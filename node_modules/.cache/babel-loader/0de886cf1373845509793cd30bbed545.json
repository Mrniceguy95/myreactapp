{"ast":null,"code":"var esprima = require(\"esprima\");\n\nvar fs = require(\"fs\");\n\nvar visitors = require(\"./extract-visitors/index\");\n\nvar transforms = require(\"./extract-transforms/index\");\n\nfunction traverse(ast, iterate) {\n  JSON.stringify(ast, function (key, value) {\n    if (typeof value !== \"object\" || value === null) {\n      return value;\n    }\n\n    iterate(value);\n    return value;\n  });\n}\n/**\n * extractor( filename|fileContent|ast )\n *\n * @filename [String]\n *\n * @fileContent [String]\n *\n * @ast [Object]\n *\n * Return an array of formatters and parsers statically extracted from given input.\n */\n\n\nfunction extractor(input) {\n  var ast;\n  var formattersAndParsers = [];\n\n  if (typeof input === \"string\") {\n    // input as a filename.\n    if (/\\.js$/i.test(input) && !/\\n/.test(input)) {\n      input = fs.readFileSync(input);\n    } // input as a file content.\n\n\n    ast = esprima.parse(input); // input as an AST.\n  } else {\n    ast = input;\n  } // Traverse AST and perform transforms.\n\n\n  traverse(ast, function (node) {\n    transforms.forEach(function (visitor) {\n      if (visitor.test(node)) {\n        visitor.transform(node);\n      }\n    });\n  }); // Traverse AST and collect formattersAndParsers.\n\n  traverse(ast, function (node) {\n    [].push.apply(formattersAndParsers, visitors.filter(function (visitor) {\n      return visitor.test(node);\n    }).map(function (visitor) {\n      return visitor.getFormatterOrParser(node);\n    }));\n  });\n  /*jslint evil: true */\n\n  return new Function(\"Globalize\", \"return [\" + formattersAndParsers.join(\", \") + \"];\");\n}\n\nmodule.exports = extractor;","map":{"version":3,"sources":["C:/Users/guido/Documents/GitHub/myreactapp/node_modules/globalize-compiler/lib/extract.js"],"names":["esprima","require","fs","visitors","transforms","traverse","ast","iterate","JSON","stringify","key","value","extractor","input","formattersAndParsers","test","readFileSync","parse","node","forEach","visitor","transform","push","apply","filter","map","getFormatterOrParser","Function","join","module","exports"],"mappings":"AAAA,IAAIA,OAAO,GAAGC,OAAO,CAAE,SAAF,CAArB;;AACA,IAAIC,EAAE,GAAGD,OAAO,CAAE,IAAF,CAAhB;;AACA,IAAIE,QAAQ,GAAGF,OAAO,CAAE,0BAAF,CAAtB;;AACA,IAAIG,UAAU,GAAGH,OAAO,CAAE,4BAAF,CAAxB;;AAEA,SAASI,QAAT,CAAmBC,GAAnB,EAAwBC,OAAxB,EAAkC;AACjCC,EAAAA,IAAI,CAACC,SAAL,CAAgBH,GAAhB,EAAqB,UAAUI,GAAV,EAAeC,KAAf,EAAuB;AAC3C,QAAK,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,KAAK,IAA5C,EAAmD;AAClD,aAAOA,KAAP;AACA;;AACDJ,IAAAA,OAAO,CAAEI,KAAF,CAAP;AACA,WAAOA,KAAP;AACA,GAND;AAOA;AAED;;;;;;;;;;;;;AAWA,SAASC,SAAT,CAAoBC,KAApB,EAA4B;AAC3B,MAAIP,GAAJ;AACA,MAAIQ,oBAAoB,GAAG,EAA3B;;AAEA,MAAK,OAAOD,KAAP,KAAiB,QAAtB,EAAiC;AAEhC;AACA,QAAO,QAAF,CAAaE,IAAb,CAAmBF,KAAnB,KAA8B,CAAG,IAAF,CAASE,IAAT,CAAeF,KAAf,CAApC,EAA6D;AAC5DA,MAAAA,KAAK,GAAGX,EAAE,CAACc,YAAH,CAAiBH,KAAjB,CAAR;AACA,KAL+B,CAOhC;;;AACAP,IAAAA,GAAG,GAAGN,OAAO,CAACiB,KAAR,CAAeJ,KAAf,CAAN,CARgC,CAUjC;AACC,GAXD,MAWO;AACNP,IAAAA,GAAG,GAAGO,KAAN;AACA,GAjB0B,CAmB3B;;;AACAR,EAAAA,QAAQ,CAAEC,GAAF,EAAO,UAAUY,IAAV,EAAiB;AAC/Bd,IAAAA,UAAU,CAACe,OAAX,CAAmB,UAAUC,OAAV,EAAoB;AACtC,UAAKA,OAAO,CAACL,IAAR,CAAcG,IAAd,CAAL,EAA4B;AAC3BE,QAAAA,OAAO,CAACC,SAAR,CAAmBH,IAAnB;AACA;AACD,KAJD;AAKA,GANO,CAAR,CApB2B,CA4B3B;;AACAb,EAAAA,QAAQ,CAAEC,GAAF,EAAO,UAAUY,IAAV,EAAiB;AAC/B,OAAGI,IAAH,CAAQC,KAAR,CAAeT,oBAAf,EAAqCX,QAAQ,CAACqB,MAAT,CAAgB,UAAUJ,OAAV,EAAoB;AACxE,aAAOA,OAAO,CAACL,IAAR,CAAcG,IAAd,CAAP;AACA,KAFoC,EAElCO,GAFkC,CAE9B,UAAUL,OAAV,EAAoB;AAC1B,aAAOA,OAAO,CAACM,oBAAR,CAA8BR,IAA9B,CAAP;AACA,KAJoC,CAArC;AAKA,GANO,CAAR;AAQA;;AACA,SAAO,IAAIS,QAAJ,CAAc,WAAd,EAA2B,aAAab,oBAAoB,CAACc,IAArB,CAA2B,IAA3B,CAAb,GAAiD,IAA5E,CAAP;AACA;;AAEDC,MAAM,CAACC,OAAP,GAAiBlB,SAAjB","sourcesContent":["var esprima = require( \"esprima\" );\nvar fs = require( \"fs\" );\nvar visitors = require( \"./extract-visitors/index\" );\nvar transforms = require( \"./extract-transforms/index\" );\n\nfunction traverse( ast, iterate ) {\n\tJSON.stringify( ast, function( key, value ) {\n\t\tif ( typeof value !== \"object\" || value === null ) {\n\t\t\treturn value;\n\t\t}\n\t\titerate( value );\n\t\treturn value;\n\t});\n}\n\n/**\n * extractor( filename|fileContent|ast )\n *\n * @filename [String]\n *\n * @fileContent [String]\n *\n * @ast [Object]\n *\n * Return an array of formatters and parsers statically extracted from given input.\n */\nfunction extractor( input ) {\n\tvar ast;\n\tvar formattersAndParsers = [];\n\n\tif ( typeof input === \"string\" ) {\n\n\t\t// input as a filename.\n\t\tif ( ( /\\.js$/i ).test( input ) && !( /\\n/ ).test( input ) ) {\n\t\t\tinput = fs.readFileSync( input );\n\t\t}\n\n\t\t// input as a file content.\n\t\tast = esprima.parse( input );\n\n\t// input as an AST.\n\t} else {\n\t\tast = input;\n\t}\n\n\t// Traverse AST and perform transforms.\n\ttraverse( ast, function( node ) {\n\t\ttransforms.forEach(function( visitor ) {\n\t\t\tif ( visitor.test( node ) ) {\n\t\t\t\tvisitor.transform( node );\n\t\t\t}\n\t\t});\n\t});\n\n\t// Traverse AST and collect formattersAndParsers.\n\ttraverse( ast, function( node ) {\n\t\t[].push.apply( formattersAndParsers, visitors.filter(function( visitor ) {\n\t\t\treturn visitor.test( node );\n\t\t}).map(function( visitor ) {\n\t\t\treturn visitor.getFormatterOrParser( node );\n\t\t}));\n\t});\n\n\t/*jslint evil: true */\n\treturn new Function( \"Globalize\", \"return [\" + formattersAndParsers.join( \", \" ) + \"];\" );\n}\n\nmodule.exports = extractor;\n"]},"metadata":{},"sourceType":"script"}