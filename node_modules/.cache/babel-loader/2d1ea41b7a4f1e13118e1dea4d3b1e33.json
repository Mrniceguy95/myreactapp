{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"C:\\\\Users\\\\guido\\\\Documents\\\\GitHub\\\\myreactapp\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nconst CommonJsRequireDependency = require(\"webpack/lib/dependencies/CommonJsRequireDependency\");\n\nconst GlobalizeCompilerHelper = require(\"./GlobalizeCompilerHelper\");\n\nconst MultiEntryPlugin = require(\"webpack/lib/MultiEntryPlugin\");\n\nconst NormalModuleReplacementPlugin = require(\"webpack/lib/NormalModuleReplacementPlugin\");\n\nconst PatchedRawModule = require(\"./PatchedRawModule\");\n\nconst SkipAMDPlugin = require(\"skip-amd-webpack-plugin\");\n\nconst util = require(\"./util\");\n/**\n * Production Mode:\n * - Have Globalize modules replaced with their runtime modules.\n * - Statically extracts formatters and parsers from user code and pre-compile\n *   them into globalize-compiled-data chunks.\n */\n\n\nclass ProductionModePlugin {\n  constructor(attributes) {\n    this.cldr = attributes.cldr || util.cldr;\n    this.developmentLocale = attributes.developmentLocale;\n    this.messages = attributes.messages && attributes.supportedLocales.reduce((sum, locale) => {\n      sum[locale] = util.readMessages(attributes.messages, locale) || {};\n      return sum;\n    }, {});\n    this.moduleFilter = util.moduleFilterFn(attributes.moduleFilter);\n    this.supportedLocales = attributes.supportedLocales;\n    this.output = attributes.output;\n    this.timeZoneData = attributes.timeZoneData || util.timeZoneData;\n    const tmpdirBase = attributes.tmpdirBase || \".\";\n    this.tmpdir = util.tmpdir(tmpdirBase);\n  }\n\n  apply(compiler) {\n    const globalizeSkipAMDPlugin = new SkipAMDPlugin(/(^|[\\/\\\\])globalize($|[\\/\\\\])/);\n    const normalModuleReplacementPlugin = new NormalModuleReplacementPlugin(/(^|[\\/\\\\])globalize$/, \"globalize/dist/globalize-runtime\");\n    const globalizeRuntimeskipAMDPlugin = new SkipAMDPlugin(/(^|[\\/\\\\])globalize-runtime($|[\\/\\\\])/);\n    const output = this.output || \"i18n-[locale].js\";\n    const globalizeCompilerHelper = new GlobalizeCompilerHelper({\n      cldr: this.cldr,\n      developmentLocale: this.developmentLocale,\n      messages: this.messages,\n      timeZoneData: this.timeZoneData,\n      tmpdir: this.tmpdir,\n      webpackCompiler: compiler\n    }); // Skip AMD part of Globalize Runtime UMD wrapper.\n\n    globalizeSkipAMDPlugin.apply(compiler); // Replaces `require(\"globalize\")` with `require(\"globalize/dist/globalize-runtime\")`.\n\n    normalModuleReplacementPlugin.apply(compiler); // Skip AMD part of Globalize Runtime UMD wrapper.\n\n    globalizeRuntimeskipAMDPlugin.apply(compiler);\n\n    const bindParser = parser => {\n      // Map each AST and its request filepath.\n      parser.hooks.program.tap(\"GlobalizePlugin\", ast => {\n        globalizeCompilerHelper.setAst(parser.state.current.request, ast);\n      }); // Precompile formatters & parsers from modules that `require(\"globalize\")`.\n\n      parser.hooks.call.for(\"require\").tap(\"GlobalizePlugin\", expr => {\n        if (expr.arguments.length !== 1) {\n          return;\n        }\n\n        const param = parser.evaluateExpression(expr.arguments[0]);\n        const request = parser.state.current.request;\n\n        if (param.isString() && param.string === \"globalize\" && this.moduleFilter(request) && !globalizeCompilerHelper.isCompiledDataModule(request)) {\n          // (a) Extract Globalize formatters & parsers, then create a custom\n          //     precompiled formatters & parsers module.\n          // (b) Add a dependency to the precompiled module. Note\n          //     `require(\"globalize\")` doesn't get replaced by `require(<custom\n          //     precompiled module>)` because we do NOT `return true` here (as\n          //     intended).\n          //\n          // Why to iterate over all the locales? Webpack allocates distinct\n          // moduleIds per locale, enabling multiple locales to be used at the\n          // same time.\n          this.supportedLocales.forEach(locale => {\n            /* a */\n            const compiledDataFilepath = globalizeCompilerHelper.createCompiledDataModule(request, locale); // Skip the AMD part of the custom precompiled formatters/parsers UMD\n            // wrapper.\n            //\n            // Note: We're hacking an already created SkipAMDPlugin instance instead\n            // of using a regular code like the below in order to take advantage of\n            // its position in the plugins list. Otherwise, it'd be too late to plugin\n            // and AMD would no longer be skipped at this point.\n            //\n            // compiler.apply(new SkipAMDPlugin(new RegExp(compiledDataFilepath));\n            //\n            // 1: Removes the leading and the trailing `/` from the regexp string.\n\n            globalizeSkipAMDPlugin.requestRegExp = new RegExp([globalizeSkipAMDPlugin.requestRegExp.toString().slice(1, -1)\n            /* 1 */\n            , util.escapeRegex(compiledDataFilepath)].join(\"|\"));\n            /* b */\n\n            const dep = new CommonJsRequireDependency(compiledDataFilepath, null);\n            dep.loc = expr.loc;\n            dep.optional = !!parser.scope.inTry;\n            parser.state.current.addDependency(dep);\n          });\n        }\n      });\n    }; // Create globalize-compiled-data chunks for the supportedLocales.\n\n\n    compiler.hooks.entryOption.tap(\"GlobalizePlugin\", context => {\n      this.supportedLocales.forEach(locale => {\n        const multiEntryPlugin = new MultiEntryPlugin(context, [], \"globalize-compiled-data-\" + locale);\n        multiEntryPlugin.apply(compiler);\n      });\n    }); // Place the Globalize compiled data modules into the globalize-compiled-data\n    // chunks.\n\n    let allModules;\n    compiler.hooks.thisCompilation.tap(\"GlobalizePlugin\", compilation => {\n      const optimizeModulesHook = modules => {\n        allModules = modules;\n      };\n\n      compilation.hooks.optimizeModules.tap(\"GlobalizePlugin\", optimizeModulesHook);\n    });\n    compiler.hooks.thisCompilation.tap(\"GlobalizePlugin\", compilation => {\n      compilation.hooks.afterOptimizeChunks.tap(\"GlobalizePlugin\", chunks => {\n        let hasAnyModuleBeenIncluded;\n        const compiledDataChunks = new Map(chunks.filter(chunk => /globalize-compiled-data/.test(chunk.name)).map(chunk => [chunk.name.replace(\"globalize-compiled-data-\", \"\"), chunk]));\n        allModules.forEach(module => {\n          let chunkRemoved;\n\n          if (globalizeCompilerHelper.isCompiledDataModule(module.request)) {\n            hasAnyModuleBeenIncluded = true;\n            module.getChunks().forEach(chunk => {\n              chunkRemoved = module.removeChunk(chunk);\n\n              if (!chunkRemoved) {\n                throw new Error(\"Failed to remove chunk \" + chunk.id + \" for module \" + module.request);\n              }\n            });\n\n            for (let _ref of compiledDataChunks.entries()) {\n              var _ref2 = _slicedToArray(_ref, 2);\n\n              let locale = _ref2[0];\n              let chunk = _ref2[1];\n\n              if (module.request.endsWith(locale + \".js\")) {\n                chunk.addModule(module);\n                module.addChunk(chunk);\n              }\n            }\n          }\n        });\n\n        for (let _ref3 of compiledDataChunks.entries()) {\n          var _ref4 = _slicedToArray(_ref3, 2);\n\n          let locale = _ref4[0];\n          let chunk = _ref4[1];\n          chunk.filenameTemplate = output.replace(\"[locale]\", locale);\n        }\n\n        if (!hasAnyModuleBeenIncluded) {\n          console.warn(\"No Globalize compiled data module found\");\n        }\n      }); // Have each globalize-compiled-data chunks include precompiled data for\n      // each supported locale. In each chunk, merge all the precompiled modules\n      // into a single one. Finally, allow the chunks to be loaded incrementally\n      // (not mutually exclusively). Details below.\n      //\n      // Up to this step, all globalize-compiled-data chunks include several\n      // precompiled modules, which have been mandatory to allow webpack to figure\n      // out the Globalize runtime dependencies. But for the final chunk we need\n      // something a little different:\n      //\n      // a) Instead of including several individual precompiled modules, it's\n      //    better (i.e., reduced size due to less boilerplate and due to deduped\n      //    formatters and parsers) having one single precompiled module for all\n      //    these individual modules.\n      //\n      // b) globalize-compiled-data chunks shouldn't be mutually exclusive to each\n      //    other, but users should be able to load two or more of these chunks\n      //    and be able to switch from one locale to another dynamically during\n      //    runtime.\n      //\n      //    Some background: by having each individual precompiled module defining\n      //    the formatters and parsers for its individual parents, what happens is\n      //    that each parent will load the globalize precompiled data by its id\n      //    with __webpack_require__(id). These ids are equally defined by the\n      //    globalize-compiled-data chunks (each chunk including data for a\n      //    certain locale). When one chunk is loaded, these ids get defined by\n      //    webpack. When a second chunk is loaded, these ids would get\n      //    overwritten.\n      //\n      //    Therefore, instead of having each individual precompiled module\n      //    defining the formatters and parsers for its individual parents, we\n      //    actually simplify them by returning Globalize only. The precompiled\n      //    content for the whole set of formatters and parsers are going to be\n      //    included in the entry module of each of these chunks.\n      //    So, we accomplish what we need: have the data loaded as soon as the\n      //    chunk is loaded, which means it will be available when each\n      //    individual parent code needs it.\n\n      compilation.hooks.afterOptimizeModuleIds.tap(\"GlobalizePlugin\", () => {\n        const globalizeModuleIds = [];\n        const globalizeModuleIdsMap = {};\n        compilation.chunks.forEach(chunk => {\n          for (const module of chunk.modulesIterable) {\n            let aux;\n            const request = module.request;\n\n            if (request && util.isGlobalizeRuntimeModule(request)) {\n              // While request has the full pathname, aux has something like\n              // \"globalize/dist/globalize-runtime/date\".\n              aux = request.split(/[\\/\\\\]/);\n              aux = aux.slice(aux.lastIndexOf(\"globalize\")).join(\"/\").replace(/\\.js$/, \"\"); // some plugins, like HashedModuleIdsPlugin, may change module ids\n              // into strings.\n\n              let moduleId = module.id;\n\n              if (typeof moduleId === \"string\") {\n                moduleId = JSON.stringify(moduleId);\n              }\n\n              globalizeModuleIds.push(moduleId);\n              globalizeModuleIdsMap[aux] = moduleId;\n            }\n          }\n        }); // rewrite the modules in the localized chunks:\n        //   - entry module will contain the compiled formatters and parsers\n        //   - non-entry modules will be rewritten to export globalize\n\n        compilation.chunks.filter(chunk => /globalize-compiled-data/.test(chunk.name)).forEach(chunk => {\n          // remove dead entry module for these reasons\n          //   - because the module has no dependencies, it won't be rendered\n          //     with __webpack_require__, making it difficult to modify its\n          //     source in a way that can import globalize\n          //\n          //   - it was a placeholder MultiModule that held no content, created\n          //     when we added a MultiEntryPlugin\n          //\n          //   - the true entry module should be globalize-compiled-data\n          //     module, which has been created as a NormalModule\n          chunk.removeModule(chunk.entryModule);\n          chunk.entryModule = chunk.getModules().find(module => module.context.endsWith(\".tmp-globalize-webpack\"));\n          const newModules = Array.from(chunk.modulesIterable, module => {\n            let fnContent;\n\n            if (module === chunk.entryModule) {\n              // rewrite entry module to contain the globalize-compiled-data\n              const locale = chunk.name.replace(\"globalize-compiled-data-\", \"\");\n              fnContent = globalizeCompilerHelper.compile(locale).replace(\"typeof define === \\\"function\\\" && define.amd\", \"false\").replace(/require\\(\"([^)]+)\"\\)/g, (garbage, moduleName) => {\n                return `__webpack_require__(${globalizeModuleIdsMap[moduleName]})`;\n              });\n            } else {\n              // rewrite all other modules in this chunk as proxies for\n              // Globalize\n              fnContent = `module.exports = __webpack_require__(${globalizeModuleIds[0]});`;\n            } // The `module` object in scope here is in each locale chunk, and\n            // any modifications we make will be rendered into every locale\n            // chunk. Create a new module to contain the locale-specific source\n            // modifications we've made.\n\n\n            const newModule = new PatchedRawModule(fnContent);\n            newModule.context = module.context;\n            newModule.id = module.id;\n            newModule.dependencies = module.dependencies;\n\n            const createHash = require(\"webpack/lib/util/createHash\");\n\n            const outputOptions = compilation.outputOptions;\n            const hashFunction = outputOptions.hashFunction;\n            const hashDigest = outputOptions.hashDigest;\n            const hashDigestLength = outputOptions.hashDigestLength;\n            const newModuleHash = createHash(hashFunction);\n            newModule.updateHash(newModuleHash);\n            newModule.hash = newModuleHash.digest(hashDigest);\n            newModule.renderedHash = newModule.hash.substr(0, hashDigestLength); // Essentially set the buildInfo.cacheable\n\n            newModule.build(null, null, null, null, () => {});\n            return newModule;\n          }); // remove old modules with modified clones\n          // chunk.removeModule doesn't always find the module to remove\n          // ¯\\_(ツ)_/¯, so we have to be be a bit more thorough here.\n\n          for (const module of chunk.modulesIterable) {\n            module.removeChunk(chunk);\n          } // install the rewritten modules\n\n\n          chunk.setModules(newModules);\n        });\n      }); // Set the right chunks order. The globalize-compiled-data chunks must\n      // appear after globalize runtime modules, but before any app code.\n\n      compilation.hooks.optimizeChunkOrder.tap(\"GlobalizePlugin\", chunks => {\n        const cachedChunkScore = {};\n\n        function moduleScore(module) {\n          if (module.request && util.isGlobalizeRuntimeModule(module.request)) {\n            return 1;\n          } else if (module.request && globalizeCompilerHelper.isCompiledDataModule(module.request)) {\n            return 0;\n          }\n\n          return -1;\n        }\n\n        function chunkScore(chunk) {\n          if (!cachedChunkScore[chunk.name]) {\n            cachedChunkScore[chunk.name] = chunk.getModules().reduce((sum, module) => {\n              return Math.max(sum, moduleScore(module));\n            }, -1);\n          }\n\n          return cachedChunkScore[chunk.name];\n        }\n\n        chunks.sort((a, b) => chunkScore(a) - chunkScore(b));\n      });\n    });\n    compiler.hooks.normalModuleFactory.tap(\"GlobalizePlugin\", factory => {\n      factory.hooks.parser.for(\"javascript/auto\").tap(\"GlobalizePlugin\", bindParser);\n    });\n  }\n\n}\n\nmodule.exports = ProductionModePlugin;","map":{"version":3,"sources":["C:/Users/guido/Documents/GitHub/myreactapp/node_modules/globalize-webpack-plugin/ProductionModePlugin.js"],"names":["CommonJsRequireDependency","require","GlobalizeCompilerHelper","MultiEntryPlugin","NormalModuleReplacementPlugin","PatchedRawModule","SkipAMDPlugin","util","ProductionModePlugin","constructor","attributes","cldr","developmentLocale","messages","supportedLocales","reduce","sum","locale","readMessages","moduleFilter","moduleFilterFn","output","timeZoneData","tmpdirBase","tmpdir","apply","compiler","globalizeSkipAMDPlugin","normalModuleReplacementPlugin","globalizeRuntimeskipAMDPlugin","globalizeCompilerHelper","webpackCompiler","bindParser","parser","hooks","program","tap","ast","setAst","state","current","request","call","for","expr","arguments","length","param","evaluateExpression","isString","string","isCompiledDataModule","forEach","compiledDataFilepath","createCompiledDataModule","requestRegExp","RegExp","toString","slice","escapeRegex","join","dep","loc","optional","scope","inTry","addDependency","entryOption","context","multiEntryPlugin","allModules","thisCompilation","compilation","optimizeModulesHook","modules","optimizeModules","afterOptimizeChunks","chunks","hasAnyModuleBeenIncluded","compiledDataChunks","Map","filter","chunk","test","name","map","replace","module","chunkRemoved","getChunks","removeChunk","Error","id","entries","endsWith","addModule","addChunk","filenameTemplate","console","warn","afterOptimizeModuleIds","globalizeModuleIds","globalizeModuleIdsMap","modulesIterable","aux","isGlobalizeRuntimeModule","split","lastIndexOf","moduleId","JSON","stringify","push","removeModule","entryModule","getModules","find","newModules","Array","from","fnContent","compile","garbage","moduleName","newModule","dependencies","createHash","outputOptions","hashFunction","hashDigest","hashDigestLength","newModuleHash","updateHash","hash","digest","renderedHash","substr","build","setModules","optimizeChunkOrder","cachedChunkScore","moduleScore","chunkScore","Math","max","sort","a","b","normalModuleFactory","factory","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst CommonJsRequireDependency = require(\"webpack/lib/dependencies/CommonJsRequireDependency\");\nconst GlobalizeCompilerHelper = require(\"./GlobalizeCompilerHelper\");\nconst MultiEntryPlugin = require(\"webpack/lib/MultiEntryPlugin\");\nconst NormalModuleReplacementPlugin = require(\"webpack/lib/NormalModuleReplacementPlugin\");\nconst PatchedRawModule = require(\"./PatchedRawModule\");\nconst SkipAMDPlugin = require(\"skip-amd-webpack-plugin\");\nconst util = require(\"./util\");\n\n/**\n * Production Mode:\n * - Have Globalize modules replaced with their runtime modules.\n * - Statically extracts formatters and parsers from user code and pre-compile\n *   them into globalize-compiled-data chunks.\n */\nclass ProductionModePlugin {\n  constructor(attributes) {\n    this.cldr = attributes.cldr || util.cldr;\n    this.developmentLocale = attributes.developmentLocale;\n    this.messages = attributes.messages && attributes.supportedLocales.reduce((sum, locale) => {\n      sum[locale] = util.readMessages(attributes.messages, locale) || {};\n      return sum;\n    }, {});\n    this.moduleFilter = util.moduleFilterFn(attributes.moduleFilter);\n    this.supportedLocales = attributes.supportedLocales;\n    this.output = attributes.output;\n    this.timeZoneData = attributes.timeZoneData || util.timeZoneData;\n    const tmpdirBase = attributes.tmpdirBase || \".\";\n    this.tmpdir = util.tmpdir(tmpdirBase);\n  }\n\n  apply(compiler) {\n    const globalizeSkipAMDPlugin = new SkipAMDPlugin(/(^|[\\/\\\\])globalize($|[\\/\\\\])/);\n    const normalModuleReplacementPlugin = new NormalModuleReplacementPlugin(/(^|[\\/\\\\])globalize$/, \"globalize/dist/globalize-runtime\");\n    const globalizeRuntimeskipAMDPlugin = new SkipAMDPlugin(/(^|[\\/\\\\])globalize-runtime($|[\\/\\\\])/);\n    const output = this.output || \"i18n-[locale].js\";\n    const globalizeCompilerHelper = new GlobalizeCompilerHelper({\n      cldr: this.cldr,\n      developmentLocale: this.developmentLocale,\n      messages: this.messages,\n      timeZoneData: this.timeZoneData,\n      tmpdir: this.tmpdir,\n      webpackCompiler: compiler\n    });\n\n    // Skip AMD part of Globalize Runtime UMD wrapper.\n    globalizeSkipAMDPlugin.apply(compiler);\n\n    // Replaces `require(\"globalize\")` with `require(\"globalize/dist/globalize-runtime\")`.\n    normalModuleReplacementPlugin.apply(compiler);\n\n    // Skip AMD part of Globalize Runtime UMD wrapper.\n    globalizeRuntimeskipAMDPlugin.apply(compiler);\n\n    const bindParser = (parser) => {\n      // Map each AST and its request filepath.\n      parser.hooks.program.tap(\"GlobalizePlugin\", (ast) => {\n        globalizeCompilerHelper.setAst(parser.state.current.request, ast);\n      });\n\n      // Precompile formatters & parsers from modules that `require(\"globalize\")`.\n      parser.hooks.call\n        .for(\"require\")\n        .tap(\"GlobalizePlugin\", (expr) => {\n          if (expr.arguments.length !== 1) {\n            return;\n          }\n          const param = parser.evaluateExpression(expr.arguments[0]);\n          const request = parser.state.current.request;\n          if (param.isString() && param.string === \"globalize\" && this.moduleFilter(request) &&\n            !(globalizeCompilerHelper.isCompiledDataModule(request))) {\n\n            // (a) Extract Globalize formatters & parsers, then create a custom\n            //     precompiled formatters & parsers module.\n            // (b) Add a dependency to the precompiled module. Note\n            //     `require(\"globalize\")` doesn't get replaced by `require(<custom\n            //     precompiled module>)` because we do NOT `return true` here (as\n            //     intended).\n            //\n            // Why to iterate over all the locales? Webpack allocates distinct\n            // moduleIds per locale, enabling multiple locales to be used at the\n            // same time.\n            this.supportedLocales.forEach((locale) => {\n              /* a */\n              const compiledDataFilepath = globalizeCompilerHelper.createCompiledDataModule(request, locale);\n\n              // Skip the AMD part of the custom precompiled formatters/parsers UMD\n              // wrapper.\n              //\n              // Note: We're hacking an already created SkipAMDPlugin instance instead\n              // of using a regular code like the below in order to take advantage of\n              // its position in the plugins list. Otherwise, it'd be too late to plugin\n              // and AMD would no longer be skipped at this point.\n              //\n              // compiler.apply(new SkipAMDPlugin(new RegExp(compiledDataFilepath));\n              //\n              // 1: Removes the leading and the trailing `/` from the regexp string.\n              globalizeSkipAMDPlugin.requestRegExp = new RegExp([\n                globalizeSkipAMDPlugin.requestRegExp.toString().slice(1, -1)/* 1 */,\n                util.escapeRegex(compiledDataFilepath)\n              ].join(\"|\"));\n\n              /* b */\n              const dep = new CommonJsRequireDependency(compiledDataFilepath, null);\n              dep.loc = expr.loc;\n              dep.optional = !!parser.scope.inTry;\n              parser.state.current.addDependency(dep);\n            });\n          }\n        });\n    };\n\n    // Create globalize-compiled-data chunks for the supportedLocales.\n    compiler.hooks.entryOption.tap(\"GlobalizePlugin\", (context) => {\n      this.supportedLocales.forEach((locale) => {\n        const multiEntryPlugin = new MultiEntryPlugin(context, [], \"globalize-compiled-data-\" + locale);\n        multiEntryPlugin.apply(compiler);\n      });\n    });\n\n    // Place the Globalize compiled data modules into the globalize-compiled-data\n    // chunks.\n    let allModules;\n    compiler.hooks.thisCompilation.tap(\"GlobalizePlugin\", (compilation) => {\n      const optimizeModulesHook = (modules) => {\n        allModules = modules;\n      };\n\n      compilation.hooks.optimizeModules.tap(\"GlobalizePlugin\", optimizeModulesHook);\n    });\n\n    compiler.hooks.thisCompilation.tap(\"GlobalizePlugin\", (compilation) => {\n      compilation.hooks.afterOptimizeChunks.tap(\"GlobalizePlugin\", (chunks) => {\n        let hasAnyModuleBeenIncluded;\n        const compiledDataChunks = new Map(\n          chunks.filter((chunk) => /globalize-compiled-data/.test(chunk.name)).\n          map(chunk => [chunk.name.replace(\"globalize-compiled-data-\", \"\"), chunk] )\n        );\n\n        allModules.forEach((module) => {\n          let chunkRemoved;\n          if (globalizeCompilerHelper.isCompiledDataModule(module.request)) {\n            hasAnyModuleBeenIncluded = true;\n            module.getChunks().forEach((chunk) => {\n              chunkRemoved = module.removeChunk(chunk);\n              if (!chunkRemoved) {\n                throw new Error(\"Failed to remove chunk \" + chunk.id + \" for module \" + module.request);\n              }\n            });\n            for (let [locale, chunk] of compiledDataChunks.entries()) {\n              if (module.request.endsWith(locale + \".js\")) {\n                chunk.addModule(module);\n                module.addChunk(chunk);\n              }\n            }\n          }\n        });\n        for (let [locale, chunk] of compiledDataChunks.entries()) {\n          chunk.filenameTemplate = output.replace(\"[locale]\", locale);\n        }\n        if(!hasAnyModuleBeenIncluded) {\n          console.warn(\"No Globalize compiled data module found\");\n        }\n      });\n\n      // Have each globalize-compiled-data chunks include precompiled data for\n      // each supported locale. In each chunk, merge all the precompiled modules\n      // into a single one. Finally, allow the chunks to be loaded incrementally\n      // (not mutually exclusively). Details below.\n      //\n      // Up to this step, all globalize-compiled-data chunks include several\n      // precompiled modules, which have been mandatory to allow webpack to figure\n      // out the Globalize runtime dependencies. But for the final chunk we need\n      // something a little different:\n      //\n      // a) Instead of including several individual precompiled modules, it's\n      //    better (i.e., reduced size due to less boilerplate and due to deduped\n      //    formatters and parsers) having one single precompiled module for all\n      //    these individual modules.\n      //\n      // b) globalize-compiled-data chunks shouldn't be mutually exclusive to each\n      //    other, but users should be able to load two or more of these chunks\n      //    and be able to switch from one locale to another dynamically during\n      //    runtime.\n      //\n      //    Some background: by having each individual precompiled module defining\n      //    the formatters and parsers for its individual parents, what happens is\n      //    that each parent will load the globalize precompiled data by its id\n      //    with __webpack_require__(id). These ids are equally defined by the\n      //    globalize-compiled-data chunks (each chunk including data for a\n      //    certain locale). When one chunk is loaded, these ids get defined by\n      //    webpack. When a second chunk is loaded, these ids would get\n      //    overwritten.\n      //\n      //    Therefore, instead of having each individual precompiled module\n      //    defining the formatters and parsers for its individual parents, we\n      //    actually simplify them by returning Globalize only. The precompiled\n      //    content for the whole set of formatters and parsers are going to be\n      //    included in the entry module of each of these chunks.\n      //    So, we accomplish what we need: have the data loaded as soon as the\n      //    chunk is loaded, which means it will be available when each\n      //    individual parent code needs it.\n      compilation.hooks.afterOptimizeModuleIds.tap(\"GlobalizePlugin\", () => {\n        const globalizeModuleIds = [];\n        const globalizeModuleIdsMap = {};\n\n        compilation.chunks.forEach((chunk) => {\n          for (const module of chunk.modulesIterable) {\n            let aux;\n            const request = module.request;\n            if (request && util.isGlobalizeRuntimeModule(request)) {\n              // While request has the full pathname, aux has something like\n              // \"globalize/dist/globalize-runtime/date\".\n              aux = request.split(/[\\/\\\\]/);\n              aux = aux.slice(aux.lastIndexOf(\"globalize\")).join(\"/\").replace(/\\.js$/, \"\");\n\n              // some plugins, like HashedModuleIdsPlugin, may change module ids\n              // into strings.\n              let moduleId = module.id;\n              if (typeof moduleId === \"string\") {\n                moduleId = JSON.stringify(moduleId);\n              }\n\n              globalizeModuleIds.push(moduleId);\n              globalizeModuleIdsMap[aux] = moduleId;\n            }\n          }\n        });\n\n        // rewrite the modules in the localized chunks:\n        //   - entry module will contain the compiled formatters and parsers\n        //   - non-entry modules will be rewritten to export globalize\n        compilation.chunks\n          .filter((chunk) => /globalize-compiled-data/.test(chunk.name))\n          .forEach((chunk) => {\n            // remove dead entry module for these reasons\n            //   - because the module has no dependencies, it won't be rendered\n            //     with __webpack_require__, making it difficult to modify its\n            //     source in a way that can import globalize\n            //\n            //   - it was a placeholder MultiModule that held no content, created\n            //     when we added a MultiEntryPlugin\n            //\n            //   - the true entry module should be globalize-compiled-data\n            //     module, which has been created as a NormalModule\n            chunk.removeModule(chunk.entryModule);\n            chunk.entryModule = chunk.getModules().find((module) => module.context.endsWith(\".tmp-globalize-webpack\"));\n\n            const newModules = Array.from(chunk.modulesIterable, (module) => {\n              let fnContent;\n              if (module === chunk.entryModule) {\n                // rewrite entry module to contain the globalize-compiled-data\n                const locale = chunk.name.replace(\"globalize-compiled-data-\", \"\");\n                fnContent = globalizeCompilerHelper.compile(locale)\n                  .replace(\"typeof define === \\\"function\\\" && define.amd\", \"false\")\n                  .replace(/require\\(\"([^)]+)\"\\)/g, (garbage, moduleName) => {\n                    return `__webpack_require__(${globalizeModuleIdsMap[moduleName]})`;\n                  });\n              } else {\n                // rewrite all other modules in this chunk as proxies for\n                // Globalize\n                fnContent = `module.exports = __webpack_require__(${globalizeModuleIds[0]});`;\n              }\n\n              // The `module` object in scope here is in each locale chunk, and\n              // any modifications we make will be rendered into every locale\n              // chunk. Create a new module to contain the locale-specific source\n              // modifications we've made.\n              const newModule = new PatchedRawModule(fnContent);\n              newModule.context = module.context;\n              newModule.id = module.id;\n              newModule.dependencies = module.dependencies;\n\n              const createHash = require(\"webpack/lib/util/createHash\");\n              const outputOptions = compilation.outputOptions;\n              const hashFunction = outputOptions.hashFunction;\n              const hashDigest = outputOptions.hashDigest;\n              const hashDigestLength = outputOptions.hashDigestLength;\n              const newModuleHash = createHash(hashFunction);\n\n              newModule.updateHash(newModuleHash);\n              newModule.hash = newModuleHash.digest(hashDigest);\n              newModule.renderedHash = newModule.hash.substr(0, hashDigestLength);\n              // Essentially set the buildInfo.cacheable\n              newModule.build(null, null, null, null, () => {});\n\n              return newModule;\n            });\n\n            // remove old modules with modified clones\n            // chunk.removeModule doesn't always find the module to remove\n            // ¯\\_(ツ)_/¯, so we have to be be a bit more thorough here.\n            for (const module of chunk.modulesIterable) {\n              module.removeChunk(chunk);\n            }\n\n            // install the rewritten modules\n            chunk.setModules(newModules);\n          });\n      });\n\n      // Set the right chunks order. The globalize-compiled-data chunks must\n      // appear after globalize runtime modules, but before any app code.\n      compilation.hooks.optimizeChunkOrder.tap(\"GlobalizePlugin\", (chunks) => {\n        const cachedChunkScore = {};\n        function moduleScore(module) {\n          if (module.request && util.isGlobalizeRuntimeModule(module.request)) {\n            return 1;\n          } else if (module.request && globalizeCompilerHelper.isCompiledDataModule(module.request)) {\n            return 0;\n          }\n          return -1;\n        }\n        function chunkScore(chunk) {\n          if (!cachedChunkScore[chunk.name]) {\n            cachedChunkScore[chunk.name] = chunk.getModules().reduce((sum, module) => {\n              return Math.max(sum, moduleScore(module));\n            }, -1);\n          }\n          return cachedChunkScore[chunk.name];\n        }\n        chunks.sort((a, b) => chunkScore(a) - chunkScore(b));\n      });\n    });\n\n    compiler.hooks.normalModuleFactory.tap(\"GlobalizePlugin\", factory => {\n      factory.hooks.parser.for(\"javascript/auto\").tap(\"GlobalizePlugin\", bindParser);\n    });\n  }\n}\n\nmodule.exports = ProductionModePlugin;\n"]},"metadata":{},"sourceType":"script"}