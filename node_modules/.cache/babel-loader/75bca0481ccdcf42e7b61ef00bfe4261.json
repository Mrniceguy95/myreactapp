{"ast":null,"code":"\"use strict\";\n\nconst fs = require(\"fs\");\n\nconst globalizeCompiler = require(\"globalize-compiler\");\n\nconst path = require(\"path\");\n\nconst _require = require(\"tapable\"),\n      SyncHook = _require.SyncHook;\n\nclass GlobalizeCompilerHelper {\n  constructor(attributes) {\n    this.asts = {};\n    this.extracts = [];\n    this.extractsMap = {};\n    this.modules = {};\n    this.cldr = attributes.cldr;\n    this.developmentLocale = attributes.developmentLocale;\n    this.messages = attributes.messages || {};\n    this.timeZoneData = attributes.timeZoneData;\n    this.tmpdir = attributes.tmpdir;\n    this.webpackCompiler = attributes.webpackCompiler;\n    this.webpackCompiler.hooks.globalizeBeforeCompileExtracts = new SyncHook([\"locale\", \"attributes\", \"request\"]);\n  }\n\n  setAst(request, ast) {\n    this.asts[request] = ast;\n  }\n\n  getExtract(request) {\n    let ast, extract;\n\n    if (!this.extractsMap[request]) {\n      ast = this.asts[request];\n      extract = globalizeCompiler.extract(ast);\n      this.extractsMap[request] = extract;\n      this.extracts.push(extract);\n    }\n\n    return this.extractsMap[request];\n  }\n\n  createCompiledDataModule(request, locale) {\n    const filepath = this.getModuleFilepath(request, locale);\n    this.modules[filepath] = true;\n    fs.writeFileSync(filepath, this.compile(locale, request));\n    return filepath;\n  }\n\n  getModuleFilepath(request, locale) {\n    // Always append .js to the file path to cater for non-JS files (e.g. .coffee).\n    return path.join(this.tmpdir, request.replace(/.*!/, \"\").replace(/[\\/\\\\?\" :\\.]/g, \"-\") + \"-\" + locale + \".js\");\n  }\n\n  compile(locale, request) {\n    let content;\n    const attributes = {\n      cldr: this.cldr,\n      defaultLocale: locale,\n      extracts: request ? this.getExtract(request) : this.extracts,\n      timeZoneData: this.timeZoneData\n    };\n\n    if (this.messages[locale]) {\n      attributes.messages = this.messages[locale];\n    }\n\n    this.webpackCompiler.hooks.globalizeBeforeCompileExtracts.call(locale, attributes, request);\n\n    try {\n      content = globalizeCompiler.compileExtracts(attributes);\n    } catch (e) {\n      // The only case to throw is when it's missing formatters/parsers for the\n      // whole chunk, i.e., when `request` isn't present; or when error is\n      // something else obviously. If a particular file misses formatters/parsers,\n      // it can be safely ignored (i.e., by using a stub content), because in the\n      // end generating the content for the whole chunk will ultimately verify\n      // whether or not formatters/parsers has been used.\n      if (!/No formatters or parsers has been provided/.test(e.message) || !request) {\n        throw e;\n      }\n\n      content = \"module.exports = require(\\\"globalize\\\");\";\n    } // Inject set defaultLocale.\n\n\n    return content.replace(/(return Globalize;)/, \"Globalize.locale(\\\"\" + locale + \"\\\"); $1\");\n  }\n\n  isCompiledDataModule(request) {\n    return request && this.modules[request.replace(/.*!/, \"\")];\n  }\n\n}\n\nmodule.exports = GlobalizeCompilerHelper;","map":{"version":3,"sources":["C:/Users/guido/Documents/GitHub/myreactapp/node_modules/globalize-webpack-plugin/GlobalizeCompilerHelper.js"],"names":["fs","require","globalizeCompiler","path","SyncHook","GlobalizeCompilerHelper","constructor","attributes","asts","extracts","extractsMap","modules","cldr","developmentLocale","messages","timeZoneData","tmpdir","webpackCompiler","hooks","globalizeBeforeCompileExtracts","setAst","request","ast","getExtract","extract","push","createCompiledDataModule","locale","filepath","getModuleFilepath","writeFileSync","compile","join","replace","content","defaultLocale","call","compileExtracts","e","test","message","isCompiledDataModule","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst fs = require(\"fs\");\nconst globalizeCompiler = require(\"globalize-compiler\");\nconst path = require(\"path\");\nconst { SyncHook } = require(\"tapable\");\n\nclass GlobalizeCompilerHelper {\n  constructor(attributes) {\n    this.asts = {};\n    this.extracts = [];\n    this.extractsMap = {};\n    this.modules = {};\n\n    this.cldr = attributes.cldr;\n    this.developmentLocale = attributes.developmentLocale;\n    this.messages = attributes.messages || {};\n    this.timeZoneData = attributes.timeZoneData;\n    this.tmpdir = attributes.tmpdir;\n    this.webpackCompiler = attributes.webpackCompiler;\n    this.webpackCompiler.hooks.globalizeBeforeCompileExtracts = new SyncHook([\"locale\", \"attributes\", \"request\"]);\n  }\n\n  setAst(request, ast) {\n    this.asts[request] = ast;\n  }\n\n  getExtract(request) {\n    let ast, extract;\n    if(!this.extractsMap[request]) {\n      ast = this.asts[request];\n      extract = globalizeCompiler.extract(ast);\n      this.extractsMap[request] = extract;\n      this.extracts.push(extract);\n    }\n    return this.extractsMap[request];\n  }\n\n  createCompiledDataModule(request, locale) {\n    const filepath = this.getModuleFilepath(request, locale);\n    this.modules[filepath] = true;\n\n    fs.writeFileSync(filepath, this.compile(locale, request));\n\n    return filepath;\n  }\n\n  getModuleFilepath(request, locale) {\n    // Always append .js to the file path to cater for non-JS files (e.g. .coffee).\n    return path.join(this.tmpdir, request.replace(/.*!/, \"\").replace(/[\\/\\\\?\" :\\.]/g, \"-\") + \"-\" + locale + \".js\");\n  }\n\n  compile(locale, request) {\n    let content;\n\n    const attributes = {\n      cldr: this.cldr,\n      defaultLocale: locale,\n      extracts: request ? this.getExtract(request) : this.extracts,\n      timeZoneData: this.timeZoneData\n    };\n\n    if (this.messages[locale]) {\n      attributes.messages = this.messages[locale];\n    }\n\n    this.webpackCompiler.hooks.globalizeBeforeCompileExtracts.call(locale, attributes, request);\n\n    try {\n      content = globalizeCompiler.compileExtracts(attributes);\n    } catch(e) {\n      // The only case to throw is when it's missing formatters/parsers for the\n      // whole chunk, i.e., when `request` isn't present; or when error is\n      // something else obviously. If a particular file misses formatters/parsers,\n      // it can be safely ignored (i.e., by using a stub content), because in the\n      // end generating the content for the whole chunk will ultimately verify\n      // whether or not formatters/parsers has been used.\n      if (!/No formatters or parsers has been provided/.test(e.message) || !request) {\n        throw e;\n      }\n      content = \"module.exports = require(\\\"globalize\\\");\";\n    }\n\n    // Inject set defaultLocale.\n    return content.replace(/(return Globalize;)/, \"Globalize.locale(\\\"\" + locale + \"\\\"); $1\");\n  }\n\n  isCompiledDataModule(request) {\n    return request && this.modules[request.replace(/.*!/, \"\")];\n  }\n}\n\nmodule.exports = GlobalizeCompilerHelper;\n"]},"metadata":{},"sourceType":"script"}