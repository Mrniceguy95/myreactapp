{"ast":null,"code":"/**\n * Globalize v1.4.2\n *\n * http://github.com/jquery/globalize\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2019-03-07T13:47Z\n */\n\n/*!\n * Globalize v1.4.2 2019-03-07T13:47Z Released under the MIT license\n * http://git.io/TrdQbw\n */\n(function (root, factory) {\n  // UMD returnExports\n  if (typeof define === \"function\" && define.amd) {\n    // AMD\n    define([\"cldr\", \"../globalize\", \"cldr/event\", \"cldr/supplemental\"], factory);\n  } else if (typeof exports === \"object\") {\n    // Node, CommonJS\n    module.exports = factory(require(\"cldrjs\"), require(\"../globalize\"));\n  } else {\n    // Global\n    factory(root.Cldr, root.Globalize);\n  }\n})(this, function (Cldr, Globalize) {\n  var createError = Globalize._createError,\n      regexpEscape = Globalize._regexpEscape,\n      runtimeBind = Globalize._runtimeBind,\n      stringPad = Globalize._stringPad,\n      validateCldr = Globalize._validateCldr,\n      validateDefaultLocale = Globalize._validateDefaultLocale,\n      validateParameterPresence = Globalize._validateParameterPresence,\n      validateParameterRange = Globalize._validateParameterRange,\n      validateParameterType = Globalize._validateParameterType,\n      validateParameterTypePlainObject = Globalize._validateParameterTypePlainObject;\n\n  var createErrorUnsupportedFeature = function (feature) {\n    return createError(\"E_UNSUPPORTED\", \"Unsupported {feature}.\", {\n      feature: feature\n    });\n  };\n\n  var validateParameterTypeNumber = function (value, name) {\n    validateParameterType(value, name, value === undefined || typeof value === \"number\", \"Number\");\n  };\n\n  var validateParameterTypeString = function (value, name) {\n    validateParameterType(value, name, value === undefined || typeof value === \"string\", \"a string\");\n  };\n  /**\n   * EBNF representation:\n   *\n   * compact_pattern_re =       prefix?\n   *                            number_pattern_re\n   *                            suffix?\n   *\n   * number_pattern_re =        0+\n   *\n   * Regexp groups:\n   *\n   *  0: compact_pattern_re\n   *  1: prefix\n   *  2: number_pattern_re (the number pattern to use in compact mode)\n   *  3: suffix\n   */\n\n\n  var numberCompactPatternRe = /^([^0]*)(0+)([^0]*)$/;\n  /**\n   * goupingSeparator( number, primaryGroupingSize, secondaryGroupingSize )\n   *\n   * @number [Number].\n   *\n   * @primaryGroupingSize [Number]\n   *\n   * @secondaryGroupingSize [Number]\n   *\n   * Return the formatted number with group separator.\n   */\n\n  var numberFormatGroupingSeparator = function (number, primaryGroupingSize, secondaryGroupingSize) {\n    var index,\n        currentGroupingSize = primaryGroupingSize,\n        ret = \"\",\n        sep = \",\",\n        switchToSecondary = secondaryGroupingSize ? true : false;\n    number = String(number).split(\".\");\n    index = number[0].length;\n\n    while (index > currentGroupingSize) {\n      ret = number[0].slice(index - currentGroupingSize, index) + (ret.length ? sep : \"\") + ret;\n      index -= currentGroupingSize;\n\n      if (switchToSecondary) {\n        currentGroupingSize = secondaryGroupingSize;\n        switchToSecondary = false;\n      }\n    }\n\n    number[0] = number[0].slice(0, index) + (ret.length ? sep : \"\") + ret;\n    return number.join(\".\");\n  };\n  /**\n   * integerFractionDigits( number, minimumIntegerDigits, minimumFractionDigits,\n   * maximumFractionDigits, round, roundIncrement )\n   *\n   * @number [Number]\n   *\n   * @minimumIntegerDigits [Number]\n   *\n   * @minimumFractionDigits [Number]\n   *\n   * @maximumFractionDigits [Number]\n   *\n   * @round [Function]\n   *\n   * @roundIncrement [Function]\n   *\n   * Return the formatted integer and fraction digits.\n   */\n\n\n  var numberFormatIntegerFractionDigits = function (number, minimumIntegerDigits, minimumFractionDigits, maximumFractionDigits, round, roundIncrement) {\n    // Fraction\n    if (maximumFractionDigits) {\n      // Rounding\n      if (roundIncrement) {\n        number = round(number, roundIncrement); // Maximum fraction digits\n      } else {\n        number = round(number, {\n          exponent: -maximumFractionDigits\n        });\n      }\n    } else {\n      number = round(number);\n    }\n\n    number = String(number); // Maximum integer digits (post string phase)\n\n    if (maximumFractionDigits && /e-/.test(number)) {\n      // Use toFixed( maximumFractionDigits ) to make sure small numbers like 1e-7 are\n      // displayed using plain digits instead of scientific notation.\n      // 1: Remove leading decimal zeros.\n      // 2: Remove leading decimal separator.\n      // Note: String() is still preferred so it doesn't mess up with a number precision\n      // unnecessarily, e.g., (123456789.123).toFixed(10) === \"123456789.1229999959\",\n      // String(123456789.123) === \"123456789.123\".\n      number = (+number).toFixed(maximumFractionDigits).replace(/0+$/, \"\")\n      /* 1 */\n      .replace(/\\.$/, \"\")\n      /* 2 */\n      ;\n    } // Minimum fraction digits (post string phase)\n\n\n    if (minimumFractionDigits) {\n      number = number.split(\".\");\n      number[1] = stringPad(number[1] || \"\", minimumFractionDigits, true);\n      number = number.join(\".\");\n    } // Minimum integer digits\n\n\n    if (minimumIntegerDigits) {\n      number = number.split(\".\");\n      number[0] = stringPad(number[0], minimumIntegerDigits);\n      number = number.join(\".\");\n    }\n\n    return number;\n  };\n  /**\n   * toPrecision( number, precision, round )\n   *\n   * @number (Number)\n   *\n   * @precision (Number) significant figures precision (not decimal precision).\n   *\n   * @round (Function)\n   *\n   * Return number.toPrecision( precision ) using the given round function.\n   */\n\n\n  var numberToPrecision = function (number, precision, round) {\n    var roundOrder;\n    roundOrder = Math.ceil(Math.log(Math.abs(number)) / Math.log(10));\n    roundOrder -= precision;\n    return round(number, {\n      exponent: roundOrder\n    });\n  };\n  /**\n   * toPrecision( number, minimumSignificantDigits, maximumSignificantDigits, round )\n   *\n   * @number [Number]\n   *\n   * @minimumSignificantDigits [Number]\n   *\n   * @maximumSignificantDigits [Number]\n   *\n   * @round [Function]\n   *\n   * Return the formatted significant digits number.\n   */\n\n\n  var numberFormatSignificantDigits = function (number, minimumSignificantDigits, maximumSignificantDigits, round) {\n    var atMinimum, atMaximum; // Sanity check.\n\n    if (minimumSignificantDigits > maximumSignificantDigits) {\n      maximumSignificantDigits = minimumSignificantDigits;\n    }\n\n    atMinimum = numberToPrecision(number, minimumSignificantDigits, round);\n    atMaximum = numberToPrecision(number, maximumSignificantDigits, round); // Use atMaximum only if it has more significant digits than atMinimum.\n\n    number = +atMinimum === +atMaximum ? atMinimum : atMaximum; // Expand integer numbers, eg. 123e5 to 12300.\n\n    number = (+number).toString(10);\n\n    if (/e/.test(number)) {\n      throw createErrorUnsupportedFeature({\n        feature: \"integers out of (1e21, 1e-7)\"\n      });\n    } // Add trailing zeros if necessary.\n\n\n    if (minimumSignificantDigits - number.replace(/^0+|\\./g, \"\").length > 0) {\n      number = number.split(\".\");\n      number[1] = stringPad(number[1] || \"\", minimumSignificantDigits - number[0].replace(/^0+/, \"\").length, true);\n      number = number.join(\".\");\n    }\n\n    return number;\n  };\n  /**\n   * EBNF representation:\n   *\n   * number_pattern_re =        prefix?\n   *                            padding?\n   *                            (integer_fraction_pattern | significant_pattern)\n   *                            scientific_notation?\n   *                            suffix?\n   *\n   * prefix =                   non_number_stuff\n   *\n   * padding =                  \"*\" regexp(.)\n   *\n   * integer_fraction_pattern = integer_pattern\n   *                            fraction_pattern?\n   *\n   * integer_pattern =          regexp([#,]*[0,]*0+)\n   *\n   * fraction_pattern =         \".\" regexp(0*[0-9]*#*)\n   *\n   * significant_pattern =      regexp([#,]*@+#*)\n   *\n   * scientific_notation =      regexp(E\\+?0+)\n   *\n   * suffix =                   non_number_stuff\n   *\n   * non_number_stuff =         regexp(('[^']+'|''|[^*#@0,.E])*)\n   *\n   *\n   * Regexp groups:\n   *\n   *  0: number_pattern_re\n   *  1: prefix\n   *  2: -\n   *  3: -\n   *  4: padding\n   *  5: (integer_fraction_pattern | significant_pattern)\n   *  6: integer_fraction_pattern\n   *  7: integer_pattern\n   *  8: fraction_pattern\n   *  9: significant_pattern\n   * 10: scientific_notation\n   * 11: suffix\n   * 12: -\n   */\n\n\n  var numberPatternRe = /^(('([^']|'')*'|[^*#@0,.E])*)(\\*.)?((([#,]*[0,]*0+)(\\.0*[0-9]*#*)?)|([#,]*@+#*))(E\\+?0+)?(('[^']+'|''|[^*#@0,.E])*)$/;\n  /**\n   * removeLiteralQuotes( string )\n   *\n   * Return:\n   * - `` if input string is `''`.\n   * - `o'clock` if input string is `'o''clock'`.\n   * - `foo` if input string is `foo`, i.e., return the same value in case it isn't a single-quoted\n   *   string.\n   */\n\n  var removeLiteralQuotes = function (string) {\n    if (string[0] + string[string.length - 1] !== \"''\") {\n      return string;\n    }\n\n    if (string === \"''\") {\n      return \"\";\n    }\n\n    return string.replace(/''/g, \"'\").slice(1, -1);\n  };\n  /**\n   * format( number, properties )\n   *\n   * @number [Number].\n   *\n   * @properties [Object] Output of number/format-properties.\n   *\n   * Return the formatted number.\n   * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html\n   */\n\n\n  var numberFormat = function (number, properties, pluralGenerator) {\n    var compactMap, infinitySymbol, maximumFractionDigits, maximumSignificantDigits, minimumFractionDigits, minimumIntegerDigits, minimumSignificantDigits, nanSymbol, nuDigitsMap, padding, prefix, primaryGroupingSize, pattern, ret, round, roundIncrement, secondaryGroupingSize, suffix, symbolMap;\n    padding = properties[1];\n    minimumIntegerDigits = properties[2];\n    minimumFractionDigits = properties[3];\n    maximumFractionDigits = properties[4];\n    minimumSignificantDigits = properties[5];\n    maximumSignificantDigits = properties[6];\n    roundIncrement = properties[7];\n    primaryGroupingSize = properties[8];\n    secondaryGroupingSize = properties[9];\n    round = properties[15];\n    infinitySymbol = properties[16];\n    nanSymbol = properties[17];\n    symbolMap = properties[18];\n    nuDigitsMap = properties[19];\n    compactMap = properties[20]; // NaN\n\n    if (isNaN(number)) {\n      return nanSymbol;\n    }\n\n    if (number < 0) {\n      pattern = properties[12];\n      prefix = properties[13];\n      suffix = properties[14];\n    } else {\n      pattern = properties[11];\n      prefix = properties[0];\n      suffix = properties[10];\n    } // Infinity\n\n\n    if (!isFinite(number)) {\n      return prefix + infinitySymbol + suffix;\n    } // Percent\n\n\n    if (pattern.indexOf(\"%\") !== -1) {\n      number *= 100; // Per mille\n    } else if (pattern.indexOf(\"\\u2030\") !== -1) {\n      number *= 1000;\n    }\n\n    var compactPattern, compactDigits, compactProperties, divisor, numberExponent, pluralForm; // Compact mode: initial number digit processing\n\n    if (compactMap) {\n      numberExponent = Math.abs(Math.floor(number)).toString().length - 1;\n      numberExponent = Math.min(numberExponent, compactMap.maxExponent); // Use default plural form to perform initial decimal shift\n\n      if (numberExponent >= 3) {\n        compactPattern = compactMap[numberExponent] && compactMap[numberExponent].other;\n      }\n\n      if (compactPattern === \"0\") {\n        compactPattern = null;\n      } else if (compactPattern) {\n        compactDigits = compactPattern.split(\"0\").length - 1;\n        divisor = numberExponent - (compactDigits - 1);\n        number = number / Math.pow(10, divisor);\n      }\n    } // Significant digit format\n\n\n    if (!isNaN(minimumSignificantDigits * maximumSignificantDigits)) {\n      number = numberFormatSignificantDigits(number, minimumSignificantDigits, maximumSignificantDigits, round); // Integer and fractional format\n    } else {\n      number = numberFormatIntegerFractionDigits(number, minimumIntegerDigits, minimumFractionDigits, maximumFractionDigits, round, roundIncrement);\n    } // Compact mode: apply formatting\n\n\n    if (compactMap && compactPattern) {\n      // Get plural form after possible roundings\n      pluralForm = pluralGenerator ? pluralGenerator(+number) : \"other\";\n      compactPattern = compactMap[numberExponent][pluralForm] || compactPattern;\n      compactProperties = compactPattern.match(numberCompactPatternRe); // update prefix/suffix with compact prefix/suffix\n\n      prefix += compactProperties[1];\n      suffix = compactProperties[3] + suffix;\n    } // Remove the possible number minus sign\n\n\n    number = number.replace(/^-/, \"\"); // Grouping separators\n\n    if (primaryGroupingSize) {\n      number = numberFormatGroupingSeparator(number, primaryGroupingSize, secondaryGroupingSize);\n    }\n\n    ret = prefix;\n    ret += number; // Scientific notation\n    // TODO implement here\n    // Padding/'([^']|'')+'|''|[.,\\-+E%\\u2030]/g\n    // TODO implement here\n\n    ret += suffix;\n    return ret.replace(/('([^']|'')+'|'')|./g, function (character, literal) {\n      // Literals\n      if (literal) {\n        return removeLiteralQuotes(literal);\n      } // Symbols\n\n\n      character = character.replace(/[.,\\-+E%\\u2030]/, function (symbol) {\n        return symbolMap[symbol];\n      }); // Numbering system\n\n      if (nuDigitsMap) {\n        character = character.replace(/[0-9]/, function (digit) {\n          return nuDigitsMap[+digit];\n        });\n      }\n\n      return character;\n    });\n  };\n\n  var numberFormatterFn = function (properties, pluralGenerator) {\n    return function numberFormatter(value) {\n      validateParameterPresence(value, \"value\");\n      validateParameterTypeNumber(value, \"value\");\n      return numberFormat(value, properties, pluralGenerator);\n    };\n  };\n  /**\n   * NumberingSystem( cldr )\n   *\n   * - http://www.unicode.org/reports/tr35/tr35-numbers.html#otherNumberingSystems\n   * - http://cldr.unicode.org/index/bcp47-extension\n   * - http://www.unicode.org/reports/tr35/#u_Extension\n   */\n\n\n  var numberNumberingSystem = function (cldr) {\n    var nu = cldr.attributes[\"u-nu\"];\n\n    if (nu) {\n      if (nu === \"traditio\") {\n        nu = \"traditional\";\n      }\n\n      if ([\"native\", \"traditional\", \"finance\"].indexOf(nu) !== -1) {\n        // Unicode locale extension `u-nu` is set using either (native, traditional or\n        // finance). So, lookup the respective locale's numberingSystem and return it.\n        return cldr.main([\"numbers/otherNumberingSystems\", nu]);\n      } // Unicode locale extension `u-nu` is set with an explicit numberingSystem. Return it.\n\n\n      return nu;\n    } // Return the default numberingSystem.\n\n\n    return cldr.main(\"numbers/defaultNumberingSystem\");\n  };\n  /**\n   * Compact( name, cldr )\n   *\n   * @compactType [String] Compact mode, `short` or `long`.\n   *\n   * @cldr [Cldr instance].\n   *\n   * Return the localized compact map for the given compact mode.\n   */\n\n\n  var numberCompact = function (compactType, cldr) {\n    var maxExponent = 0;\n    var object = cldr.main([\"numbers/decimalFormats-numberSystem-\" + numberNumberingSystem(cldr), compactType, \"decimalFormat\"]);\n    object = Object.keys(object).reduce(function (newObject, compactKey) {\n      var numberExponent = compactKey.split(\"0\").length - 1;\n      var pluralForm = compactKey.split(\"-\")[2];\n      newObject[numberExponent] = newObject[numberExponent] || {};\n      newObject[numberExponent][pluralForm] = object[compactKey];\n      maxExponent = Math.max(numberExponent, maxExponent);\n      return newObject;\n    }, {});\n    object.maxExponent = maxExponent;\n    return object;\n  };\n  /**\n   * nuMap( cldr )\n   *\n   * @cldr [Cldr instance].\n   *\n   * Return digits map if numbering system is different than `latn`.\n   */\n\n\n  var numberNumberingSystemDigitsMap = function (cldr) {\n    var aux,\n        nu = numberNumberingSystem(cldr);\n\n    if (nu === \"latn\") {\n      return;\n    }\n\n    aux = cldr.supplemental([\"numberingSystems\", nu]);\n\n    if (aux._type !== \"numeric\") {\n      throw createErrorUnsupportedFeature(\"`\" + aux._type + \"` numbering system\");\n    }\n\n    return aux._digits;\n  };\n  /**\n   * format( number, pattern )\n   *\n   * @number [Number].\n   *\n   * @pattern [String] raw pattern for numbers.\n   *\n   * Return the formatted number.\n   * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html\n   */\n\n\n  var numberPatternProperties = function (pattern) {\n    var aux1, aux2, fractionPattern, integerFractionOrSignificantPattern, integerPattern, maximumFractionDigits, maximumSignificantDigits, minimumFractionDigits, minimumIntegerDigits, minimumSignificantDigits, padding, prefix, primaryGroupingSize, roundIncrement, scientificNotation, secondaryGroupingSize, significantPattern, suffix;\n    pattern = pattern.match(numberPatternRe);\n\n    if (!pattern) {\n      throw new Error(\"Invalid pattern: \" + pattern);\n    }\n\n    prefix = pattern[1];\n    padding = pattern[4];\n    integerFractionOrSignificantPattern = pattern[5];\n    significantPattern = pattern[9];\n    scientificNotation = pattern[10];\n    suffix = pattern[11]; // Significant digit format\n\n    if (significantPattern) {\n      significantPattern.replace(/(@+)(#*)/, function (match, minimumSignificantDigitsMatch, maximumSignificantDigitsMatch) {\n        minimumSignificantDigits = minimumSignificantDigitsMatch.length;\n        maximumSignificantDigits = minimumSignificantDigits + maximumSignificantDigitsMatch.length;\n      }); // Integer and fractional format\n    } else {\n      fractionPattern = pattern[8];\n      integerPattern = pattern[7];\n\n      if (fractionPattern) {\n        // Minimum fraction digits, and rounding.\n        fractionPattern.replace(/[0-9]+/, function (match) {\n          minimumFractionDigits = match;\n        });\n\n        if (minimumFractionDigits) {\n          roundIncrement = +(\"0.\" + minimumFractionDigits);\n          minimumFractionDigits = minimumFractionDigits.length;\n        } else {\n          minimumFractionDigits = 0;\n        } // Maximum fraction digits\n        // 1: ignore decimal character\n\n\n        maximumFractionDigits = fractionPattern.length - 1\n        /* 1 */\n        ;\n      } else {\n        minimumFractionDigits = 0;\n        maximumFractionDigits = 0;\n      } // Minimum integer digits\n\n\n      integerPattern.replace(/0+$/, function (match) {\n        minimumIntegerDigits = match.length;\n      });\n    } // Scientific notation\n\n\n    if (scientificNotation) {\n      throw createErrorUnsupportedFeature({\n        feature: \"scientific notation (not implemented)\"\n      });\n    } // Padding\n\n\n    if (padding) {\n      throw createErrorUnsupportedFeature({\n        feature: \"padding (not implemented)\"\n      });\n    } // Grouping\n\n\n    if ((aux1 = integerFractionOrSignificantPattern.lastIndexOf(\",\")) !== -1) {\n      // Primary grouping size is the interval between the last group separator and the end of\n      // the integer (or the end of the significant pattern).\n      aux2 = integerFractionOrSignificantPattern.split(\".\")[0];\n      primaryGroupingSize = aux2.length - aux1 - 1; // Secondary grouping size is the interval between the last two group separators.\n\n      if ((aux2 = integerFractionOrSignificantPattern.lastIndexOf(\",\", aux1 - 1)) !== -1) {\n        secondaryGroupingSize = aux1 - 1 - aux2;\n      }\n    } // Return:\n    //  0: @prefix String\n    //  1: @padding Array [ <character>, <count> ] TODO\n    //  2: @minimumIntegerDigits non-negative integer Number value indicating the minimum integer\n    //        digits to be used. Numbers will be padded with leading zeroes if necessary.\n    //  3: @minimumFractionDigits and\n    //  4: @maximumFractionDigits are non-negative integer Number values indicating the minimum and\n    //        maximum fraction digits to be used. Numbers will be rounded or padded with trailing\n    //        zeroes if necessary.\n    //  5: @minimumSignificantDigits and\n    //  6: @maximumSignificantDigits are positive integer Number values indicating the minimum and\n    //        maximum fraction digits to be shown. Either none or both of these properties are\n    //        present; if they are, they override minimum and maximum integer and fraction digits\n    //        – the formatter uses however many integer and fraction digits are required to display\n    //        the specified number of significant digits.\n    //  7: @roundIncrement Decimal round increment or null\n    //  8: @primaryGroupingSize\n    //  9: @secondaryGroupingSize\n    // 10: @suffix String\n\n\n    return [prefix, padding, minimumIntegerDigits, minimumFractionDigits, maximumFractionDigits, minimumSignificantDigits, maximumSignificantDigits, roundIncrement, primaryGroupingSize, secondaryGroupingSize, suffix];\n  };\n  /**\n   * Symbol( name, cldr )\n   *\n   * @name [String] Symbol name.\n   *\n   * @cldr [Cldr instance].\n   *\n   * Return the localized symbol given its name.\n   */\n\n\n  var numberSymbol = function (name, cldr) {\n    return cldr.main([\"numbers/symbols-numberSystem-\" + numberNumberingSystem(cldr), name]);\n  };\n\n  var numberSymbolName = {\n    \".\": \"decimal\",\n    \",\": \"group\",\n    \"%\": \"percentSign\",\n    \"+\": \"plusSign\",\n    \"-\": \"minusSign\",\n    \"E\": \"exponential\",\n    \"\\u2030\": \"perMille\"\n  };\n  /**\n   * symbolMap( cldr )\n   *\n   * @cldr [Cldr instance].\n   *\n   * Return the (localized symbol, pattern symbol) key value pair, eg. {\n   *   \".\": \"٫\",\n   *   \",\": \"٬\",\n   *   \"%\": \"٪\",\n   *   ...\n   * };\n   */\n\n  var numberSymbolMap = function (cldr) {\n    var symbol,\n        symbolMap = {};\n\n    for (symbol in numberSymbolName) {\n      symbolMap[symbol] = numberSymbol(numberSymbolName[symbol], cldr);\n    }\n\n    return symbolMap;\n  };\n\n  var numberTruncate = function (value) {\n    if (isNaN(value)) {\n      return NaN;\n    }\n\n    return Math[value < 0 ? \"ceil\" : \"floor\"](value);\n  };\n  /**\n   * round( method )\n   *\n   * @method [String] with either \"round\", \"ceil\", \"floor\", or \"truncate\".\n   *\n   * Return function( value, incrementOrExp ):\n   *\n   *   @value [Number] eg. 123.45.\n   *\n   *   @incrementOrExp [Number] optional, eg. 0.1; or\n   *     [Object] Either { increment: <value> } or { exponent: <value> }\n   *\n   *   Return the rounded number, eg:\n   *   - round( \"round\" )( 123.45 ): 123;\n   *   - round( \"ceil\" )( 123.45 ): 124;\n   *   - round( \"floor\" )( 123.45 ): 123;\n   *   - round( \"truncate\" )( 123.45 ): 123;\n   *   - round( \"round\" )( 123.45, 0.1 ): 123.5;\n   *   - round( \"round\" )( 123.45, 10 ): 120;\n   *\n   *   Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round\n   *   Ref: #376\n   */\n\n\n  var numberRound = function (method) {\n    method = method || \"round\";\n    method = method === \"truncate\" ? numberTruncate : Math[method];\n    return function (value, incrementOrExp) {\n      var exp, increment;\n      value = +value; // If the value is not a number, return NaN.\n\n      if (isNaN(value)) {\n        return NaN;\n      } // Exponent given.\n\n\n      if (typeof incrementOrExp === \"object\" && incrementOrExp.exponent) {\n        exp = +incrementOrExp.exponent;\n        increment = 1;\n\n        if (exp === 0) {\n          return method(value);\n        } // If the exp is not an integer, return NaN.\n\n\n        if (!(typeof exp === \"number\" && exp % 1 === 0)) {\n          return NaN;\n        } // Increment given.\n\n      } else {\n        increment = +incrementOrExp || 1;\n\n        if (increment === 1) {\n          return method(value);\n        } // If the increment is not a number, return NaN.\n\n\n        if (isNaN(increment)) {\n          return NaN;\n        }\n\n        increment = increment.toExponential().split(\"e\");\n        exp = +increment[1];\n        increment = +increment[0];\n      } // Shift & Round\n\n\n      value = value.toString().split(\"e\");\n      value[0] = +value[0] / increment;\n      value[1] = value[1] ? +value[1] - exp : -exp;\n      value = method(+(value[0] + \"e\" + value[1])); // Shift back\n\n      value = value.toString().split(\"e\");\n      value[0] = +value[0] * increment;\n      value[1] = value[1] ? +value[1] + exp : exp;\n      return +(value[0] + \"e\" + value[1]);\n    };\n  };\n  /**\n   * formatProperties( pattern, cldr [, options] )\n   *\n   * @pattern [String] raw pattern for numbers.\n   *\n   * @cldr [Cldr instance].\n   *\n   * @options [Object]:\n   * - minimumIntegerDigits [Number]\n   * - minimumFractionDigits, maximumFractionDigits [Number]\n   * - minimumSignificantDigits, maximumSignificantDigits [Number]\n   * - round [String] \"ceil\", \"floor\", \"round\" (default), or \"truncate\".\n   * - useGrouping [Boolean] default true.\n   *\n   * Return the processed properties that will be used in number/format.\n   * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html\n   */\n\n\n  var numberFormatProperties = function (pattern, cldr, options) {\n    var negativePattern, negativePrefix, negativeProperties, negativeSuffix, positivePattern, roundFn, properties;\n\n    function getOptions(attribute, propertyIndex) {\n      if (attribute in options) {\n        properties[propertyIndex] = options[attribute];\n      }\n    }\n\n    options = options || {};\n    pattern = pattern.split(\";\");\n    positivePattern = pattern[0];\n    negativePattern = pattern[1] || \"-\" + positivePattern;\n    negativeProperties = numberPatternProperties(negativePattern);\n    negativePrefix = negativeProperties[0];\n    negativeSuffix = negativeProperties[10]; // Have runtime code to refer to numberRound() instead of including it explicitly.\n\n    roundFn = numberRound(options.round);\n\n    roundFn.generatorString = function () {\n      return \"numberRound(\" + (options.round ? \"\\\"\" + options.round + \"\\\"\" : \"\") + \")\";\n    };\n\n    properties = numberPatternProperties(positivePattern).concat([positivePattern, negativePrefix + positivePattern + negativeSuffix, negativePrefix, negativeSuffix, roundFn, numberSymbol(\"infinity\", cldr), numberSymbol(\"nan\", cldr), numberSymbolMap(cldr), numberNumberingSystemDigitsMap(cldr)]);\n\n    if (options.compact) {\n      // The compact digits number pattern is always `0+`, so override the following properties.\n      // Note: minimumIntegerDigits would actually range from `0` to `000` based on the scale of\n      // the value to be formatted, though we're always using 1 as a simplification, because the\n      // number won't be zero-padded since we chose the right format based on the scale, i.e.,\n      // we'd never see something like `003M` anyway.\n      properties[2] = 1; // minimumIntegerDigits\n\n      properties[3] = 0; // minimumFractionDigits\n\n      properties[4] = 0; // maximumFractionDigits\n\n      properties[5] = // minimumSignificantDigits &\n      properties[6] = undefined; // maximumSignificantDigits\n\n      properties[20] = numberCompact(options.compact, cldr);\n    }\n\n    getOptions(\"minimumIntegerDigits\", 2);\n    getOptions(\"minimumFractionDigits\", 3);\n    getOptions(\"maximumFractionDigits\", 4);\n    getOptions(\"minimumSignificantDigits\", 5);\n    getOptions(\"maximumSignificantDigits\", 6); // Grouping separators\n\n    if (options.useGrouping === false) {\n      properties[8] = null;\n    } // Normalize number of digits if only one of either minimumFractionDigits or\n    // maximumFractionDigits is passed in as an option\n\n\n    if (\"minimumFractionDigits\" in options && !(\"maximumFractionDigits\" in options)) {\n      // maximumFractionDigits = Math.max( minimumFractionDigits, maximumFractionDigits );\n      properties[4] = Math.max(properties[3], properties[4]);\n    } else if (!(\"minimumFractionDigits\" in options) && \"maximumFractionDigits\" in options) {\n      // minimumFractionDigits = Math.min( minimumFractionDigits, maximumFractionDigits );\n      properties[3] = Math.min(properties[3], properties[4]);\n    } // Return:\n    // 0-10: see number/pattern-properties.\n    // 11: @positivePattern [String] Positive pattern.\n    // 12: @negativePattern [String] Negative pattern.\n    // 13: @negativePrefix [String] Negative prefix.\n    // 14: @negativeSuffix [String] Negative suffix.\n    // 15: @round [Function] Round function.\n    // 16: @infinitySymbol [String] Infinity symbol.\n    // 17: @nanSymbol [String] NaN symbol.\n    // 18: @symbolMap [Object] A bunch of other symbols.\n    // 19: @nuDigitsMap [Array] Digits map if numbering system is different than `latn`.\n    // 20: @compactMap [Object] Map of per-digit-count format patterns for specified compact mode.\n\n\n    return properties;\n  };\n  /**\n   * Generated by:\n   *\n   * var regenerate = require( \"regenerate\" );\n   * var formatSymbols = require( * \"unicode-8.0.0/General_Category/Format/symbols\" );\n   * regenerate().add( formatSymbols ).toString();\n   *\n   * https://github.com/mathiasbynens/regenerate\n   * https://github.com/mathiasbynens/unicode-8.0.0\n   */\n\n\n  var regexpCfG = /[\\xAD\\u0600-\\u0605\\u061C\\u06DD\\u070F\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u2064\\u2066-\\u206F\\uFEFF\\uFFF9-\\uFFFB]|\\uD804\\uDCBD|\\uD82F[\\uDCA0-\\uDCA3]|\\uD834[\\uDD73-\\uDD7A]|\\uDB40[\\uDC01\\uDC20-\\uDC7F]/g;\n  /**\n   * Generated by:\n   *\n   * var regenerate = require( \"regenerate\" );\n   * var dashSymbols = require( * \"unicode-8.0.0/General_Category/Dash_Punctuation/symbols\" );\n   * regenerate().add( dashSymbols ).toString();\n   *\n   * https://github.com/mathiasbynens/regenerate\n   * https://github.com/mathiasbynens/unicode-8.0.0\n   *\n   * NOTE: In addition to [:dash:],  the below includes MINUS SIGN U+2212.\n   */\n\n  var regexpDashG = /[\\-\\u058A\\u05BE\\u1400\\u1806\\u2010-\\u2015\\u2E17\\u2E1A\\u2E3A\\u2E3B\\u2E40\\u301C\\u3030\\u30A0\\uFE31\\uFE32\\uFE58\\uFE63\\uFF0D\\u2212]/g;\n  /**\n   * Generated by:\n   *\n   * var regenerate = require( \"regenerate\" );\n   * var spaceSeparatorSymbols = require( \"unicode-8.0.0/General_Category/Space_Separator/symbols\" );\n   * regenerate().add( spaceSeparatorSymbols ).toString();\n   *\n   * https://github.com/mathiasbynens/regenerate\n   * https://github.com/mathiasbynens/unicode-8.0.0\n   */\n\n  var regexpZsG = /[ \\xA0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000]/g;\n  /**\n   * Loose Matching:\n   * - Ignore all format characters, which includes RLM, LRM or ALM used to control BIDI\n   *   formatting.\n   * - Map all characters in [:Zs:] to U+0020 SPACE;\n   * - Map all characters in [:Dash:] to U+002D HYPHEN-MINUS;\n   */\n\n  var looseMatching = function (value) {\n    return value.replace(regexpCfG, \"\").replace(regexpDashG, \"-\").replace(regexpZsG, \" \");\n  };\n  /**\n   * parse( value, properties )\n   *\n   * @value [String].\n   *\n   * @properties [Object] Parser properties is a reduced pre-processed cldr\n   * data set returned by numberParserProperties().\n   *\n   * Return the parsed Number (including Infinity) or NaN when value is invalid.\n   * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html\n   */\n\n\n  var numberParse = function (value, properties) {\n    var grammar, invertedNuDigitsMap, invertedSymbolMap, negative, number, prefix, prefixNSuffix, suffix, tokenizer, valid; // Grammar:\n    // - Value <=           NaN | PositiveNumber | NegativeNumber\n    // - PositiveNumber <=  PositivePrefix NumberOrInf PositiveSufix\n    // - NegativeNumber <=  NegativePrefix NumberOrInf\n    // - NumberOrInf <=     Number | Inf\n\n    grammar = [[\"nan\"], [\"prefix\", \"infinity\", \"suffix\"], [\"prefix\", \"number\", \"suffix\"], [\"negativePrefix\", \"infinity\", \"negativeSuffix\"], [\"negativePrefix\", \"number\", \"negativeSuffix\"]];\n    invertedSymbolMap = properties[0];\n    invertedNuDigitsMap = properties[1] || {};\n    tokenizer = properties[2];\n    value = looseMatching(value);\n\n    function parse(type) {\n      return function (lexeme) {\n        // Reverse localized symbols and numbering system.\n        lexeme = lexeme.split(\"\").map(function (character) {\n          return invertedSymbolMap[character] || invertedNuDigitsMap[character] || character;\n        }).join(\"\");\n\n        switch (type) {\n          case \"infinity\":\n            number = Infinity;\n            break;\n\n          case \"nan\":\n            number = NaN;\n            break;\n\n          case \"number\":\n            // Remove grouping separators.\n            lexeme = lexeme.replace(/,/g, \"\");\n            number = +lexeme;\n            break;\n\n          case \"prefix\":\n          case \"negativePrefix\":\n            prefix = lexeme;\n            break;\n\n          case \"suffix\":\n            suffix = lexeme;\n            break;\n\n          case \"negativeSuffix\":\n            suffix = lexeme;\n            negative = true;\n            break;\n          // This should never be reached.\n\n          default:\n            throw new Error(\"Internal error\");\n        }\n\n        return \"\";\n      };\n    }\n\n    function tokenizeNParse(_value, grammar) {\n      return grammar.some(function (statement) {\n        var value = _value; // The whole grammar statement should be used (i.e., .every() return true) and value be\n        // entirely consumed (i.e., !value.length).\n\n        return statement.every(function (type) {\n          if (value.match(tokenizer[type]) === null) {\n            return false;\n          } // Consume and parse it.\n\n\n          value = value.replace(tokenizer[type], parse(type));\n          return true;\n        }) && !value.length;\n      });\n    }\n\n    valid = tokenizeNParse(value, grammar); // NaN\n\n    if (!valid || isNaN(number)) {\n      return NaN;\n    }\n\n    prefixNSuffix = \"\" + prefix + suffix; // Percent\n\n    if (prefixNSuffix.indexOf(\"%\") !== -1) {\n      number /= 100; // Per mille\n    } else if (prefixNSuffix.indexOf(\"\\u2030\") !== -1) {\n      number /= 1000;\n    } // Negative number\n\n\n    if (negative) {\n      number *= -1;\n    }\n\n    return number;\n  };\n\n  var numberParserFn = function (properties) {\n    return function numberParser(value) {\n      validateParameterPresence(value, \"value\");\n      validateParameterTypeString(value, \"value\");\n      return numberParse(value, properties);\n    };\n  };\n  /**\n   * symbolMap( cldr )\n   *\n   * @cldr [Cldr instance].\n   *\n   * Return the (localized symbol, pattern symbol) key value pair, eg. {\n   *   \"٫\": \".\",\n   *   \"٬\": \",\",\n   *   \"٪\": \"%\",\n   *   ...\n   * };\n   */\n\n\n  var numberSymbolInvertedMap = function (cldr) {\n    var symbol,\n        symbolMap = {};\n\n    for (symbol in numberSymbolName) {\n      symbolMap[numberSymbol(numberSymbolName[symbol], cldr)] = symbol;\n    }\n\n    return symbolMap;\n  };\n  /**\n   * objectMap( object, fn)\n   *\n   * - object\n   *\n   * - fn( pair ) => pair\n   */\n\n\n  var objectMap = function (object, fn) {\n    return Object.keys(object).map(function (key) {\n      return fn([key, object[key]]);\n    }).reduce(function (object, pair) {\n      object[pair[0]] = pair[1];\n      return object;\n    }, {});\n  };\n  /**\n   * parseProperties( pattern, cldr )\n   *\n   * @pattern [String] raw pattern for numbers.\n   *\n   * @cldr [Cldr instance].\n   *\n   * Return parser properties, used to feed parser function.\n   *\n   * TODO:\n   * - Scientific_notation;\n   * - Padding;\n   */\n\n\n  var numberParseProperties = function (pattern, cldr, options) {\n    var aux,\n        decimalSymbolRe,\n        digitsRe,\n        groupingSeparatorRe,\n        infinitySymbol,\n        invertedNuDigitsMap,\n        invertedSymbolMap,\n        maximumFractionDigits,\n        maximumSignificantDigits,\n        minimumSignificantDigits,\n        nanSymbol,\n        negativePrefix,\n        negativeSuffix,\n        nuDigitsMap,\n        numberTokenizer,\n        prefix,\n        primaryGroupingSize,\n        secondaryGroupingSize,\n        suffix,\n        symbolMap,\n        formatProperties = numberFormatProperties(pattern, cldr, options);\n    prefix = looseMatching(formatProperties[0]);\n    maximumFractionDigits = formatProperties[4];\n    minimumSignificantDigits = formatProperties[5];\n    maximumSignificantDigits = formatProperties[6];\n    primaryGroupingSize = formatProperties[8];\n    secondaryGroupingSize = formatProperties[9];\n    suffix = looseMatching(formatProperties[10]);\n    negativePrefix = looseMatching(formatProperties[13]);\n    negativeSuffix = looseMatching(formatProperties[14]);\n    infinitySymbol = looseMatching(formatProperties[16]);\n    nanSymbol = looseMatching(formatProperties[17]);\n    symbolMap = objectMap(formatProperties[18], function (pair) {\n      return [pair[0], looseMatching(pair[1])];\n    });\n    nuDigitsMap = formatProperties[19];\n    invertedSymbolMap = objectMap(numberSymbolInvertedMap(cldr), function (pair) {\n      return [looseMatching(pair[0]), pair[1]];\n    });\n    digitsRe = nuDigitsMap ? \"[\" + nuDigitsMap + \"]\" : \"\\\\d\";\n    groupingSeparatorRe = regexpEscape(symbolMap[\",\"]);\n    decimalSymbolRe = regexpEscape(symbolMap[\".\"]);\n\n    if (nuDigitsMap) {\n      invertedNuDigitsMap = nuDigitsMap.split(\"\").reduce(function (object, localizedDigit, i) {\n        object[localizedDigit] = String(i);\n        return object;\n      }, {});\n    }\n\n    aux = [prefix, suffix, negativePrefix, negativeSuffix].map(function (value) {\n      return value.replace(/('([^']|'')+'|'')|./g, function (character, literal) {\n        // Literals\n        if (literal) {\n          return removeLiteralQuotes(literal);\n        } // Symbols\n\n\n        character = character.replace(/[\\-+E%\\u2030]/, function (symbol) {\n          return symbolMap[symbol];\n        });\n        return character;\n      });\n    });\n    prefix = aux[0];\n    suffix = aux[1];\n    negativePrefix = aux[2];\n    negativeSuffix = aux[3]; // Number\n    //\n    // number_re =                       integer fraction?\n    //\n    // integer =                         digits | digits_using_grouping_separators\n    //\n    // fraction =                        regexp((.\\d+)?)\n    //\n    // digits =                          regexp(\\d+)\n    //\n    // digits_w_grouping_separators =    digits_w_1_grouping_separators |\n    //                                   digits_w_2_grouping_separators\n    //\n    // digits_w_1_grouping_separators =  regexp(\\d{1,3}(,\\d{3})+)\n    //\n    // digits_w_2_grouping_separators =  regexp(\\d{1,2}((,\\d{2})*(,\\d{3})))\n    // Integer part\n\n    numberTokenizer = digitsRe + \"+\"; // Grouping separators\n\n    if (primaryGroupingSize) {\n      if (secondaryGroupingSize) {\n        aux = digitsRe + \"{1,\" + secondaryGroupingSize + \"}((\" + groupingSeparatorRe + digitsRe + \"{\" + secondaryGroupingSize + \"})*(\" + groupingSeparatorRe + digitsRe + \"{\" + primaryGroupingSize + \"}))\";\n      } else {\n        aux = digitsRe + \"{1,\" + primaryGroupingSize + \"}(\" + groupingSeparatorRe + digitsRe + \"{\" + primaryGroupingSize + \"})+\";\n      }\n\n      numberTokenizer = \"(\" + aux + \"|\" + numberTokenizer + \")\";\n    } // Fraction part? Only included if 1 or 2.\n    // 1: Using significant digit format.\n    // 2: Using integer and fractional format && it has a maximumFractionDigits.\n\n\n    if (!isNaN(minimumSignificantDigits * maximumSignificantDigits) ||\n    /* 1 */\n    maximumFractionDigits\n    /* 2 */\n    ) {\n        // 1: Handle trailing decimal separator, e.g., `\"1.\" => `1``.\n        aux = decimalSymbolRe + digitsRe + \"+\";\n        numberTokenizer = numberTokenizer + \"(\" + aux + \"|\" + decimalSymbolRe\n        /* 1 */\n        + \")?\" + // Handle non-padded decimals, e.g., `\".12\"` => `0.12` by making the integer part\n        // optional.\n        \"|(\" + numberTokenizer + \")?\" + aux;\n        numberTokenizer = \"(\" + numberTokenizer + \")\";\n      } // 0: @invertedSymbolMap [Object] Inverted symbol map.\n    // 1: @invertedNuDigitsMap [Object] Inverted digits map if numbering system is different than\n    //    `latn`.\n    // 2: @tokenizer [Object] Tokenizer map, used by parser to consume input.\n\n\n    return [invertedSymbolMap, invertedNuDigitsMap, {\n      infinity: new RegExp(\"^\" + regexpEscape(infinitySymbol)),\n      nan: new RegExp(\"^\" + regexpEscape(nanSymbol)),\n      negativePrefix: new RegExp(\"^\" + regexpEscape(negativePrefix)),\n      negativeSuffix: new RegExp(\"^\" + regexpEscape(negativeSuffix)),\n      number: new RegExp(\"^\" + numberTokenizer),\n      prefix: new RegExp(\"^\" + regexpEscape(prefix)),\n      suffix: new RegExp(\"^\" + regexpEscape(suffix))\n    }];\n  };\n  /**\n   * Pattern( style )\n   *\n   * @style [String] \"decimal\" (default) or \"percent\".\n   *\n   * @cldr [Cldr instance].\n   */\n\n\n  var numberPattern = function (style, cldr) {\n    if (style !== \"decimal\" && style !== \"percent\") {\n      throw new Error(\"Invalid style\");\n    }\n\n    return cldr.main([\"numbers\", style + \"Formats-numberSystem-\" + numberNumberingSystem(cldr), \"standard\"]);\n  };\n\n  function validateDigits(properties) {\n    var minimumIntegerDigits = properties[2],\n        minimumFractionDigits = properties[3],\n        maximumFractionDigits = properties[4],\n        minimumSignificantDigits = properties[5],\n        maximumSignificantDigits = properties[6]; // Validate significant digit format properties\n\n    if (!isNaN(minimumSignificantDigits * maximumSignificantDigits)) {\n      validateParameterRange(minimumSignificantDigits, \"minimumSignificantDigits\", 1, 21);\n      validateParameterRange(maximumSignificantDigits, \"maximumSignificantDigits\", minimumSignificantDigits, 21);\n    } else if (!isNaN(minimumSignificantDigits) || !isNaN(maximumSignificantDigits)) {\n      throw new Error(\"Neither or both the minimum and maximum significant digits must be \" + \"present\"); // Validate integer and fractional format\n    } else {\n      validateParameterRange(minimumIntegerDigits, \"minimumIntegerDigits\", 1, 21);\n      validateParameterRange(minimumFractionDigits, \"minimumFractionDigits\", 0, 20);\n      validateParameterRange(maximumFractionDigits, \"maximumFractionDigits\", minimumFractionDigits, 20);\n    }\n  }\n  /**\n   * .numberFormatter( [options] )\n   *\n   * @options [Object]:\n   * - style: [String] \"decimal\" (default) or \"percent\".\n   * - see also number/format options.\n   *\n   * Return a function that formats a number according to the given options and default/instance\n   * locale.\n   */\n\n\n  Globalize.numberFormatter = Globalize.prototype.numberFormatter = function (options) {\n    var args, cldr, fnArgs, pattern, properties, returnFn;\n    validateParameterTypePlainObject(options, \"options\");\n    options = options || {};\n    cldr = this.cldr;\n    args = [options];\n    validateDefaultLocale(cldr);\n    cldr.on(\"get\", validateCldr);\n\n    if (options.raw) {\n      pattern = options.raw;\n    } else {\n      pattern = numberPattern(options.style || \"decimal\", cldr);\n    }\n\n    properties = numberFormatProperties(pattern, cldr, options);\n    fnArgs = [properties];\n    cldr.off(\"get\", validateCldr);\n    validateDigits(properties);\n\n    if (options.compact) {\n      fnArgs.push(this.pluralGenerator());\n    }\n\n    returnFn = numberFormatterFn.apply(null, fnArgs);\n    runtimeBind(args, cldr, returnFn, fnArgs);\n    return returnFn;\n  };\n  /**\n   * .numberParser( [options] )\n   *\n   * @options [Object]:\n   * - style: [String] \"decimal\" (default) or \"percent\".\n   *\n   * Return the number parser according to the default/instance locale.\n   */\n\n\n  Globalize.numberParser = Globalize.prototype.numberParser = function (options) {\n    var args, cldr, pattern, properties, returnFn;\n    validateParameterTypePlainObject(options, \"options\");\n    options = options || {};\n    cldr = this.cldr;\n    args = [options];\n    validateDefaultLocale(cldr);\n\n    if (options.compact) {\n      throw createErrorUnsupportedFeature({\n        feature: \"compact number parsing (not implemented)\"\n      });\n    }\n\n    cldr.on(\"get\", validateCldr);\n\n    if (options.raw) {\n      pattern = options.raw;\n    } else {\n      pattern = numberPattern(options.style || \"decimal\", cldr);\n    }\n\n    properties = numberParseProperties(pattern, cldr, options);\n    cldr.off(\"get\", validateCldr);\n    returnFn = numberParserFn(properties);\n    runtimeBind(args, cldr, returnFn, [properties]);\n    return returnFn;\n  };\n  /**\n   * .formatNumber( value [, options] )\n   *\n   * @value [Number] number to be formatted.\n   *\n   * @options [Object]: see number/format-properties.\n   *\n   * Format a number according to the given options and default/instance locale.\n   */\n\n\n  Globalize.formatNumber = Globalize.prototype.formatNumber = function (value, options) {\n    validateParameterPresence(value, \"value\");\n    validateParameterTypeNumber(value, \"value\");\n    return this.numberFormatter(options)(value);\n  };\n  /**\n   * .parseNumber( value [, options] )\n   *\n   * @value [String]\n   *\n   * @options [Object]: See numberParser().\n   *\n   * Return the parsed Number (including Infinity) or NaN when value is invalid.\n   */\n\n\n  Globalize.parseNumber = Globalize.prototype.parseNumber = function (value, options) {\n    validateParameterPresence(value, \"value\");\n    validateParameterTypeString(value, \"value\");\n    return this.numberParser(options)(value);\n  };\n  /**\n   * Optimization to avoid duplicating some internal functions across modules.\n   */\n\n\n  Globalize._createErrorUnsupportedFeature = createErrorUnsupportedFeature;\n  Globalize._numberNumberingSystem = numberNumberingSystem;\n  Globalize._numberNumberingSystemDigitsMap = numberNumberingSystemDigitsMap;\n  Globalize._numberPattern = numberPattern;\n  Globalize._numberSymbol = numberSymbol;\n  Globalize._looseMatching = looseMatching;\n  Globalize._removeLiteralQuotes = removeLiteralQuotes;\n  Globalize._stringPad = stringPad;\n  Globalize._validateParameterTypeNumber = validateParameterTypeNumber;\n  Globalize._validateParameterTypeString = validateParameterTypeString;\n  return Globalize;\n});","map":{"version":3,"sources":["C:/Users/guido/Documents/GitHub/myreactapp/node_modules/globalize/dist/globalize/number.js"],"names":["root","factory","define","amd","exports","module","require","Cldr","Globalize","createError","_createError","regexpEscape","_regexpEscape","runtimeBind","_runtimeBind","stringPad","_stringPad","validateCldr","_validateCldr","validateDefaultLocale","_validateDefaultLocale","validateParameterPresence","_validateParameterPresence","validateParameterRange","_validateParameterRange","validateParameterType","_validateParameterType","validateParameterTypePlainObject","_validateParameterTypePlainObject","createErrorUnsupportedFeature","feature","validateParameterTypeNumber","value","name","undefined","validateParameterTypeString","numberCompactPatternRe","numberFormatGroupingSeparator","number","primaryGroupingSize","secondaryGroupingSize","index","currentGroupingSize","ret","sep","switchToSecondary","String","split","length","slice","join","numberFormatIntegerFractionDigits","minimumIntegerDigits","minimumFractionDigits","maximumFractionDigits","round","roundIncrement","exponent","test","toFixed","replace","numberToPrecision","precision","roundOrder","Math","ceil","log","abs","numberFormatSignificantDigits","minimumSignificantDigits","maximumSignificantDigits","atMinimum","atMaximum","toString","numberPatternRe","removeLiteralQuotes","string","numberFormat","properties","pluralGenerator","compactMap","infinitySymbol","nanSymbol","nuDigitsMap","padding","prefix","pattern","suffix","symbolMap","isNaN","isFinite","indexOf","compactPattern","compactDigits","compactProperties","divisor","numberExponent","pluralForm","floor","min","maxExponent","other","pow","match","character","literal","symbol","digit","numberFormatterFn","numberFormatter","numberNumberingSystem","cldr","nu","attributes","main","numberCompact","compactType","object","Object","keys","reduce","newObject","compactKey","max","numberNumberingSystemDigitsMap","aux","supplemental","_type","_digits","numberPatternProperties","aux1","aux2","fractionPattern","integerFractionOrSignificantPattern","integerPattern","scientificNotation","significantPattern","Error","minimumSignificantDigitsMatch","maximumSignificantDigitsMatch","lastIndexOf","numberSymbol","numberSymbolName","numberSymbolMap","numberTruncate","NaN","numberRound","method","incrementOrExp","exp","increment","toExponential","numberFormatProperties","options","negativePattern","negativePrefix","negativeProperties","negativeSuffix","positivePattern","roundFn","getOptions","attribute","propertyIndex","generatorString","concat","compact","useGrouping","regexpCfG","regexpDashG","regexpZsG","looseMatching","numberParse","grammar","invertedNuDigitsMap","invertedSymbolMap","negative","prefixNSuffix","tokenizer","valid","parse","type","lexeme","map","Infinity","tokenizeNParse","_value","some","statement","every","numberParserFn","numberParser","numberSymbolInvertedMap","objectMap","fn","key","pair","numberParseProperties","decimalSymbolRe","digitsRe","groupingSeparatorRe","numberTokenizer","formatProperties","localizedDigit","i","infinity","RegExp","nan","numberPattern","style","validateDigits","prototype","args","fnArgs","returnFn","on","raw","off","push","apply","formatNumber","parseNumber","_createErrorUnsupportedFeature","_numberNumberingSystem","_numberNumberingSystemDigitsMap","_numberPattern","_numberSymbol","_looseMatching","_removeLiteralQuotes","_validateParameterTypeNumber","_validateParameterTypeString"],"mappings":"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","sourcesContent":["/**\n * Globalize v1.4.2\n *\n * http://github.com/jquery/globalize\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2019-03-07T13:47Z\n */\n/*!\n * Globalize v1.4.2 2019-03-07T13:47Z Released under the MIT license\n * http://git.io/TrdQbw\n */\n(function( root, factory ) {\n\n\t// UMD returnExports\n\tif ( typeof define === \"function\" && define.amd ) {\n\n\t\t// AMD\n\t\tdefine([\n\t\t\t\"cldr\",\n\t\t\t\"../globalize\",\n\t\t\t\"cldr/event\",\n\t\t\t\"cldr/supplemental\"\n\t\t], factory );\n\t} else if ( typeof exports === \"object\" ) {\n\n\t\t// Node, CommonJS\n\t\tmodule.exports = factory( require( \"cldrjs\" ), require( \"../globalize\" ) );\n\t} else {\n\n\t\t// Global\n\t\tfactory( root.Cldr, root.Globalize );\n\t}\n}(this, function( Cldr, Globalize ) {\n\nvar createError = Globalize._createError,\n\tregexpEscape = Globalize._regexpEscape,\n\truntimeBind = Globalize._runtimeBind,\n\tstringPad = Globalize._stringPad,\n\tvalidateCldr = Globalize._validateCldr,\n\tvalidateDefaultLocale = Globalize._validateDefaultLocale,\n\tvalidateParameterPresence = Globalize._validateParameterPresence,\n\tvalidateParameterRange = Globalize._validateParameterRange,\n\tvalidateParameterType = Globalize._validateParameterType,\n\tvalidateParameterTypePlainObject = Globalize._validateParameterTypePlainObject;\n\n\nvar createErrorUnsupportedFeature = function( feature ) {\n\treturn createError( \"E_UNSUPPORTED\", \"Unsupported {feature}.\", {\n\t\tfeature: feature\n\t});\n};\n\n\n\n\nvar validateParameterTypeNumber = function( value, name ) {\n\tvalidateParameterType(\n\t\tvalue,\n\t\tname,\n\t\tvalue === undefined || typeof value === \"number\",\n\t\t\"Number\"\n\t);\n};\n\n\n\n\nvar validateParameterTypeString = function( value, name ) {\n\tvalidateParameterType(\n\t\tvalue,\n\t\tname,\n\t\tvalue === undefined || typeof value === \"string\",\n\t\t\"a string\"\n\t);\n};\n\n\n\n\n/**\n * EBNF representation:\n *\n * compact_pattern_re =       prefix?\n *                            number_pattern_re\n *                            suffix?\n *\n * number_pattern_re =        0+\n *\n * Regexp groups:\n *\n *  0: compact_pattern_re\n *  1: prefix\n *  2: number_pattern_re (the number pattern to use in compact mode)\n *  3: suffix\n */\nvar numberCompactPatternRe = ( /^([^0]*)(0+)([^0]*)$/ );\n\n\n\n\n/**\n * goupingSeparator( number, primaryGroupingSize, secondaryGroupingSize )\n *\n * @number [Number].\n *\n * @primaryGroupingSize [Number]\n *\n * @secondaryGroupingSize [Number]\n *\n * Return the formatted number with group separator.\n */\nvar numberFormatGroupingSeparator = function( number, primaryGroupingSize, secondaryGroupingSize ) {\n\tvar index,\n\t\tcurrentGroupingSize = primaryGroupingSize,\n\t\tret = \"\",\n\t\tsep = \",\",\n\t\tswitchToSecondary = secondaryGroupingSize ? true : false;\n\n\tnumber = String( number ).split( \".\" );\n\tindex = number[ 0 ].length;\n\n\twhile ( index > currentGroupingSize ) {\n\t\tret = number[ 0 ].slice( index - currentGroupingSize, index ) +\n\t\t\t( ret.length ? sep : \"\" ) + ret;\n\t\tindex -= currentGroupingSize;\n\t\tif ( switchToSecondary ) {\n\t\t\tcurrentGroupingSize = secondaryGroupingSize;\n\t\t\tswitchToSecondary = false;\n\t\t}\n\t}\n\n\tnumber[ 0 ] = number[ 0 ].slice( 0, index ) + ( ret.length ? sep : \"\" ) + ret;\n\treturn number.join( \".\" );\n};\n\n\n\n\n/**\n * integerFractionDigits( number, minimumIntegerDigits, minimumFractionDigits,\n * maximumFractionDigits, round, roundIncrement )\n *\n * @number [Number]\n *\n * @minimumIntegerDigits [Number]\n *\n * @minimumFractionDigits [Number]\n *\n * @maximumFractionDigits [Number]\n *\n * @round [Function]\n *\n * @roundIncrement [Function]\n *\n * Return the formatted integer and fraction digits.\n */\nvar numberFormatIntegerFractionDigits = function( number, minimumIntegerDigits, minimumFractionDigits, maximumFractionDigits, round,\n\troundIncrement ) {\n\n\t// Fraction\n\tif ( maximumFractionDigits ) {\n\n\t\t// Rounding\n\t\tif ( roundIncrement ) {\n\t\t\tnumber = round( number, roundIncrement );\n\n\t\t// Maximum fraction digits\n\t\t} else {\n\t\t\tnumber = round( number, { exponent: -maximumFractionDigits } );\n\t\t}\n\n\t} else {\n\t\tnumber = round( number );\n\t}\n\n\tnumber = String( number );\n\n\t// Maximum integer digits (post string phase)\n\tif ( maximumFractionDigits && /e-/.test( number ) ) {\n\n\t\t// Use toFixed( maximumFractionDigits ) to make sure small numbers like 1e-7 are\n\t\t// displayed using plain digits instead of scientific notation.\n\t\t// 1: Remove leading decimal zeros.\n\t\t// 2: Remove leading decimal separator.\n\t\t// Note: String() is still preferred so it doesn't mess up with a number precision\n\t\t// unnecessarily, e.g., (123456789.123).toFixed(10) === \"123456789.1229999959\",\n\t\t// String(123456789.123) === \"123456789.123\".\n\t\tnumber = ( +number ).toFixed( maximumFractionDigits )\n\t\t\t.replace( /0+$/, \"\" ) /* 1 */\n\t\t\t.replace( /\\.$/, \"\" ) /* 2 */;\n\t}\n\n\t// Minimum fraction digits (post string phase)\n\tif ( minimumFractionDigits ) {\n\t\tnumber = number.split( \".\" );\n\t\tnumber[ 1 ] = stringPad( number[ 1 ] || \"\", minimumFractionDigits, true );\n\t\tnumber = number.join( \".\" );\n\t}\n\n\t// Minimum integer digits\n\tif ( minimumIntegerDigits ) {\n\t\tnumber = number.split( \".\" );\n\t\tnumber[ 0 ] = stringPad( number[ 0 ], minimumIntegerDigits );\n\t\tnumber = number.join( \".\" );\n\t}\n\n\treturn number;\n};\n\n\n\n\n/**\n * toPrecision( number, precision, round )\n *\n * @number (Number)\n *\n * @precision (Number) significant figures precision (not decimal precision).\n *\n * @round (Function)\n *\n * Return number.toPrecision( precision ) using the given round function.\n */\nvar numberToPrecision = function( number, precision, round ) {\n\tvar roundOrder;\n\n\troundOrder = Math.ceil( Math.log( Math.abs( number ) ) / Math.log( 10 ) );\n\troundOrder -= precision;\n\n\treturn round( number, { exponent: roundOrder } );\n};\n\n\n\n\n/**\n * toPrecision( number, minimumSignificantDigits, maximumSignificantDigits, round )\n *\n * @number [Number]\n *\n * @minimumSignificantDigits [Number]\n *\n * @maximumSignificantDigits [Number]\n *\n * @round [Function]\n *\n * Return the formatted significant digits number.\n */\nvar numberFormatSignificantDigits = function( number, minimumSignificantDigits, maximumSignificantDigits, round ) {\n\tvar atMinimum, atMaximum;\n\n\t// Sanity check.\n\tif ( minimumSignificantDigits > maximumSignificantDigits ) {\n\t\tmaximumSignificantDigits = minimumSignificantDigits;\n\t}\n\n\tatMinimum = numberToPrecision( number, minimumSignificantDigits, round );\n\tatMaximum = numberToPrecision( number, maximumSignificantDigits, round );\n\n\t// Use atMaximum only if it has more significant digits than atMinimum.\n\tnumber = +atMinimum === +atMaximum ? atMinimum : atMaximum;\n\n\t// Expand integer numbers, eg. 123e5 to 12300.\n\tnumber = ( +number ).toString( 10 );\n\n\tif ( ( /e/ ).test( number ) ) {\n\t\tthrow createErrorUnsupportedFeature({\n\t\t\tfeature: \"integers out of (1e21, 1e-7)\"\n\t\t});\n\t}\n\n\t// Add trailing zeros if necessary.\n\tif ( minimumSignificantDigits - number.replace( /^0+|\\./g, \"\" ).length > 0 ) {\n\t\tnumber = number.split( \".\" );\n\t\tnumber[ 1 ] = stringPad( number[ 1 ] || \"\", minimumSignificantDigits - number[ 0 ].replace( /^0+/, \"\" ).length, true );\n\t\tnumber = number.join( \".\" );\n\t}\n\n\treturn number;\n};\n\n\n\n\n/**\n * EBNF representation:\n *\n * number_pattern_re =        prefix?\n *                            padding?\n *                            (integer_fraction_pattern | significant_pattern)\n *                            scientific_notation?\n *                            suffix?\n *\n * prefix =                   non_number_stuff\n *\n * padding =                  \"*\" regexp(.)\n *\n * integer_fraction_pattern = integer_pattern\n *                            fraction_pattern?\n *\n * integer_pattern =          regexp([#,]*[0,]*0+)\n *\n * fraction_pattern =         \".\" regexp(0*[0-9]*#*)\n *\n * significant_pattern =      regexp([#,]*@+#*)\n *\n * scientific_notation =      regexp(E\\+?0+)\n *\n * suffix =                   non_number_stuff\n *\n * non_number_stuff =         regexp(('[^']+'|''|[^*#@0,.E])*)\n *\n *\n * Regexp groups:\n *\n *  0: number_pattern_re\n *  1: prefix\n *  2: -\n *  3: -\n *  4: padding\n *  5: (integer_fraction_pattern | significant_pattern)\n *  6: integer_fraction_pattern\n *  7: integer_pattern\n *  8: fraction_pattern\n *  9: significant_pattern\n * 10: scientific_notation\n * 11: suffix\n * 12: -\n */\nvar numberPatternRe = ( /^(('([^']|'')*'|[^*#@0,.E])*)(\\*.)?((([#,]*[0,]*0+)(\\.0*[0-9]*#*)?)|([#,]*@+#*))(E\\+?0+)?(('[^']+'|''|[^*#@0,.E])*)$/ );\n\n\n\n\n/**\n * removeLiteralQuotes( string )\n *\n * Return:\n * - `` if input string is `''`.\n * - `o'clock` if input string is `'o''clock'`.\n * - `foo` if input string is `foo`, i.e., return the same value in case it isn't a single-quoted\n *   string.\n */\nvar removeLiteralQuotes = function( string ) {\n\tif ( string[ 0 ] + string[ string.length - 1 ] !== \"''\" ) {\n\t\treturn string;\n\t}\n\tif ( string === \"''\" ) {\n\t\treturn \"\";\n\t}\n\treturn string.replace( /''/g, \"'\" ).slice( 1, -1 );\n};\n\n\n\n\n/**\n * format( number, properties )\n *\n * @number [Number].\n *\n * @properties [Object] Output of number/format-properties.\n *\n * Return the formatted number.\n * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html\n */\nvar numberFormat = function( number, properties, pluralGenerator ) {\n\tvar compactMap, infinitySymbol, maximumFractionDigits, maximumSignificantDigits,\n\tminimumFractionDigits, minimumIntegerDigits, minimumSignificantDigits, nanSymbol, nuDigitsMap,\n\tpadding, prefix, primaryGroupingSize, pattern, ret, round, roundIncrement,\n\tsecondaryGroupingSize, suffix, symbolMap;\n\n\tpadding = properties[ 1 ];\n\tminimumIntegerDigits = properties[ 2 ];\n\tminimumFractionDigits = properties[ 3 ];\n\tmaximumFractionDigits = properties[ 4 ];\n\tminimumSignificantDigits = properties[ 5 ];\n\tmaximumSignificantDigits = properties[ 6 ];\n\troundIncrement = properties[ 7 ];\n\tprimaryGroupingSize = properties[ 8 ];\n\tsecondaryGroupingSize = properties[ 9 ];\n\tround = properties[ 15 ];\n\tinfinitySymbol = properties[ 16 ];\n\tnanSymbol = properties[ 17 ];\n\tsymbolMap = properties[ 18 ];\n\tnuDigitsMap = properties[ 19 ];\n\tcompactMap = properties[ 20 ];\n\n\t// NaN\n\tif ( isNaN( number ) ) {\n\t\treturn nanSymbol;\n\t}\n\n\tif ( number < 0 ) {\n\t\tpattern = properties[ 12 ];\n\t\tprefix = properties[ 13 ];\n\t\tsuffix = properties[ 14 ];\n\t} else {\n\t\tpattern = properties[ 11 ];\n\t\tprefix = properties[ 0 ];\n\t\tsuffix = properties[ 10 ];\n\t}\n\n\t// Infinity\n\tif ( !isFinite( number ) ) {\n\t\treturn prefix + infinitySymbol + suffix;\n\t}\n\n\t// Percent\n\tif ( pattern.indexOf( \"%\" ) !== -1 ) {\n\t\tnumber *= 100;\n\n\t// Per mille\n\t} else if ( pattern.indexOf( \"\\u2030\" ) !== -1 ) {\n\t\tnumber *= 1000;\n\t}\n\n\tvar compactPattern, compactDigits, compactProperties, divisor, numberExponent, pluralForm;\n\n\t// Compact mode: initial number digit processing\n\tif ( compactMap ) {\n\t\tnumberExponent = Math.abs( Math.floor( number ) ).toString().length - 1;\n\t\tnumberExponent = Math.min( numberExponent, compactMap.maxExponent );\n\n\t\t// Use default plural form to perform initial decimal shift\n\t\tif ( numberExponent >= 3 ) {\n\t\t\tcompactPattern = compactMap[ numberExponent ] && compactMap[ numberExponent ].other;\n\t\t}\n\n\t\tif ( compactPattern === \"0\" ) {\n\t\t\tcompactPattern = null;\n\t\t} else if ( compactPattern ) {\n\t\t\tcompactDigits = compactPattern.split( \"0\" ).length - 1;\n\t\t\tdivisor = numberExponent - ( compactDigits - 1 );\n\t\t\tnumber = number / Math.pow( 10, divisor );\n\t\t}\n\t}\n\n\t// Significant digit format\n\tif ( !isNaN( minimumSignificantDigits * maximumSignificantDigits ) ) {\n\t\tnumber = numberFormatSignificantDigits( number, minimumSignificantDigits,\n\t\t\tmaximumSignificantDigits, round );\n\n\t// Integer and fractional format\n\t} else {\n\t\tnumber = numberFormatIntegerFractionDigits( number, minimumIntegerDigits,\n\t\t\tminimumFractionDigits, maximumFractionDigits, round, roundIncrement );\n\t}\n\n\t// Compact mode: apply formatting\n\tif ( compactMap && compactPattern ) {\n\n\t\t// Get plural form after possible roundings\n\t\tpluralForm = pluralGenerator ? pluralGenerator( +number ) : \"other\";\n\n\t\tcompactPattern = compactMap[ numberExponent ][ pluralForm ] || compactPattern;\n\t\tcompactProperties = compactPattern.match( numberCompactPatternRe );\n\n\t\t// update prefix/suffix with compact prefix/suffix\n\t\tprefix += compactProperties[ 1 ];\n\t\tsuffix = compactProperties[ 3 ] + suffix;\n\t}\n\n\t// Remove the possible number minus sign\n\tnumber = number.replace( /^-/, \"\" );\n\n\t// Grouping separators\n\tif ( primaryGroupingSize ) {\n\t\tnumber = numberFormatGroupingSeparator( number, primaryGroupingSize,\n\t\t\tsecondaryGroupingSize );\n\t}\n\n\tret = prefix;\n\n\tret += number;\n\n\t// Scientific notation\n\t// TODO implement here\n\n\t// Padding/'([^']|'')+'|''|[.,\\-+E%\\u2030]/g\n\t// TODO implement here\n\n\tret += suffix;\n\n\treturn ret.replace( /('([^']|'')+'|'')|./g, function( character, literal ) {\n\n\t\t// Literals\n\t\tif ( literal ) {\n\t\t\treturn removeLiteralQuotes( literal );\n\t\t}\n\n\t\t// Symbols\n\t\tcharacter = character.replace( /[.,\\-+E%\\u2030]/, function( symbol ) {\n\t\t\treturn symbolMap[ symbol ];\n\t\t});\n\n\t\t// Numbering system\n\t\tif ( nuDigitsMap ) {\n\t\t\tcharacter = character.replace( /[0-9]/, function( digit ) {\n\t\t\t\treturn nuDigitsMap[ +digit ];\n\t\t\t});\n\t\t}\n\n\t\treturn character;\n\t});\n};\n\n\n\n\nvar numberFormatterFn = function( properties, pluralGenerator ) {\n\treturn function numberFormatter( value ) {\n\t\tvalidateParameterPresence( value, \"value\" );\n\t\tvalidateParameterTypeNumber( value, \"value\" );\n\n\t\treturn numberFormat( value, properties, pluralGenerator );\n\t};\n};\n\n\n\n\n/**\n * NumberingSystem( cldr )\n *\n * - http://www.unicode.org/reports/tr35/tr35-numbers.html#otherNumberingSystems\n * - http://cldr.unicode.org/index/bcp47-extension\n * - http://www.unicode.org/reports/tr35/#u_Extension\n */\nvar numberNumberingSystem = function( cldr ) {\n\tvar nu = cldr.attributes[ \"u-nu\" ];\n\n\tif ( nu ) {\n\t\tif ( nu === \"traditio\" ) {\n\t\t\tnu = \"traditional\";\n\t\t}\n\t\tif ( [ \"native\", \"traditional\", \"finance\" ].indexOf( nu ) !== -1 ) {\n\n\t\t\t// Unicode locale extension `u-nu` is set using either (native, traditional or\n\t\t\t// finance). So, lookup the respective locale's numberingSystem and return it.\n\t\t\treturn cldr.main([ \"numbers/otherNumberingSystems\", nu ]);\n\t\t}\n\n\t\t// Unicode locale extension `u-nu` is set with an explicit numberingSystem. Return it.\n\t\treturn nu;\n\t}\n\n\t// Return the default numberingSystem.\n\treturn cldr.main( \"numbers/defaultNumberingSystem\" );\n};\n\n\n\n\n/**\n * Compact( name, cldr )\n *\n * @compactType [String] Compact mode, `short` or `long`.\n *\n * @cldr [Cldr instance].\n *\n * Return the localized compact map for the given compact mode.\n */\nvar numberCompact = function( compactType, cldr ) {\n\tvar maxExponent = 0;\n\n\tvar object = cldr.main([\n\t\t\"numbers/decimalFormats-numberSystem-\" + numberNumberingSystem( cldr ),\n\t\tcompactType,\n\t\t\"decimalFormat\"\n\t]);\n\n\tobject = Object.keys( object ).reduce(function( newObject, compactKey ) {\n\t\tvar numberExponent = compactKey.split( \"0\" ).length - 1;\n\t\tvar pluralForm = compactKey.split( \"-\" )[ 2 ];\n\t\tnewObject[ numberExponent ] = newObject[ numberExponent ] || {};\n\t\tnewObject[ numberExponent ][ pluralForm ] = object[ compactKey ];\n\t\tmaxExponent = Math.max( numberExponent, maxExponent );\n\t\treturn newObject;\n\t}, {});\n\n\tobject.maxExponent = maxExponent;\n\n\treturn object;\n};\n\n\n\n\n/**\n * nuMap( cldr )\n *\n * @cldr [Cldr instance].\n *\n * Return digits map if numbering system is different than `latn`.\n */\nvar numberNumberingSystemDigitsMap = function( cldr ) {\n\tvar aux,\n\t\tnu = numberNumberingSystem( cldr );\n\n\tif ( nu === \"latn\" ) {\n\t\treturn;\n\t}\n\n\taux = cldr.supplemental([ \"numberingSystems\", nu ]);\n\n\tif ( aux._type !== \"numeric\" ) {\n\t\tthrow createErrorUnsupportedFeature( \"`\" + aux._type + \"` numbering system\" );\n\t}\n\n\treturn aux._digits;\n};\n\n\n\n\n/**\n * format( number, pattern )\n *\n * @number [Number].\n *\n * @pattern [String] raw pattern for numbers.\n *\n * Return the formatted number.\n * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html\n */\nvar numberPatternProperties = function( pattern ) {\n\tvar aux1, aux2, fractionPattern, integerFractionOrSignificantPattern, integerPattern,\n\t\tmaximumFractionDigits, maximumSignificantDigits, minimumFractionDigits,\n\t\tminimumIntegerDigits, minimumSignificantDigits, padding, prefix, primaryGroupingSize,\n\t\troundIncrement, scientificNotation, secondaryGroupingSize, significantPattern, suffix;\n\n\tpattern = pattern.match( numberPatternRe );\n\tif ( !pattern ) {\n\t\tthrow new Error( \"Invalid pattern: \" + pattern );\n\t}\n\n\tprefix = pattern[ 1 ];\n\tpadding = pattern[ 4 ];\n\tintegerFractionOrSignificantPattern = pattern[ 5 ];\n\tsignificantPattern = pattern[ 9 ];\n\tscientificNotation = pattern[ 10 ];\n\tsuffix = pattern[ 11 ];\n\n\t// Significant digit format\n\tif ( significantPattern ) {\n\t\tsignificantPattern.replace( /(@+)(#*)/, function( match, minimumSignificantDigitsMatch, maximumSignificantDigitsMatch ) {\n\t\t\tminimumSignificantDigits = minimumSignificantDigitsMatch.length;\n\t\t\tmaximumSignificantDigits = minimumSignificantDigits +\n\t\t\t\tmaximumSignificantDigitsMatch.length;\n\t\t});\n\n\t// Integer and fractional format\n\t} else {\n\t\tfractionPattern = pattern[ 8 ];\n\t\tintegerPattern = pattern[ 7 ];\n\n\t\tif ( fractionPattern ) {\n\n\t\t\t// Minimum fraction digits, and rounding.\n\t\t\tfractionPattern.replace( /[0-9]+/, function( match ) {\n\t\t\t\tminimumFractionDigits = match;\n\t\t\t});\n\t\t\tif ( minimumFractionDigits ) {\n\t\t\t\troundIncrement = +( \"0.\" + minimumFractionDigits );\n\t\t\t\tminimumFractionDigits = minimumFractionDigits.length;\n\t\t\t} else {\n\t\t\t\tminimumFractionDigits = 0;\n\t\t\t}\n\n\t\t\t// Maximum fraction digits\n\t\t\t// 1: ignore decimal character\n\t\t\tmaximumFractionDigits = fractionPattern.length - 1 /* 1 */;\n\t\t} else {\n\t\t\tminimumFractionDigits = 0;\n\t\t\tmaximumFractionDigits = 0;\n\t\t}\n\n\t\t// Minimum integer digits\n\t\tintegerPattern.replace( /0+$/, function( match ) {\n\t\t\tminimumIntegerDigits = match.length;\n\t\t});\n\t}\n\n\t// Scientific notation\n\tif ( scientificNotation ) {\n\t\tthrow createErrorUnsupportedFeature({\n\t\t\tfeature: \"scientific notation (not implemented)\"\n\t\t});\n\t}\n\n\t// Padding\n\tif ( padding ) {\n\t\tthrow createErrorUnsupportedFeature({\n\t\t\tfeature: \"padding (not implemented)\"\n\t\t});\n\t}\n\n\t// Grouping\n\tif ( ( aux1 = integerFractionOrSignificantPattern.lastIndexOf( \",\" ) ) !== -1 ) {\n\n\t\t// Primary grouping size is the interval between the last group separator and the end of\n\t\t// the integer (or the end of the significant pattern).\n\t\taux2 = integerFractionOrSignificantPattern.split( \".\" )[ 0 ];\n\t\tprimaryGroupingSize = aux2.length - aux1 - 1;\n\n\t\t// Secondary grouping size is the interval between the last two group separators.\n\t\tif ( ( aux2 = integerFractionOrSignificantPattern.lastIndexOf( \",\", aux1 - 1 ) ) !== -1 ) {\n\t\t\tsecondaryGroupingSize = aux1 - 1 - aux2;\n\t\t}\n\t}\n\n\t// Return:\n\t//  0: @prefix String\n\t//  1: @padding Array [ <character>, <count> ] TODO\n\t//  2: @minimumIntegerDigits non-negative integer Number value indicating the minimum integer\n\t//        digits to be used. Numbers will be padded with leading zeroes if necessary.\n\t//  3: @minimumFractionDigits and\n\t//  4: @maximumFractionDigits are non-negative integer Number values indicating the minimum and\n\t//        maximum fraction digits to be used. Numbers will be rounded or padded with trailing\n\t//        zeroes if necessary.\n\t//  5: @minimumSignificantDigits and\n\t//  6: @maximumSignificantDigits are positive integer Number values indicating the minimum and\n\t//        maximum fraction digits to be shown. Either none or both of these properties are\n\t//        present; if they are, they override minimum and maximum integer and fraction digits\n\t//        – the formatter uses however many integer and fraction digits are required to display\n\t//        the specified number of significant digits.\n\t//  7: @roundIncrement Decimal round increment or null\n\t//  8: @primaryGroupingSize\n\t//  9: @secondaryGroupingSize\n\t// 10: @suffix String\n\treturn [\n\t\tprefix,\n\t\tpadding,\n\t\tminimumIntegerDigits,\n\t\tminimumFractionDigits,\n\t\tmaximumFractionDigits,\n\t\tminimumSignificantDigits,\n\t\tmaximumSignificantDigits,\n\t\troundIncrement,\n\t\tprimaryGroupingSize,\n\t\tsecondaryGroupingSize,\n\t\tsuffix\n\t];\n};\n\n\n\n\n/**\n * Symbol( name, cldr )\n *\n * @name [String] Symbol name.\n *\n * @cldr [Cldr instance].\n *\n * Return the localized symbol given its name.\n */\nvar numberSymbol = function( name, cldr ) {\n\treturn cldr.main([\n\t\t\"numbers/symbols-numberSystem-\" + numberNumberingSystem( cldr ),\n\t\tname\n\t]);\n};\n\n\n\n\nvar numberSymbolName = {\n\t\".\": \"decimal\",\n\t\",\": \"group\",\n\t\"%\": \"percentSign\",\n\t\"+\": \"plusSign\",\n\t\"-\": \"minusSign\",\n\t\"E\": \"exponential\",\n\t\"\\u2030\": \"perMille\"\n};\n\n\n\n\n/**\n * symbolMap( cldr )\n *\n * @cldr [Cldr instance].\n *\n * Return the (localized symbol, pattern symbol) key value pair, eg. {\n *   \".\": \"٫\",\n *   \",\": \"٬\",\n *   \"%\": \"٪\",\n *   ...\n * };\n */\nvar numberSymbolMap = function( cldr ) {\n\tvar symbol,\n\t\tsymbolMap = {};\n\n\tfor ( symbol in numberSymbolName ) {\n\t\tsymbolMap[ symbol ] = numberSymbol( numberSymbolName[ symbol ], cldr );\n\t}\n\n\treturn symbolMap;\n};\n\n\n\n\nvar numberTruncate = function( value ) {\n\tif ( isNaN( value ) ) {\n\t\treturn NaN;\n\t}\n\treturn Math[ value < 0 ? \"ceil\" : \"floor\" ]( value );\n};\n\n\n\n\n/**\n * round( method )\n *\n * @method [String] with either \"round\", \"ceil\", \"floor\", or \"truncate\".\n *\n * Return function( value, incrementOrExp ):\n *\n *   @value [Number] eg. 123.45.\n *\n *   @incrementOrExp [Number] optional, eg. 0.1; or\n *     [Object] Either { increment: <value> } or { exponent: <value> }\n *\n *   Return the rounded number, eg:\n *   - round( \"round\" )( 123.45 ): 123;\n *   - round( \"ceil\" )( 123.45 ): 124;\n *   - round( \"floor\" )( 123.45 ): 123;\n *   - round( \"truncate\" )( 123.45 ): 123;\n *   - round( \"round\" )( 123.45, 0.1 ): 123.5;\n *   - round( \"round\" )( 123.45, 10 ): 120;\n *\n *   Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round\n *   Ref: #376\n */\nvar numberRound = function( method ) {\n\tmethod = method || \"round\";\n\tmethod = method === \"truncate\" ? numberTruncate : Math[ method ];\n\n\treturn function( value, incrementOrExp ) {\n\t\tvar exp, increment;\n\n\t\tvalue = +value;\n\n\t\t// If the value is not a number, return NaN.\n\t\tif ( isNaN( value ) ) {\n\t\t\treturn NaN;\n\t\t}\n\n\t\t// Exponent given.\n\t\tif ( typeof incrementOrExp === \"object\" && incrementOrExp.exponent ) {\n\t\t\texp = +incrementOrExp.exponent;\n\t\t\tincrement = 1;\n\n\t\t\tif ( exp === 0 ) {\n\t\t\t\treturn method( value );\n\t\t\t}\n\n\t\t\t// If the exp is not an integer, return NaN.\n\t\t\tif ( !( typeof exp === \"number\" && exp % 1 === 0 ) ) {\n\t\t\t\treturn NaN;\n\t\t\t}\n\n\t\t// Increment given.\n\t\t} else {\n\t\t\tincrement = +incrementOrExp || 1;\n\n\t\t\tif ( increment === 1 ) {\n\t\t\t\treturn method( value );\n\t\t\t}\n\n\t\t\t// If the increment is not a number, return NaN.\n\t\t\tif ( isNaN( increment ) ) {\n\t\t\t\treturn NaN;\n\t\t\t}\n\n\t\t\tincrement = increment.toExponential().split( \"e\" );\n\t\t\texp = +increment[ 1 ];\n\t\t\tincrement = +increment[ 0 ];\n\t\t}\n\n\t\t// Shift & Round\n\t\tvalue = value.toString().split( \"e\" );\n\t\tvalue[ 0 ] = +value[ 0 ] / increment;\n\t\tvalue[ 1 ] = value[ 1 ] ? ( +value[ 1 ] - exp ) : -exp;\n\t\tvalue = method( +( value[ 0 ] + \"e\" + value[ 1 ] ) );\n\n\t\t// Shift back\n\t\tvalue = value.toString().split( \"e\" );\n\t\tvalue[ 0 ] = +value[ 0 ] * increment;\n\t\tvalue[ 1 ] = value[ 1 ] ? ( +value[ 1 ] + exp ) : exp;\n\t\treturn +( value[ 0 ] + \"e\" + value[ 1 ] );\n\t};\n};\n\n\n\n\n/**\n * formatProperties( pattern, cldr [, options] )\n *\n * @pattern [String] raw pattern for numbers.\n *\n * @cldr [Cldr instance].\n *\n * @options [Object]:\n * - minimumIntegerDigits [Number]\n * - minimumFractionDigits, maximumFractionDigits [Number]\n * - minimumSignificantDigits, maximumSignificantDigits [Number]\n * - round [String] \"ceil\", \"floor\", \"round\" (default), or \"truncate\".\n * - useGrouping [Boolean] default true.\n *\n * Return the processed properties that will be used in number/format.\n * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html\n */\nvar numberFormatProperties = function( pattern, cldr, options ) {\n\tvar negativePattern, negativePrefix, negativeProperties, negativeSuffix, positivePattern,\n\t\troundFn, properties;\n\n\tfunction getOptions( attribute, propertyIndex ) {\n\t\tif ( attribute in options ) {\n\t\t\tproperties[ propertyIndex ] = options[ attribute ];\n\t\t}\n\t}\n\n\toptions = options || {};\n\tpattern = pattern.split( \";\" );\n\n\tpositivePattern = pattern[ 0 ];\n\n\tnegativePattern = pattern[ 1 ] || \"-\" + positivePattern;\n\tnegativeProperties = numberPatternProperties( negativePattern );\n\tnegativePrefix = negativeProperties[ 0 ];\n\tnegativeSuffix = negativeProperties[ 10 ];\n\n\t// Have runtime code to refer to numberRound() instead of including it explicitly.\n\troundFn = numberRound( options.round );\n\troundFn.generatorString = function() {\n\t\treturn \"numberRound(\" + ( options.round ? \"\\\"\" + options.round + \"\\\"\" : \"\" ) + \")\";\n\t};\n\n\tproperties = numberPatternProperties( positivePattern ).concat([\n\t\tpositivePattern,\n\t\tnegativePrefix + positivePattern + negativeSuffix,\n\t\tnegativePrefix,\n\t\tnegativeSuffix,\n\t\troundFn,\n\t\tnumberSymbol( \"infinity\", cldr ),\n\t\tnumberSymbol( \"nan\", cldr ),\n\t\tnumberSymbolMap( cldr ),\n\t\tnumberNumberingSystemDigitsMap( cldr )\n\t]);\n\n\tif ( options.compact ) {\n\n\t\t// The compact digits number pattern is always `0+`, so override the following properties.\n\t\t// Note: minimumIntegerDigits would actually range from `0` to `000` based on the scale of\n\t\t// the value to be formatted, though we're always using 1 as a simplification, because the\n\t\t// number won't be zero-padded since we chose the right format based on the scale, i.e.,\n\t\t// we'd never see something like `003M` anyway.\n\t\tproperties[ 2 ] = 1; // minimumIntegerDigits\n\t\tproperties[ 3 ] = 0; // minimumFractionDigits\n\t\tproperties[ 4 ] = 0; // maximumFractionDigits\n\t\tproperties[ 5 ] = // minimumSignificantDigits &\n\t\t\tproperties[ 6 ] = undefined ; // maximumSignificantDigits\n\n\t\tproperties[20] = numberCompact( options.compact, cldr );\n\t}\n\n\tgetOptions( \"minimumIntegerDigits\", 2 );\n\tgetOptions( \"minimumFractionDigits\", 3 );\n\tgetOptions( \"maximumFractionDigits\", 4 );\n\tgetOptions( \"minimumSignificantDigits\", 5 );\n\tgetOptions( \"maximumSignificantDigits\", 6 );\n\n\t// Grouping separators\n\tif ( options.useGrouping === false ) {\n\t\tproperties[ 8 ] = null;\n\t}\n\n\t// Normalize number of digits if only one of either minimumFractionDigits or\n\t// maximumFractionDigits is passed in as an option\n\tif ( \"minimumFractionDigits\" in options && !( \"maximumFractionDigits\" in options ) ) {\n\n\t\t// maximumFractionDigits = Math.max( minimumFractionDigits, maximumFractionDigits );\n\t\tproperties[ 4 ] = Math.max( properties[ 3 ], properties[ 4 ] );\n\t} else if ( !( \"minimumFractionDigits\" in options ) &&\n\t\t\t\"maximumFractionDigits\" in options ) {\n\n\t\t// minimumFractionDigits = Math.min( minimumFractionDigits, maximumFractionDigits );\n\t\tproperties[ 3 ] = Math.min( properties[ 3 ], properties[ 4 ] );\n\t}\n\n\t// Return:\n\t// 0-10: see number/pattern-properties.\n\t// 11: @positivePattern [String] Positive pattern.\n\t// 12: @negativePattern [String] Negative pattern.\n\t// 13: @negativePrefix [String] Negative prefix.\n\t// 14: @negativeSuffix [String] Negative suffix.\n\t// 15: @round [Function] Round function.\n\t// 16: @infinitySymbol [String] Infinity symbol.\n\t// 17: @nanSymbol [String] NaN symbol.\n\t// 18: @symbolMap [Object] A bunch of other symbols.\n\t// 19: @nuDigitsMap [Array] Digits map if numbering system is different than `latn`.\n\t// 20: @compactMap [Object] Map of per-digit-count format patterns for specified compact mode.\n\treturn properties;\n};\n\n\n\n\n/**\n * Generated by:\n *\n * var regenerate = require( \"regenerate\" );\n * var formatSymbols = require( * \"unicode-8.0.0/General_Category/Format/symbols\" );\n * regenerate().add( formatSymbols ).toString();\n *\n * https://github.com/mathiasbynens/regenerate\n * https://github.com/mathiasbynens/unicode-8.0.0\n */\nvar regexpCfG = /[\\xAD\\u0600-\\u0605\\u061C\\u06DD\\u070F\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u2064\\u2066-\\u206F\\uFEFF\\uFFF9-\\uFFFB]|\\uD804\\uDCBD|\\uD82F[\\uDCA0-\\uDCA3]|\\uD834[\\uDD73-\\uDD7A]|\\uDB40[\\uDC01\\uDC20-\\uDC7F]/g;\n\n\n\n\n/**\n * Generated by:\n *\n * var regenerate = require( \"regenerate\" );\n * var dashSymbols = require( * \"unicode-8.0.0/General_Category/Dash_Punctuation/symbols\" );\n * regenerate().add( dashSymbols ).toString();\n *\n * https://github.com/mathiasbynens/regenerate\n * https://github.com/mathiasbynens/unicode-8.0.0\n *\n * NOTE: In addition to [:dash:],  the below includes MINUS SIGN U+2212.\n */\nvar regexpDashG = /[\\-\\u058A\\u05BE\\u1400\\u1806\\u2010-\\u2015\\u2E17\\u2E1A\\u2E3A\\u2E3B\\u2E40\\u301C\\u3030\\u30A0\\uFE31\\uFE32\\uFE58\\uFE63\\uFF0D\\u2212]/g;\n\n\n\n\n/**\n * Generated by:\n *\n * var regenerate = require( \"regenerate\" );\n * var spaceSeparatorSymbols = require( \"unicode-8.0.0/General_Category/Space_Separator/symbols\" );\n * regenerate().add( spaceSeparatorSymbols ).toString();\n *\n * https://github.com/mathiasbynens/regenerate\n * https://github.com/mathiasbynens/unicode-8.0.0\n */\nvar regexpZsG = /[ \\xA0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000]/g;\n\n\n\n\n/**\n * Loose Matching:\n * - Ignore all format characters, which includes RLM, LRM or ALM used to control BIDI\n *   formatting.\n * - Map all characters in [:Zs:] to U+0020 SPACE;\n * - Map all characters in [:Dash:] to U+002D HYPHEN-MINUS;\n */\nvar looseMatching = function( value ) {\n\treturn value\n\t\t.replace( regexpCfG, \"\" )\n\t\t.replace( regexpDashG, \"-\" )\n\t\t.replace( regexpZsG, \" \" );\n};\n\n\n\n\n/**\n * parse( value, properties )\n *\n * @value [String].\n *\n * @properties [Object] Parser properties is a reduced pre-processed cldr\n * data set returned by numberParserProperties().\n *\n * Return the parsed Number (including Infinity) or NaN when value is invalid.\n * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html\n */\nvar numberParse = function( value, properties ) {\n\tvar grammar, invertedNuDigitsMap, invertedSymbolMap, negative, number, prefix, prefixNSuffix,\n\t\tsuffix, tokenizer, valid;\n\n\t// Grammar:\n\t// - Value <=           NaN | PositiveNumber | NegativeNumber\n\t// - PositiveNumber <=  PositivePrefix NumberOrInf PositiveSufix\n\t// - NegativeNumber <=  NegativePrefix NumberOrInf\n\t// - NumberOrInf <=     Number | Inf\n\tgrammar = [\n\t\t[ \"nan\" ],\n\t\t[ \"prefix\", \"infinity\", \"suffix\" ],\n\t\t[ \"prefix\", \"number\", \"suffix\" ],\n\t\t[ \"negativePrefix\", \"infinity\", \"negativeSuffix\" ],\n\t\t[ \"negativePrefix\", \"number\", \"negativeSuffix\" ]\n\t];\n\n\tinvertedSymbolMap = properties[ 0 ];\n\tinvertedNuDigitsMap = properties[ 1 ] || {};\n\ttokenizer = properties[ 2 ];\n\n\tvalue = looseMatching( value );\n\n\tfunction parse( type ) {\n\t\treturn function( lexeme ) {\n\n\t\t\t// Reverse localized symbols and numbering system.\n\t\t\tlexeme = lexeme.split( \"\" ).map(function( character ) {\n\t\t\t\treturn invertedSymbolMap[ character ] ||\n\t\t\t\t\tinvertedNuDigitsMap[ character ] ||\n\t\t\t\t\tcharacter;\n\t\t\t}).join( \"\" );\n\n\t\t\tswitch ( type ) {\n\t\t\t\tcase \"infinity\":\n\t\t\t\t\tnumber = Infinity;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"nan\":\n\t\t\t\t\tnumber = NaN;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"number\":\n\n\t\t\t\t\t// Remove grouping separators.\n\t\t\t\t\tlexeme = lexeme.replace( /,/g, \"\" );\n\n\t\t\t\t\tnumber = +lexeme;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"prefix\":\n\t\t\t\tcase \"negativePrefix\":\n\t\t\t\t\tprefix = lexeme;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"suffix\":\n\t\t\t\t\tsuffix = lexeme;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"negativeSuffix\":\n\t\t\t\t\tsuffix = lexeme;\n\t\t\t\t\tnegative = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t// This should never be reached.\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( \"Internal error\" );\n\t\t\t}\n\t\t\treturn \"\";\n\t\t};\n\t}\n\n\tfunction tokenizeNParse( _value, grammar ) {\n\t\treturn grammar.some(function( statement ) {\n\t\t\tvar value = _value;\n\n\t\t\t// The whole grammar statement should be used (i.e., .every() return true) and value be\n\t\t\t// entirely consumed (i.e., !value.length).\n\t\t\treturn statement.every(function( type ) {\n\t\t\t\tif ( value.match( tokenizer[ type ] ) === null ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Consume and parse it.\n\t\t\t\tvalue = value.replace( tokenizer[ type ], parse( type ) );\n\t\t\t\treturn true;\n\t\t\t}) && !value.length;\n\t\t});\n\t}\n\n\tvalid = tokenizeNParse( value, grammar );\n\n\t// NaN\n\tif ( !valid || isNaN( number ) ) {\n\t\treturn NaN;\n\t}\n\n\tprefixNSuffix = \"\" + prefix + suffix;\n\n\t// Percent\n\tif ( prefixNSuffix.indexOf( \"%\" ) !== -1 ) {\n\t\tnumber /= 100;\n\n\t// Per mille\n\t} else if ( prefixNSuffix.indexOf( \"\\u2030\" ) !== -1 ) {\n\t\tnumber /= 1000;\n\t}\n\n\t// Negative number\n\tif ( negative ) {\n\t\tnumber *= -1;\n\t}\n\n\treturn number;\n};\n\n\n\n\nvar numberParserFn = function( properties ) {\n\treturn function numberParser( value ) {\n\t\tvalidateParameterPresence( value, \"value\" );\n\t\tvalidateParameterTypeString( value, \"value\" );\n\n\t\treturn numberParse( value, properties );\n\t};\n\n};\n\n\n\n\n/**\n * symbolMap( cldr )\n *\n * @cldr [Cldr instance].\n *\n * Return the (localized symbol, pattern symbol) key value pair, eg. {\n *   \"٫\": \".\",\n *   \"٬\": \",\",\n *   \"٪\": \"%\",\n *   ...\n * };\n */\nvar numberSymbolInvertedMap = function( cldr ) {\n\tvar symbol,\n\t\tsymbolMap = {};\n\n\tfor ( symbol in numberSymbolName ) {\n\t\tsymbolMap[ numberSymbol( numberSymbolName[ symbol ], cldr ) ] = symbol;\n\t}\n\n\treturn symbolMap;\n};\n\n\n\n\n/**\n * objectMap( object, fn)\n *\n * - object\n *\n * - fn( pair ) => pair\n */\nvar objectMap = function( object, fn ) {\n\treturn Object.keys( object ).map(function( key ) {\n\t\treturn fn([ key, object[ key ] ]);\n\t}).reduce(function( object, pair ) {\n\t\tobject[ pair[ 0 ] ] = pair[ 1 ];\n\t\treturn object;\n\t}, {});\n};\n\n\n\n\n/**\n * parseProperties( pattern, cldr )\n *\n * @pattern [String] raw pattern for numbers.\n *\n * @cldr [Cldr instance].\n *\n * Return parser properties, used to feed parser function.\n *\n * TODO:\n * - Scientific_notation;\n * - Padding;\n */\nvar numberParseProperties = function( pattern, cldr, options ) {\n\tvar aux, decimalSymbolRe, digitsRe, groupingSeparatorRe, infinitySymbol, invertedNuDigitsMap,\n\t\tinvertedSymbolMap, maximumFractionDigits, maximumSignificantDigits,\n\t\tminimumSignificantDigits, nanSymbol, negativePrefix, negativeSuffix, nuDigitsMap,\n\t\tnumberTokenizer, prefix, primaryGroupingSize, secondaryGroupingSize, suffix, symbolMap,\n\t\tformatProperties = numberFormatProperties( pattern, cldr, options );\n\n\tprefix = looseMatching( formatProperties[ 0 ] );\n\tmaximumFractionDigits = formatProperties[ 4 ];\n\tminimumSignificantDigits = formatProperties[ 5 ];\n\tmaximumSignificantDigits = formatProperties[ 6 ];\n\tprimaryGroupingSize = formatProperties[ 8 ];\n\tsecondaryGroupingSize = formatProperties[ 9 ];\n\tsuffix = looseMatching( formatProperties[ 10 ] );\n\tnegativePrefix = looseMatching( formatProperties[ 13 ] );\n\tnegativeSuffix = looseMatching( formatProperties[ 14 ] );\n\tinfinitySymbol = looseMatching( formatProperties[ 16 ] );\n\tnanSymbol = looseMatching( formatProperties[ 17 ] );\n\tsymbolMap = objectMap( formatProperties[ 18 ], function( pair ) {\n\t\treturn [ pair[ 0 ], looseMatching( pair[ 1 ] ) ];\n\t});\n\tnuDigitsMap = formatProperties[ 19 ];\n\n\tinvertedSymbolMap = objectMap( numberSymbolInvertedMap( cldr ), function( pair ) {\n\t\treturn [ looseMatching( pair[ 0 ] ), pair[ 1 ] ];\n\t});\n\n\tdigitsRe = nuDigitsMap ? \"[\" + nuDigitsMap + \"]\" : \"\\\\d\";\n\tgroupingSeparatorRe = regexpEscape( symbolMap[ \",\" ] );\n\tdecimalSymbolRe = regexpEscape( symbolMap[ \".\" ] );\n\n\tif ( nuDigitsMap ) {\n\t\tinvertedNuDigitsMap = nuDigitsMap.split( \"\" ).reduce(function( object, localizedDigit, i ) {\n\t\t\tobject[ localizedDigit ] = String( i );\n\t\t\treturn object;\n\t\t}, {} );\n\t}\n\n\taux = [ prefix, suffix, negativePrefix, negativeSuffix ].map(function( value ) {\n\t\treturn value.replace( /('([^']|'')+'|'')|./g, function( character, literal ) {\n\n\t\t\t// Literals\n\t\t\tif ( literal ) {\n\t\t\t\treturn removeLiteralQuotes( literal );\n\t\t\t}\n\n\t\t\t// Symbols\n\t\t\tcharacter = character.replace( /[\\-+E%\\u2030]/, function( symbol ) {\n\t\t\t\treturn symbolMap[ symbol ];\n\t\t\t});\n\n\t\t\treturn character;\n\t\t});\n\t});\n\n\tprefix = aux[ 0 ];\n\tsuffix = aux[ 1 ];\n\tnegativePrefix = aux[ 2 ];\n\tnegativeSuffix = aux[ 3 ];\n\n\t// Number\n\t//\n\t// number_re =                       integer fraction?\n\t//\n\t// integer =                         digits | digits_using_grouping_separators\n\t//\n\t// fraction =                        regexp((.\\d+)?)\n\t//\n\t// digits =                          regexp(\\d+)\n\t//\n\t// digits_w_grouping_separators =    digits_w_1_grouping_separators |\n\t//                                   digits_w_2_grouping_separators\n\t//\n\t// digits_w_1_grouping_separators =  regexp(\\d{1,3}(,\\d{3})+)\n\t//\n\t// digits_w_2_grouping_separators =  regexp(\\d{1,2}((,\\d{2})*(,\\d{3})))\n\n\t// Integer part\n\tnumberTokenizer = digitsRe + \"+\";\n\n\t// Grouping separators\n\tif ( primaryGroupingSize ) {\n\t\tif ( secondaryGroupingSize ) {\n\t\t\taux = digitsRe + \"{1,\" + secondaryGroupingSize + \"}((\" + groupingSeparatorRe +\n\t\t\t\tdigitsRe + \"{\" + secondaryGroupingSize + \"})*(\" + groupingSeparatorRe +\n\t\t\t\tdigitsRe + \"{\" + primaryGroupingSize + \"}))\";\n\t\t} else {\n\t\t\taux = digitsRe + \"{1,\" + primaryGroupingSize + \"}(\" + groupingSeparatorRe +\n\t\t\t\tdigitsRe + \"{\" + primaryGroupingSize + \"})+\";\n\t\t}\n\t\tnumberTokenizer = \"(\" + aux + \"|\" + numberTokenizer + \")\";\n\t}\n\n\t// Fraction part? Only included if 1 or 2.\n\t// 1: Using significant digit format.\n\t// 2: Using integer and fractional format && it has a maximumFractionDigits.\n\tif ( !isNaN( minimumSignificantDigits * maximumSignificantDigits ) || /* 1 */\n\t\t\t\tmaximumFractionDigits /* 2 */ ) {\n\n\t\t// 1: Handle trailing decimal separator, e.g., `\"1.\" => `1``.\n\t\taux = decimalSymbolRe + digitsRe + \"+\";\n\t\tnumberTokenizer = numberTokenizer + \"(\" + aux + \"|\" + decimalSymbolRe /* 1 */ + \")?\" +\n\n\t\t\t// Handle non-padded decimals, e.g., `\".12\"` => `0.12` by making the integer part\n\t\t\t// optional.\n\t\t\t\"|(\" + numberTokenizer + \")?\" + aux;\n\n\t\tnumberTokenizer = \"(\" + numberTokenizer + \")\";\n\t}\n\n\t// 0: @invertedSymbolMap [Object] Inverted symbol map.\n\t// 1: @invertedNuDigitsMap [Object] Inverted digits map if numbering system is different than\n\t//    `latn`.\n\t// 2: @tokenizer [Object] Tokenizer map, used by parser to consume input.\n\treturn [\n\t\tinvertedSymbolMap,\n\t\tinvertedNuDigitsMap,\n\t\t{\n\t\t\tinfinity: new RegExp( \"^\" + regexpEscape( infinitySymbol ) ),\n\t\t\tnan:  new RegExp( \"^\" + regexpEscape( nanSymbol ) ),\n\t\t\tnegativePrefix: new RegExp( \"^\" + regexpEscape( negativePrefix ) ),\n\t\t\tnegativeSuffix: new RegExp( \"^\" + regexpEscape( negativeSuffix ) ),\n\t\t\tnumber: new RegExp( \"^\" + numberTokenizer ),\n\t\t\tprefix: new RegExp( \"^\" + regexpEscape( prefix ) ),\n\t\t\tsuffix: new RegExp( \"^\" + regexpEscape( suffix ) )\n\t\t}\n\t];\n\n};\n\n\n\n\n/**\n * Pattern( style )\n *\n * @style [String] \"decimal\" (default) or \"percent\".\n *\n * @cldr [Cldr instance].\n */\nvar numberPattern = function( style, cldr ) {\n\tif ( style !== \"decimal\" && style !== \"percent\" ) {\n\t\tthrow new Error( \"Invalid style\" );\n\t}\n\n\treturn cldr.main([\n\t\t\"numbers\",\n\t\tstyle + \"Formats-numberSystem-\" + numberNumberingSystem( cldr ),\n\t\t\"standard\"\n\t]);\n};\n\n\n\n\nfunction validateDigits( properties ) {\n\tvar minimumIntegerDigits = properties[ 2 ],\n\t\tminimumFractionDigits = properties[ 3 ],\n\t\tmaximumFractionDigits = properties[ 4 ],\n\t\tminimumSignificantDigits = properties[ 5 ],\n\t\tmaximumSignificantDigits = properties[ 6 ];\n\n\t// Validate significant digit format properties\n\tif ( !isNaN( minimumSignificantDigits * maximumSignificantDigits ) ) {\n\t\tvalidateParameterRange( minimumSignificantDigits, \"minimumSignificantDigits\", 1, 21 );\n\t\tvalidateParameterRange( maximumSignificantDigits, \"maximumSignificantDigits\",\n\t\t\tminimumSignificantDigits, 21 );\n\n\t} else if ( !isNaN( minimumSignificantDigits ) || !isNaN( maximumSignificantDigits ) ) {\n\t\tthrow new Error( \"Neither or both the minimum and maximum significant digits must be \" +\n\t\t\t\"present\" );\n\n\t// Validate integer and fractional format\n\t} else {\n\t\tvalidateParameterRange( minimumIntegerDigits, \"minimumIntegerDigits\", 1, 21 );\n\t\tvalidateParameterRange( minimumFractionDigits, \"minimumFractionDigits\", 0, 20 );\n\t\tvalidateParameterRange( maximumFractionDigits, \"maximumFractionDigits\",\n\t\t\tminimumFractionDigits, 20 );\n\t}\n}\n\n/**\n * .numberFormatter( [options] )\n *\n * @options [Object]:\n * - style: [String] \"decimal\" (default) or \"percent\".\n * - see also number/format options.\n *\n * Return a function that formats a number according to the given options and default/instance\n * locale.\n */\nGlobalize.numberFormatter =\nGlobalize.prototype.numberFormatter = function( options ) {\n\tvar args, cldr, fnArgs, pattern, properties, returnFn;\n\n\tvalidateParameterTypePlainObject( options, \"options\" );\n\n\toptions = options || {};\n\tcldr = this.cldr;\n\n\targs = [ options ];\n\n\tvalidateDefaultLocale( cldr );\n\n\tcldr.on( \"get\", validateCldr );\n\n\tif ( options.raw ) {\n\t\tpattern = options.raw;\n\t} else {\n\t\tpattern = numberPattern( options.style || \"decimal\", cldr );\n\t}\n\n\tproperties = numberFormatProperties( pattern, cldr, options );\n\tfnArgs = [ properties ];\n\n\tcldr.off( \"get\", validateCldr );\n\n\tvalidateDigits( properties );\n\n\tif ( options.compact ) {\n\t\tfnArgs.push( this.pluralGenerator() );\n\t}\n\treturnFn = numberFormatterFn.apply( null, fnArgs );\n\truntimeBind( args, cldr, returnFn, fnArgs );\n\n\treturn returnFn;\n};\n\n/**\n * .numberParser( [options] )\n *\n * @options [Object]:\n * - style: [String] \"decimal\" (default) or \"percent\".\n *\n * Return the number parser according to the default/instance locale.\n */\nGlobalize.numberParser =\nGlobalize.prototype.numberParser = function( options ) {\n\tvar args, cldr, pattern, properties, returnFn;\n\n\tvalidateParameterTypePlainObject( options, \"options\" );\n\n\toptions = options || {};\n\tcldr = this.cldr;\n\n\targs = [ options ];\n\n\tvalidateDefaultLocale( cldr );\n\tif ( options.compact ) {\n\t\tthrow createErrorUnsupportedFeature({\n\t\t\tfeature: \"compact number parsing (not implemented)\"\n\t\t});\n\t}\n\n\tcldr.on( \"get\", validateCldr );\n\n\tif ( options.raw ) {\n\t\tpattern = options.raw;\n\t} else {\n\t\tpattern = numberPattern( options.style || \"decimal\", cldr );\n\t}\n\n\tproperties = numberParseProperties( pattern, cldr, options );\n\n\tcldr.off( \"get\", validateCldr );\n\n\treturnFn = numberParserFn( properties );\n\n\truntimeBind( args, cldr, returnFn, [ properties ] );\n\n\treturn returnFn;\n};\n\n/**\n * .formatNumber( value [, options] )\n *\n * @value [Number] number to be formatted.\n *\n * @options [Object]: see number/format-properties.\n *\n * Format a number according to the given options and default/instance locale.\n */\nGlobalize.formatNumber =\nGlobalize.prototype.formatNumber = function( value, options ) {\n\tvalidateParameterPresence( value, \"value\" );\n\tvalidateParameterTypeNumber( value, \"value\" );\n\n\treturn this.numberFormatter( options )( value );\n};\n\n/**\n * .parseNumber( value [, options] )\n *\n * @value [String]\n *\n * @options [Object]: See numberParser().\n *\n * Return the parsed Number (including Infinity) or NaN when value is invalid.\n */\nGlobalize.parseNumber =\nGlobalize.prototype.parseNumber = function( value, options ) {\n\tvalidateParameterPresence( value, \"value\" );\n\tvalidateParameterTypeString( value, \"value\" );\n\n\treturn this.numberParser( options )( value );\n};\n\n/**\n * Optimization to avoid duplicating some internal functions across modules.\n */\nGlobalize._createErrorUnsupportedFeature = createErrorUnsupportedFeature;\nGlobalize._numberNumberingSystem = numberNumberingSystem;\nGlobalize._numberNumberingSystemDigitsMap = numberNumberingSystemDigitsMap;\nGlobalize._numberPattern = numberPattern;\nGlobalize._numberSymbol = numberSymbol;\nGlobalize._looseMatching = looseMatching;\nGlobalize._removeLiteralQuotes = removeLiteralQuotes;\nGlobalize._stringPad = stringPad;\nGlobalize._validateParameterTypeNumber = validateParameterTypeNumber;\nGlobalize._validateParameterTypeString = validateParameterTypeString;\n\nreturn Globalize;\n\n\n\n\n}));\n"]},"metadata":{},"sourceType":"script"}