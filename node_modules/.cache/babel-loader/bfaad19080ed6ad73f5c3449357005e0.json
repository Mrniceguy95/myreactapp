{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\"use strict\";\n\nclass Hook {\n  constructor(args) {\n    if (!Array.isArray(args)) args = [];\n    this._args = args;\n    this.taps = [];\n    this.interceptors = [];\n    this.call = this._call = this._createCompileDelegate(\"call\", \"sync\");\n    this.promise = this._promise = this._createCompileDelegate(\"promise\", \"promise\");\n    this.callAsync = this._callAsync = this._createCompileDelegate(\"callAsync\", \"async\");\n    this._x = undefined;\n  }\n\n  compile(options) {\n    throw new Error(\"Abstract: should be overriden\");\n  }\n\n  _createCall(type) {\n    return this.compile({\n      taps: this.taps,\n      interceptors: this.interceptors,\n      args: this._args,\n      type: type\n    });\n  }\n\n  _createCompileDelegate(name, type) {\n    const lazyCompileHook = (...args) => {\n      this[name] = this._createCall(type);\n      return this[name](...args);\n    };\n\n    return lazyCompileHook;\n  }\n\n  tap(options, fn) {\n    if (typeof options === \"string\") options = {\n      name: options\n    };\n    if (typeof options !== \"object\" || options === null) throw new Error(\"Invalid arguments to tap(options: Object, fn: function)\");\n    options = Object.assign({\n      type: \"sync\",\n      fn: fn\n    }, options);\n    if (typeof options.name !== \"string\" || options.name === \"\") throw new Error(\"Missing name for tap\");\n    options = this._runRegisterInterceptors(options);\n\n    this._insert(options);\n  }\n\n  tapAsync(options, fn) {\n    if (typeof options === \"string\") options = {\n      name: options\n    };\n    if (typeof options !== \"object\" || options === null) throw new Error(\"Invalid arguments to tapAsync(options: Object, fn: function)\");\n    options = Object.assign({\n      type: \"async\",\n      fn: fn\n    }, options);\n    if (typeof options.name !== \"string\" || options.name === \"\") throw new Error(\"Missing name for tapAsync\");\n    options = this._runRegisterInterceptors(options);\n\n    this._insert(options);\n  }\n\n  tapPromise(options, fn) {\n    if (typeof options === \"string\") options = {\n      name: options\n    };\n    if (typeof options !== \"object\" || options === null) throw new Error(\"Invalid arguments to tapPromise(options: Object, fn: function)\");\n    options = Object.assign({\n      type: \"promise\",\n      fn: fn\n    }, options);\n    if (typeof options.name !== \"string\" || options.name === \"\") throw new Error(\"Missing name for tapPromise\");\n    options = this._runRegisterInterceptors(options);\n\n    this._insert(options);\n  }\n\n  _runRegisterInterceptors(options) {\n    for (const interceptor of this.interceptors) {\n      if (interceptor.register) {\n        const newOptions = interceptor.register(options);\n        if (newOptions !== undefined) options = newOptions;\n      }\n    }\n\n    return options;\n  }\n\n  withOptions(options) {\n    const mergeOptions = opt => Object.assign({}, options, typeof opt === \"string\" ? {\n      name: opt\n    } : opt); // Prevent creating endless prototype chains\n\n\n    options = Object.assign({}, options, this._withOptions);\n    const base = this._withOptionsBase || this;\n    const newHook = Object.create(base);\n    newHook.tapAsync = (opt, fn) => base.tapAsync(mergeOptions(opt), fn), newHook.tap = (opt, fn) => base.tap(mergeOptions(opt), fn);\n\n    newHook.tapPromise = (opt, fn) => base.tapPromise(mergeOptions(opt), fn);\n\n    newHook._withOptions = options;\n    newHook._withOptionsBase = base;\n    return newHook;\n  }\n\n  isUsed() {\n    return this.taps.length > 0 || this.interceptors.length > 0;\n  }\n\n  intercept(interceptor) {\n    this._resetCompilation();\n\n    this.interceptors.push(Object.assign({}, interceptor));\n\n    if (interceptor.register) {\n      for (let i = 0; i < this.taps.length; i++) this.taps[i] = interceptor.register(this.taps[i]);\n    }\n  }\n\n  _resetCompilation() {\n    this.call = this._call;\n    this.callAsync = this._callAsync;\n    this.promise = this._promise;\n  }\n\n  _insert(item) {\n    this._resetCompilation();\n\n    let before;\n    if (typeof item.before === \"string\") before = new Set([item.before]);else if (Array.isArray(item.before)) {\n      before = new Set(item.before);\n    }\n    let stage = 0;\n    if (typeof item.stage === \"number\") stage = item.stage;\n    let i = this.taps.length;\n\n    while (i > 0) {\n      i--;\n      const x = this.taps[i];\n      this.taps[i + 1] = x;\n      const xStage = x.stage || 0;\n\n      if (before) {\n        if (before.has(x.name)) {\n          before.delete(x.name);\n          continue;\n        }\n\n        if (before.size > 0) {\n          continue;\n        }\n      }\n\n      if (xStage > stage) {\n        continue;\n      }\n\n      i++;\n      break;\n    }\n\n    this.taps[i] = item;\n  }\n\n}\n\nmodule.exports = Hook;","map":{"version":3,"sources":["C:/Users/guido/Documents/GitHub/myreactapp/node_modules/globalize-webpack-plugin/node_modules/tapable/lib/Hook.js"],"names":["Hook","constructor","args","Array","isArray","_args","taps","interceptors","call","_call","_createCompileDelegate","promise","_promise","callAsync","_callAsync","_x","undefined","compile","options","Error","_createCall","type","name","lazyCompileHook","tap","fn","Object","assign","_runRegisterInterceptors","_insert","tapAsync","tapPromise","interceptor","register","newOptions","withOptions","mergeOptions","opt","_withOptions","base","_withOptionsBase","newHook","create","isUsed","length","intercept","_resetCompilation","push","i","item","before","Set","stage","x","xStage","has","delete","size","module","exports"],"mappings":"AAAA;;;;AAIA;;AAEA,MAAMA,IAAN,CAAW;AACVC,EAAAA,WAAW,CAACC,IAAD,EAAO;AACjB,QAAG,CAACC,KAAK,CAACC,OAAN,CAAcF,IAAd,CAAJ,EAAyBA,IAAI,GAAG,EAAP;AACzB,SAAKG,KAAL,GAAaH,IAAb;AACA,SAAKI,IAAL,GAAY,EAAZ;AACA,SAAKC,YAAL,GAAoB,EAApB;AACA,SAAKC,IAAL,GAAY,KAAKC,KAAL,GAAa,KAAKC,sBAAL,CAA4B,MAA5B,EAAoC,MAApC,CAAzB;AACA,SAAKC,OAAL,GAAe,KAAKC,QAAL,GAAgB,KAAKF,sBAAL,CAA4B,SAA5B,EAAuC,SAAvC,CAA/B;AACA,SAAKG,SAAL,GAAiB,KAAKC,UAAL,GAAkB,KAAKJ,sBAAL,CAA4B,WAA5B,EAAyC,OAAzC,CAAnC;AACA,SAAKK,EAAL,GAAUC,SAAV;AACA;;AAEDC,EAAAA,OAAO,CAACC,OAAD,EAAU;AAChB,UAAM,IAAIC,KAAJ,CAAU,+BAAV,CAAN;AACA;;AAEDC,EAAAA,WAAW,CAACC,IAAD,EAAO;AACjB,WAAO,KAAKJ,OAAL,CAAa;AACnBX,MAAAA,IAAI,EAAE,KAAKA,IADQ;AAEnBC,MAAAA,YAAY,EAAE,KAAKA,YAFA;AAGnBL,MAAAA,IAAI,EAAE,KAAKG,KAHQ;AAInBgB,MAAAA,IAAI,EAAEA;AAJa,KAAb,CAAP;AAMA;;AAEDX,EAAAA,sBAAsB,CAACY,IAAD,EAAOD,IAAP,EAAa;AAClC,UAAME,eAAe,GAAG,CAAC,GAAGrB,IAAJ,KAAa;AACpC,WAAKoB,IAAL,IAAa,KAAKF,WAAL,CAAiBC,IAAjB,CAAb;AACA,aAAO,KAAKC,IAAL,EAAW,GAAGpB,IAAd,CAAP;AACA,KAHD;;AAIA,WAAOqB,eAAP;AACA;;AAEDC,EAAAA,GAAG,CAACN,OAAD,EAAUO,EAAV,EAAc;AAChB,QAAG,OAAOP,OAAP,KAAmB,QAAtB,EACCA,OAAO,GAAG;AAAEI,MAAAA,IAAI,EAAEJ;AAAR,KAAV;AACD,QAAG,OAAOA,OAAP,KAAmB,QAAnB,IAA+BA,OAAO,KAAK,IAA9C,EACC,MAAM,IAAIC,KAAJ,CAAU,yDAAV,CAAN;AACDD,IAAAA,OAAO,GAAGQ,MAAM,CAACC,MAAP,CAAc;AAAEN,MAAAA,IAAI,EAAE,MAAR;AAAgBI,MAAAA,EAAE,EAAEA;AAApB,KAAd,EAAwCP,OAAxC,CAAV;AACA,QAAG,OAAOA,OAAO,CAACI,IAAf,KAAwB,QAAxB,IAAoCJ,OAAO,CAACI,IAAR,KAAiB,EAAxD,EACC,MAAM,IAAIH,KAAJ,CAAU,sBAAV,CAAN;AACDD,IAAAA,OAAO,GAAG,KAAKU,wBAAL,CAA8BV,OAA9B,CAAV;;AACA,SAAKW,OAAL,CAAaX,OAAb;AACA;;AAEDY,EAAAA,QAAQ,CAACZ,OAAD,EAAUO,EAAV,EAAc;AACrB,QAAG,OAAOP,OAAP,KAAmB,QAAtB,EACCA,OAAO,GAAG;AAAEI,MAAAA,IAAI,EAAEJ;AAAR,KAAV;AACD,QAAG,OAAOA,OAAP,KAAmB,QAAnB,IAA+BA,OAAO,KAAK,IAA9C,EACC,MAAM,IAAIC,KAAJ,CAAU,8DAAV,CAAN;AACDD,IAAAA,OAAO,GAAGQ,MAAM,CAACC,MAAP,CAAc;AAAEN,MAAAA,IAAI,EAAE,OAAR;AAAiBI,MAAAA,EAAE,EAAEA;AAArB,KAAd,EAAyCP,OAAzC,CAAV;AACA,QAAG,OAAOA,OAAO,CAACI,IAAf,KAAwB,QAAxB,IAAoCJ,OAAO,CAACI,IAAR,KAAiB,EAAxD,EACC,MAAM,IAAIH,KAAJ,CAAU,2BAAV,CAAN;AACDD,IAAAA,OAAO,GAAG,KAAKU,wBAAL,CAA8BV,OAA9B,CAAV;;AACA,SAAKW,OAAL,CAAaX,OAAb;AACA;;AAEDa,EAAAA,UAAU,CAACb,OAAD,EAAUO,EAAV,EAAc;AACvB,QAAG,OAAOP,OAAP,KAAmB,QAAtB,EACCA,OAAO,GAAG;AAAEI,MAAAA,IAAI,EAAEJ;AAAR,KAAV;AACD,QAAG,OAAOA,OAAP,KAAmB,QAAnB,IAA+BA,OAAO,KAAK,IAA9C,EACC,MAAM,IAAIC,KAAJ,CAAU,gEAAV,CAAN;AACDD,IAAAA,OAAO,GAAGQ,MAAM,CAACC,MAAP,CAAc;AAAEN,MAAAA,IAAI,EAAE,SAAR;AAAmBI,MAAAA,EAAE,EAAEA;AAAvB,KAAd,EAA2CP,OAA3C,CAAV;AACA,QAAG,OAAOA,OAAO,CAACI,IAAf,KAAwB,QAAxB,IAAoCJ,OAAO,CAACI,IAAR,KAAiB,EAAxD,EACC,MAAM,IAAIH,KAAJ,CAAU,6BAAV,CAAN;AACDD,IAAAA,OAAO,GAAG,KAAKU,wBAAL,CAA8BV,OAA9B,CAAV;;AACA,SAAKW,OAAL,CAAaX,OAAb;AACA;;AAEDU,EAAAA,wBAAwB,CAACV,OAAD,EAAU;AACjC,SAAI,MAAMc,WAAV,IAAyB,KAAKzB,YAA9B,EAA4C;AAC3C,UAAGyB,WAAW,CAACC,QAAf,EAAyB;AACxB,cAAMC,UAAU,GAAGF,WAAW,CAACC,QAAZ,CAAqBf,OAArB,CAAnB;AACA,YAAGgB,UAAU,KAAKlB,SAAlB,EACCE,OAAO,GAAGgB,UAAV;AACD;AACD;;AACD,WAAOhB,OAAP;AACA;;AAEDiB,EAAAA,WAAW,CAACjB,OAAD,EAAU;AACpB,UAAMkB,YAAY,GAAGC,GAAG,IAAIX,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBT,OAAlB,EAA2B,OAAOmB,GAAP,KAAe,QAAf,GAA0B;AAAEf,MAAAA,IAAI,EAAEe;AAAR,KAA1B,GAA0CA,GAArE,CAA5B,CADoB,CAGpB;;;AACAnB,IAAAA,OAAO,GAAGQ,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBT,OAAlB,EAA2B,KAAKoB,YAAhC,CAAV;AACA,UAAMC,IAAI,GAAG,KAAKC,gBAAL,IAAyB,IAAtC;AACA,UAAMC,OAAO,GAAGf,MAAM,CAACgB,MAAP,CAAcH,IAAd,CAAhB;AAEAE,IAAAA,OAAO,CAACX,QAAR,GAAmB,CAACO,GAAD,EAAMZ,EAAN,KAAac,IAAI,CAACT,QAAL,CAAcM,YAAY,CAACC,GAAD,CAA1B,EAAiCZ,EAAjC,CAAhC,EACAgB,OAAO,CAACjB,GAAR,GAAc,CAACa,GAAD,EAAMZ,EAAN,KAAac,IAAI,CAACf,GAAL,CAASY,YAAY,CAACC,GAAD,CAArB,EAA4BZ,EAA5B,CAD3B;;AAEAgB,IAAAA,OAAO,CAACV,UAAR,GAAqB,CAACM,GAAD,EAAMZ,EAAN,KAAac,IAAI,CAACR,UAAL,CAAgBK,YAAY,CAACC,GAAD,CAA5B,EAAmCZ,EAAnC,CAAlC;;AACAgB,IAAAA,OAAO,CAACH,YAAR,GAAuBpB,OAAvB;AACAuB,IAAAA,OAAO,CAACD,gBAAR,GAA2BD,IAA3B;AACA,WAAOE,OAAP;AACA;;AAEDE,EAAAA,MAAM,GAAG;AACR,WAAO,KAAKrC,IAAL,CAAUsC,MAAV,GAAmB,CAAnB,IAAwB,KAAKrC,YAAL,CAAkBqC,MAAlB,GAA2B,CAA1D;AACA;;AAEDC,EAAAA,SAAS,CAACb,WAAD,EAAc;AACtB,SAAKc,iBAAL;;AACA,SAAKvC,YAAL,CAAkBwC,IAAlB,CAAuBrB,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBK,WAAlB,CAAvB;;AACA,QAAGA,WAAW,CAACC,QAAf,EAAyB;AACxB,WAAI,IAAIe,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAG,KAAK1C,IAAL,CAAUsC,MAA7B,EAAqCI,CAAC,EAAtC,EACC,KAAK1C,IAAL,CAAU0C,CAAV,IAAehB,WAAW,CAACC,QAAZ,CAAqB,KAAK3B,IAAL,CAAU0C,CAAV,CAArB,CAAf;AACD;AACD;;AAEDF,EAAAA,iBAAiB,GAAG;AACnB,SAAKtC,IAAL,GAAY,KAAKC,KAAjB;AACA,SAAKI,SAAL,GAAiB,KAAKC,UAAtB;AACA,SAAKH,OAAL,GAAe,KAAKC,QAApB;AACA;;AAEDiB,EAAAA,OAAO,CAACoB,IAAD,EAAO;AACb,SAAKH,iBAAL;;AACA,QAAII,MAAJ;AACA,QAAG,OAAOD,IAAI,CAACC,MAAZ,KAAuB,QAA1B,EACCA,MAAM,GAAG,IAAIC,GAAJ,CAAQ,CAACF,IAAI,CAACC,MAAN,CAAR,CAAT,CADD,KAEK,IAAG/C,KAAK,CAACC,OAAN,CAAc6C,IAAI,CAACC,MAAnB,CAAH,EAA+B;AACnCA,MAAAA,MAAM,GAAG,IAAIC,GAAJ,CAAQF,IAAI,CAACC,MAAb,CAAT;AACA;AACD,QAAIE,KAAK,GAAG,CAAZ;AACA,QAAG,OAAOH,IAAI,CAACG,KAAZ,KAAsB,QAAzB,EACCA,KAAK,GAAGH,IAAI,CAACG,KAAb;AACD,QAAIJ,CAAC,GAAG,KAAK1C,IAAL,CAAUsC,MAAlB;;AACA,WAAMI,CAAC,GAAG,CAAV,EAAa;AACZA,MAAAA,CAAC;AACD,YAAMK,CAAC,GAAG,KAAK/C,IAAL,CAAU0C,CAAV,CAAV;AACA,WAAK1C,IAAL,CAAU0C,CAAC,GAAC,CAAZ,IAAiBK,CAAjB;AACA,YAAMC,MAAM,GAAGD,CAAC,CAACD,KAAF,IAAW,CAA1B;;AACA,UAAGF,MAAH,EAAW;AACV,YAAGA,MAAM,CAACK,GAAP,CAAWF,CAAC,CAAC/B,IAAb,CAAH,EAAuB;AACtB4B,UAAAA,MAAM,CAACM,MAAP,CAAcH,CAAC,CAAC/B,IAAhB;AACA;AACA;;AACD,YAAG4B,MAAM,CAACO,IAAP,GAAc,CAAjB,EAAoB;AACnB;AACA;AACD;;AACD,UAAGH,MAAM,GAAGF,KAAZ,EAAmB;AAClB;AACA;;AACDJ,MAAAA,CAAC;AACD;AACA;;AACD,SAAK1C,IAAL,CAAU0C,CAAV,IAAeC,IAAf;AACA;;AApJS;;AAuJXS,MAAM,CAACC,OAAP,GAAiB3D,IAAjB","sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\"use strict\";\r\n\r\nclass Hook {\r\n\tconstructor(args) {\r\n\t\tif(!Array.isArray(args)) args = [];\r\n\t\tthis._args = args;\r\n\t\tthis.taps = [];\r\n\t\tthis.interceptors = [];\r\n\t\tthis.call = this._call = this._createCompileDelegate(\"call\", \"sync\");\r\n\t\tthis.promise = this._promise = this._createCompileDelegate(\"promise\", \"promise\");\r\n\t\tthis.callAsync = this._callAsync = this._createCompileDelegate(\"callAsync\", \"async\");\r\n\t\tthis._x = undefined;\r\n\t}\r\n\r\n\tcompile(options) {\r\n\t\tthrow new Error(\"Abstract: should be overriden\");\r\n\t}\r\n\r\n\t_createCall(type) {\r\n\t\treturn this.compile({\r\n\t\t\ttaps: this.taps,\r\n\t\t\tinterceptors: this.interceptors,\r\n\t\t\targs: this._args,\r\n\t\t\ttype: type\r\n\t\t});\r\n\t}\r\n\r\n\t_createCompileDelegate(name, type) {\r\n\t\tconst lazyCompileHook = (...args) => {\r\n\t\t\tthis[name] = this._createCall(type);\r\n\t\t\treturn this[name](...args);\r\n\t\t};\r\n\t\treturn lazyCompileHook;\r\n\t}\r\n\r\n\ttap(options, fn) {\r\n\t\tif(typeof options === \"string\")\r\n\t\t\toptions = { name: options };\r\n\t\tif(typeof options !== \"object\" || options === null)\r\n\t\t\tthrow new Error(\"Invalid arguments to tap(options: Object, fn: function)\");\r\n\t\toptions = Object.assign({ type: \"sync\", fn: fn }, options);\r\n\t\tif(typeof options.name !== \"string\" || options.name === \"\")\r\n\t\t\tthrow new Error(\"Missing name for tap\");\r\n\t\toptions = this._runRegisterInterceptors(options);\r\n\t\tthis._insert(options);\r\n\t}\r\n\r\n\ttapAsync(options, fn) {\r\n\t\tif(typeof options === \"string\")\r\n\t\t\toptions = { name: options };\r\n\t\tif(typeof options !== \"object\" || options === null)\r\n\t\t\tthrow new Error(\"Invalid arguments to tapAsync(options: Object, fn: function)\");\r\n\t\toptions = Object.assign({ type: \"async\", fn: fn }, options);\r\n\t\tif(typeof options.name !== \"string\" || options.name === \"\")\r\n\t\t\tthrow new Error(\"Missing name for tapAsync\");\r\n\t\toptions = this._runRegisterInterceptors(options);\r\n\t\tthis._insert(options);\r\n\t}\r\n\r\n\ttapPromise(options, fn) {\r\n\t\tif(typeof options === \"string\")\r\n\t\t\toptions = { name: options };\r\n\t\tif(typeof options !== \"object\" || options === null)\r\n\t\t\tthrow new Error(\"Invalid arguments to tapPromise(options: Object, fn: function)\");\r\n\t\toptions = Object.assign({ type: \"promise\", fn: fn }, options);\r\n\t\tif(typeof options.name !== \"string\" || options.name === \"\")\r\n\t\t\tthrow new Error(\"Missing name for tapPromise\");\r\n\t\toptions = this._runRegisterInterceptors(options);\r\n\t\tthis._insert(options);\r\n\t}\r\n\r\n\t_runRegisterInterceptors(options) {\r\n\t\tfor(const interceptor of this.interceptors) {\r\n\t\t\tif(interceptor.register) {\r\n\t\t\t\tconst newOptions = interceptor.register(options);\r\n\t\t\t\tif(newOptions !== undefined)\r\n\t\t\t\t\toptions = newOptions;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn options;\r\n\t}\r\n\r\n\twithOptions(options) {\r\n\t\tconst mergeOptions = opt => Object.assign({}, options, typeof opt === \"string\" ? { name: opt } : opt);\r\n\r\n\t\t// Prevent creating endless prototype chains\r\n\t\toptions = Object.assign({}, options, this._withOptions);\r\n\t\tconst base = this._withOptionsBase || this;\r\n\t\tconst newHook = Object.create(base);\r\n\r\n\t\tnewHook.tapAsync = (opt, fn) => base.tapAsync(mergeOptions(opt), fn),\r\n\t\tnewHook.tap = (opt, fn) => base.tap(mergeOptions(opt), fn);\r\n\t\tnewHook.tapPromise = (opt, fn) => base.tapPromise(mergeOptions(opt), fn);\r\n\t\tnewHook._withOptions = options;\r\n\t\tnewHook._withOptionsBase = base;\r\n\t\treturn newHook;\r\n\t}\r\n\r\n\tisUsed() {\r\n\t\treturn this.taps.length > 0 || this.interceptors.length > 0;\r\n\t}\r\n\r\n\tintercept(interceptor) {\r\n\t\tthis._resetCompilation();\r\n\t\tthis.interceptors.push(Object.assign({}, interceptor));\r\n\t\tif(interceptor.register) {\r\n\t\t\tfor(let i = 0; i < this.taps.length; i++)\r\n\t\t\t\tthis.taps[i] = interceptor.register(this.taps[i]);\r\n\t\t}\r\n\t}\r\n\r\n\t_resetCompilation() {\r\n\t\tthis.call = this._call;\r\n\t\tthis.callAsync = this._callAsync;\r\n\t\tthis.promise = this._promise;\r\n\t}\r\n\r\n\t_insert(item) {\r\n\t\tthis._resetCompilation();\r\n\t\tlet before;\r\n\t\tif(typeof item.before === \"string\")\r\n\t\t\tbefore = new Set([item.before]);\r\n\t\telse if(Array.isArray(item.before)) {\r\n\t\t\tbefore = new Set(item.before);\r\n\t\t}\r\n\t\tlet stage = 0;\r\n\t\tif(typeof item.stage === \"number\")\r\n\t\t\tstage = item.stage;\r\n\t\tlet i = this.taps.length;\r\n\t\twhile(i > 0) {\r\n\t\t\ti--;\r\n\t\t\tconst x = this.taps[i];\r\n\t\t\tthis.taps[i+1] = x;\r\n\t\t\tconst xStage = x.stage || 0;\r\n\t\t\tif(before) {\r\n\t\t\t\tif(before.has(x.name)) {\r\n\t\t\t\t\tbefore.delete(x.name);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif(before.size > 0) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(xStage > stage) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\ti++;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tthis.taps[i] = item;\r\n\t}\r\n}\r\n\r\nmodule.exports = Hook;\r\n"]},"metadata":{},"sourceType":"script"}