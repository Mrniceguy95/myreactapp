{"ast":null,"code":"/*\n  Copyright (c) jQuery Foundation, Inc. and Contributors, All Rights Reserved.\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n(function (root, factory) {\n  'use strict'; // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n  // Rhino, and plain browser loading.\n\n  /* istanbul ignore next */\n\n  if (typeof define === 'function' && define.amd) {\n    define(['exports'], factory);\n  } else if (typeof exports !== 'undefined') {\n    factory(exports);\n  } else {\n    factory(root.esprima = {});\n  }\n})(this, function (exports) {\n  'use strict';\n\n  var Token, TokenName, FnExprTokens, Syntax, PlaceHolders, Messages, Regex, source, strict, index, lineNumber, lineStart, hasLineTerminator, lastIndex, lastLineNumber, lastLineStart, startIndex, startLineNumber, startLineStart, scanning, length, lookahead, state, extra, isBindingElement, isAssignmentTarget, firstCoverInitializedNameError;\n  Token = {\n    BooleanLiteral: 1,\n    EOF: 2,\n    Identifier: 3,\n    Keyword: 4,\n    NullLiteral: 5,\n    NumericLiteral: 6,\n    Punctuator: 7,\n    StringLiteral: 8,\n    RegularExpression: 9,\n    Template: 10\n  };\n  TokenName = {};\n  TokenName[Token.BooleanLiteral] = 'Boolean';\n  TokenName[Token.EOF] = '<end>';\n  TokenName[Token.Identifier] = 'Identifier';\n  TokenName[Token.Keyword] = 'Keyword';\n  TokenName[Token.NullLiteral] = 'Null';\n  TokenName[Token.NumericLiteral] = 'Numeric';\n  TokenName[Token.Punctuator] = 'Punctuator';\n  TokenName[Token.StringLiteral] = 'String';\n  TokenName[Token.RegularExpression] = 'RegularExpression';\n  TokenName[Token.Template] = 'Template'; // A function following one of those tokens is an expression.\n\n  FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new', 'return', 'case', 'delete', 'throw', 'void', // assignment operators\n  '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=', '&=', '|=', '^=', ',', // binary/unary operators\n  '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&', '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=', '<=', '<', '>', '!=', '!=='];\n  Syntax = {\n    AssignmentExpression: 'AssignmentExpression',\n    AssignmentPattern: 'AssignmentPattern',\n    ArrayExpression: 'ArrayExpression',\n    ArrayPattern: 'ArrayPattern',\n    ArrowFunctionExpression: 'ArrowFunctionExpression',\n    BlockStatement: 'BlockStatement',\n    BinaryExpression: 'BinaryExpression',\n    BreakStatement: 'BreakStatement',\n    CallExpression: 'CallExpression',\n    CatchClause: 'CatchClause',\n    ClassBody: 'ClassBody',\n    ClassDeclaration: 'ClassDeclaration',\n    ClassExpression: 'ClassExpression',\n    ConditionalExpression: 'ConditionalExpression',\n    ContinueStatement: 'ContinueStatement',\n    DoWhileStatement: 'DoWhileStatement',\n    DebuggerStatement: 'DebuggerStatement',\n    EmptyStatement: 'EmptyStatement',\n    ExportAllDeclaration: 'ExportAllDeclaration',\n    ExportDefaultDeclaration: 'ExportDefaultDeclaration',\n    ExportNamedDeclaration: 'ExportNamedDeclaration',\n    ExportSpecifier: 'ExportSpecifier',\n    ExpressionStatement: 'ExpressionStatement',\n    ForStatement: 'ForStatement',\n    ForOfStatement: 'ForOfStatement',\n    ForInStatement: 'ForInStatement',\n    FunctionDeclaration: 'FunctionDeclaration',\n    FunctionExpression: 'FunctionExpression',\n    Identifier: 'Identifier',\n    IfStatement: 'IfStatement',\n    ImportDeclaration: 'ImportDeclaration',\n    ImportDefaultSpecifier: 'ImportDefaultSpecifier',\n    ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',\n    ImportSpecifier: 'ImportSpecifier',\n    Literal: 'Literal',\n    LabeledStatement: 'LabeledStatement',\n    LogicalExpression: 'LogicalExpression',\n    MemberExpression: 'MemberExpression',\n    MetaProperty: 'MetaProperty',\n    MethodDefinition: 'MethodDefinition',\n    NewExpression: 'NewExpression',\n    ObjectExpression: 'ObjectExpression',\n    ObjectPattern: 'ObjectPattern',\n    Program: 'Program',\n    Property: 'Property',\n    RestElement: 'RestElement',\n    ReturnStatement: 'ReturnStatement',\n    SequenceExpression: 'SequenceExpression',\n    SpreadElement: 'SpreadElement',\n    Super: 'Super',\n    SwitchCase: 'SwitchCase',\n    SwitchStatement: 'SwitchStatement',\n    TaggedTemplateExpression: 'TaggedTemplateExpression',\n    TemplateElement: 'TemplateElement',\n    TemplateLiteral: 'TemplateLiteral',\n    ThisExpression: 'ThisExpression',\n    ThrowStatement: 'ThrowStatement',\n    TryStatement: 'TryStatement',\n    UnaryExpression: 'UnaryExpression',\n    UpdateExpression: 'UpdateExpression',\n    VariableDeclaration: 'VariableDeclaration',\n    VariableDeclarator: 'VariableDeclarator',\n    WhileStatement: 'WhileStatement',\n    WithStatement: 'WithStatement',\n    YieldExpression: 'YieldExpression'\n  };\n  PlaceHolders = {\n    ArrowParameterPlaceHolder: 'ArrowParameterPlaceHolder'\n  }; // Error messages should be identical to V8.\n\n  Messages = {\n    UnexpectedToken: 'Unexpected token %0',\n    UnexpectedNumber: 'Unexpected number',\n    UnexpectedString: 'Unexpected string',\n    UnexpectedIdentifier: 'Unexpected identifier',\n    UnexpectedReserved: 'Unexpected reserved word',\n    UnexpectedTemplate: 'Unexpected quasi %0',\n    UnexpectedEOS: 'Unexpected end of input',\n    NewlineAfterThrow: 'Illegal newline after throw',\n    InvalidRegExp: 'Invalid regular expression',\n    UnterminatedRegExp: 'Invalid regular expression: missing /',\n    InvalidLHSInAssignment: 'Invalid left-hand side in assignment',\n    InvalidLHSInForIn: 'Invalid left-hand side in for-in',\n    InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',\n    MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n    NoCatchOrFinally: 'Missing catch or finally after try',\n    UnknownLabel: 'Undefined label \\'%0\\'',\n    Redeclaration: '%0 \\'%1\\' has already been declared',\n    IllegalContinue: 'Illegal continue statement',\n    IllegalBreak: 'Illegal break statement',\n    IllegalReturn: 'Illegal return statement',\n    StrictModeWith: 'Strict mode code may not include a with statement',\n    StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',\n    StrictVarName: 'Variable name may not be eval or arguments in strict mode',\n    StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',\n    StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n    StrictFunctionName: 'Function name may not be eval or arguments in strict mode',\n    StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',\n    StrictDelete: 'Delete of an unqualified identifier in strict mode.',\n    StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',\n    StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n    StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n    StrictReservedWord: 'Use of future reserved word in strict mode',\n    TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',\n    ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',\n    DefaultRestParameter: 'Unexpected token =',\n    ObjectPatternAsRestParameter: 'Unexpected token {',\n    DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',\n    ConstructorSpecialMethod: 'Class constructor may not be an accessor',\n    DuplicateConstructor: 'A class may only have one constructor',\n    StaticPrototype: 'Classes may not have static property named prototype',\n    MissingFromClause: 'Unexpected token',\n    NoAsAfterImportNamespace: 'Unexpected token',\n    InvalidModuleSpecifier: 'Unexpected token',\n    IllegalImportDeclaration: 'Unexpected token',\n    IllegalExportDeclaration: 'Unexpected token',\n    DuplicateBinding: 'Duplicate binding %0'\n  }; // See also tools/generate-unicode-regex.js.\n\n  Regex = {\n    // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierStart:\n    NonAsciiIdentifierStart: /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF5D-\\uDF61]|\\uD805[\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA]|\\uD806[\\uDCA0-\\uDCDF\\uDCFF\\uDEC0-\\uDEF8]|\\uD808[\\uDC00-\\uDF98]|\\uD809[\\uDC00-\\uDC6E]|[\\uD80C\\uD840-\\uD868\\uD86A-\\uD86C][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50\\uDF93-\\uDF9F]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD83A[\\uDC00-\\uDCC4]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D]|\\uD87E[\\uDC00-\\uDE1D]/,\n    // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierPart:\n    NonAsciiIdentifierPart: /[\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC6F\\uDC7F-\\uDCBA\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDD0-\\uDDDA\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF01-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3C-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB7\\uDEC0-\\uDEC9]|\\uD806[\\uDCA0-\\uDCE9\\uDCFF\\uDEC0-\\uDEF8]|\\uD808[\\uDC00-\\uDF98]|\\uD809[\\uDC00-\\uDC6E]|[\\uD80C\\uD840-\\uD868\\uD86A-\\uD86C][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50-\\uDF7E\\uDF8F-\\uDF9F]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D]|\\uD87E[\\uDC00-\\uDE1D]|\\uDB40[\\uDD00-\\uDDEF]/\n  }; // Ensure the condition is true, otherwise throw an error.\n  // This is only to have a better contract semantic, i.e. another safety net\n  // to catch a logic error. The condition shall be fulfilled in normal case.\n  // Do NOT use this to enforce a certain condition on any user input.\n\n  function assert(condition, message) {\n    /* istanbul ignore if */\n    if (!condition) {\n      throw new Error('ASSERT: ' + message);\n    }\n  }\n\n  function isDecimalDigit(ch) {\n    return ch >= 0x30 && ch <= 0x39; // 0..9\n  }\n\n  function isHexDigit(ch) {\n    return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n  }\n\n  function isOctalDigit(ch) {\n    return '01234567'.indexOf(ch) >= 0;\n  }\n\n  function octalToDecimal(ch) {\n    // \\0 is not octal escape sequence\n    var octal = ch !== '0',\n        code = '01234567'.indexOf(ch);\n\n    if (index < length && isOctalDigit(source[index])) {\n      octal = true;\n      code = code * 8 + '01234567'.indexOf(source[index++]); // 3 digits are only allowed when string starts\n      // with 0, 1, 2, 3\n\n      if ('0123'.indexOf(ch) >= 0 && index < length && isOctalDigit(source[index])) {\n        code = code * 8 + '01234567'.indexOf(source[index++]);\n      }\n    }\n\n    return {\n      code: code,\n      octal: octal\n    };\n  } // ECMA-262 11.2 White Space\n\n\n  function isWhiteSpace(ch) {\n    return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 || ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0;\n  } // ECMA-262 11.3 Line Terminators\n\n\n  function isLineTerminator(ch) {\n    return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;\n  } // ECMA-262 11.6 Identifier Names and Identifiers\n\n\n  function fromCodePoint(cp) {\n    return cp < 0x10000 ? String.fromCharCode(cp) : String.fromCharCode(0xD800 + (cp - 0x10000 >> 10)) + String.fromCharCode(0xDC00 + (cp - 0x10000 & 1023));\n  }\n\n  function isIdentifierStart(ch) {\n    return ch === 0x24 || ch === 0x5F || // $ (dollar) and _ (underscore)\n    ch >= 0x41 && ch <= 0x5A || // A..Z\n    ch >= 0x61 && ch <= 0x7A || // a..z\n    ch === 0x5C || // \\ (backslash)\n    ch >= 0x80 && Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));\n  }\n\n  function isIdentifierPart(ch) {\n    return ch === 0x24 || ch === 0x5F || // $ (dollar) and _ (underscore)\n    ch >= 0x41 && ch <= 0x5A || // A..Z\n    ch >= 0x61 && ch <= 0x7A || // a..z\n    ch >= 0x30 && ch <= 0x39 || // 0..9\n    ch === 0x5C || // \\ (backslash)\n    ch >= 0x80 && Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));\n  } // ECMA-262 11.6.2.2 Future Reserved Words\n\n\n  function isFutureReservedWord(id) {\n    switch (id) {\n      case 'enum':\n      case 'export':\n      case 'import':\n      case 'super':\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  function isStrictModeReservedWord(id) {\n    switch (id) {\n      case 'implements':\n      case 'interface':\n      case 'package':\n      case 'private':\n      case 'protected':\n      case 'public':\n      case 'static':\n      case 'yield':\n      case 'let':\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  function isRestrictedWord(id) {\n    return id === 'eval' || id === 'arguments';\n  } // ECMA-262 11.6.2.1 Keywords\n\n\n  function isKeyword(id) {\n    switch (id.length) {\n      case 2:\n        return id === 'if' || id === 'in' || id === 'do';\n\n      case 3:\n        return id === 'var' || id === 'for' || id === 'new' || id === 'try' || id === 'let';\n\n      case 4:\n        return id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum';\n\n      case 5:\n        return id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'yield' || id === 'class' || id === 'super';\n\n      case 6:\n        return id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import';\n\n      case 7:\n        return id === 'default' || id === 'finally' || id === 'extends';\n\n      case 8:\n        return id === 'function' || id === 'continue' || id === 'debugger';\n\n      case 10:\n        return id === 'instanceof';\n\n      default:\n        return false;\n    }\n  } // ECMA-262 11.4 Comments\n\n\n  function addComment(type, value, start, end, loc) {\n    var comment;\n    assert(typeof start === 'number', 'Comment must have valid position');\n    state.lastCommentStart = start;\n    comment = {\n      type: type,\n      value: value\n    };\n\n    if (extra.range) {\n      comment.range = [start, end];\n    }\n\n    if (extra.loc) {\n      comment.loc = loc;\n    }\n\n    extra.comments.push(comment);\n\n    if (extra.attachComment) {\n      extra.leadingComments.push(comment);\n      extra.trailingComments.push(comment);\n    }\n\n    if (extra.tokenize) {\n      comment.type = comment.type + 'Comment';\n\n      if (extra.delegate) {\n        comment = extra.delegate(comment);\n      }\n\n      extra.tokens.push(comment);\n    }\n  }\n\n  function skipSingleLineComment(offset) {\n    var start, loc, ch, comment;\n    start = index - offset;\n    loc = {\n      start: {\n        line: lineNumber,\n        column: index - lineStart - offset\n      }\n    };\n\n    while (index < length) {\n      ch = source.charCodeAt(index);\n      ++index;\n\n      if (isLineTerminator(ch)) {\n        hasLineTerminator = true;\n\n        if (extra.comments) {\n          comment = source.slice(start + offset, index - 1);\n          loc.end = {\n            line: lineNumber,\n            column: index - lineStart - 1\n          };\n          addComment('Line', comment, start, index - 1, loc);\n        }\n\n        if (ch === 13 && source.charCodeAt(index) === 10) {\n          ++index;\n        }\n\n        ++lineNumber;\n        lineStart = index;\n        return;\n      }\n    }\n\n    if (extra.comments) {\n      comment = source.slice(start + offset, index);\n      loc.end = {\n        line: lineNumber,\n        column: index - lineStart\n      };\n      addComment('Line', comment, start, index, loc);\n    }\n  }\n\n  function skipMultiLineComment() {\n    var start, loc, ch, comment;\n\n    if (extra.comments) {\n      start = index - 2;\n      loc = {\n        start: {\n          line: lineNumber,\n          column: index - lineStart - 2\n        }\n      };\n    }\n\n    while (index < length) {\n      ch = source.charCodeAt(index);\n\n      if (isLineTerminator(ch)) {\n        if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {\n          ++index;\n        }\n\n        hasLineTerminator = true;\n        ++lineNumber;\n        ++index;\n        lineStart = index;\n      } else if (ch === 0x2A) {\n        // Block comment ends with '*/'.\n        if (source.charCodeAt(index + 1) === 0x2F) {\n          ++index;\n          ++index;\n\n          if (extra.comments) {\n            comment = source.slice(start + 2, index - 2);\n            loc.end = {\n              line: lineNumber,\n              column: index - lineStart\n            };\n            addComment('Block', comment, start, index, loc);\n          }\n\n          return;\n        }\n\n        ++index;\n      } else {\n        ++index;\n      }\n    } // Ran off the end of the file - the whole thing is a comment\n\n\n    if (extra.comments) {\n      loc.end = {\n        line: lineNumber,\n        column: index - lineStart\n      };\n      comment = source.slice(start + 2, index);\n      addComment('Block', comment, start, index, loc);\n    }\n\n    tolerateUnexpectedToken();\n  }\n\n  function skipComment() {\n    var ch, start;\n    hasLineTerminator = false;\n    start = index === 0;\n\n    while (index < length) {\n      ch = source.charCodeAt(index);\n\n      if (isWhiteSpace(ch)) {\n        ++index;\n      } else if (isLineTerminator(ch)) {\n        hasLineTerminator = true;\n        ++index;\n\n        if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {\n          ++index;\n        }\n\n        ++lineNumber;\n        lineStart = index;\n        start = true;\n      } else if (ch === 0x2F) {\n        // U+002F is '/'\n        ch = source.charCodeAt(index + 1);\n\n        if (ch === 0x2F) {\n          ++index;\n          ++index;\n          skipSingleLineComment(2);\n          start = true;\n        } else if (ch === 0x2A) {\n          // U+002A is '*'\n          ++index;\n          ++index;\n          skipMultiLineComment();\n        } else {\n          break;\n        }\n      } else if (start && ch === 0x2D) {\n        // U+002D is '-'\n        // U+003E is '>'\n        if (source.charCodeAt(index + 1) === 0x2D && source.charCodeAt(index + 2) === 0x3E) {\n          // '-->' is a single-line comment\n          index += 3;\n          skipSingleLineComment(3);\n        } else {\n          break;\n        }\n      } else if (ch === 0x3C) {\n        // U+003C is '<'\n        if (source.slice(index + 1, index + 4) === '!--') {\n          ++index; // `<`\n\n          ++index; // `!`\n\n          ++index; // `-`\n\n          ++index; // `-`\n\n          skipSingleLineComment(4);\n        } else {\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n  }\n\n  function scanHexEscape(prefix) {\n    var i,\n        len,\n        ch,\n        code = 0;\n    len = prefix === 'u' ? 4 : 2;\n\n    for (i = 0; i < len; ++i) {\n      if (index < length && isHexDigit(source[index])) {\n        ch = source[index++];\n        code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n      } else {\n        return '';\n      }\n    }\n\n    return String.fromCharCode(code);\n  }\n\n  function scanUnicodeCodePointEscape() {\n    var ch, code;\n    ch = source[index];\n    code = 0; // At least, one hex digit is required.\n\n    if (ch === '}') {\n      throwUnexpectedToken();\n    }\n\n    while (index < length) {\n      ch = source[index++];\n\n      if (!isHexDigit(ch)) {\n        break;\n      }\n\n      code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n    }\n\n    if (code > 0x10FFFF || ch !== '}') {\n      throwUnexpectedToken();\n    }\n\n    return fromCodePoint(code);\n  }\n\n  function codePointAt(i) {\n    var cp, first, second;\n    cp = source.charCodeAt(i);\n\n    if (cp >= 0xD800 && cp <= 0xDBFF) {\n      second = source.charCodeAt(i + 1);\n\n      if (second >= 0xDC00 && second <= 0xDFFF) {\n        first = cp;\n        cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n      }\n    }\n\n    return cp;\n  }\n\n  function getComplexIdentifier() {\n    var cp, ch, id;\n    cp = codePointAt(index);\n    id = fromCodePoint(cp);\n    index += id.length; // '\\u' (U+005C, U+0075) denotes an escaped character.\n\n    if (cp === 0x5C) {\n      if (source.charCodeAt(index) !== 0x75) {\n        throwUnexpectedToken();\n      }\n\n      ++index;\n\n      if (source[index] === '{') {\n        ++index;\n        ch = scanUnicodeCodePointEscape();\n      } else {\n        ch = scanHexEscape('u');\n        cp = ch.charCodeAt(0);\n\n        if (!ch || ch === '\\\\' || !isIdentifierStart(cp)) {\n          throwUnexpectedToken();\n        }\n      }\n\n      id = ch;\n    }\n\n    while (index < length) {\n      cp = codePointAt(index);\n\n      if (!isIdentifierPart(cp)) {\n        break;\n      }\n\n      ch = fromCodePoint(cp);\n      id += ch;\n      index += ch.length; // '\\u' (U+005C, U+0075) denotes an escaped character.\n\n      if (cp === 0x5C) {\n        id = id.substr(0, id.length - 1);\n\n        if (source.charCodeAt(index) !== 0x75) {\n          throwUnexpectedToken();\n        }\n\n        ++index;\n\n        if (source[index] === '{') {\n          ++index;\n          ch = scanUnicodeCodePointEscape();\n        } else {\n          ch = scanHexEscape('u');\n          cp = ch.charCodeAt(0);\n\n          if (!ch || ch === '\\\\' || !isIdentifierPart(cp)) {\n            throwUnexpectedToken();\n          }\n        }\n\n        id += ch;\n      }\n    }\n\n    return id;\n  }\n\n  function getIdentifier() {\n    var start, ch;\n    start = index++;\n\n    while (index < length) {\n      ch = source.charCodeAt(index);\n\n      if (ch === 0x5C) {\n        // Blackslash (U+005C) marks Unicode escape sequence.\n        index = start;\n        return getComplexIdentifier();\n      } else if (ch >= 0xD800 && ch < 0xDFFF) {\n        // Need to handle surrogate pairs.\n        index = start;\n        return getComplexIdentifier();\n      }\n\n      if (isIdentifierPart(ch)) {\n        ++index;\n      } else {\n        break;\n      }\n    }\n\n    return source.slice(start, index);\n  }\n\n  function scanIdentifier() {\n    var start, id, type;\n    start = index; // Backslash (U+005C) starts an escaped character.\n\n    id = source.charCodeAt(index) === 0x5C ? getComplexIdentifier() : getIdentifier(); // There is no keyword or literal with only one character.\n    // Thus, it must be an identifier.\n\n    if (id.length === 1) {\n      type = Token.Identifier;\n    } else if (isKeyword(id)) {\n      type = Token.Keyword;\n    } else if (id === 'null') {\n      type = Token.NullLiteral;\n    } else if (id === 'true' || id === 'false') {\n      type = Token.BooleanLiteral;\n    } else {\n      type = Token.Identifier;\n    }\n\n    return {\n      type: type,\n      value: id,\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: start,\n      end: index\n    };\n  } // ECMA-262 11.7 Punctuators\n\n\n  function scanPunctuator() {\n    var token, str;\n    token = {\n      type: Token.Punctuator,\n      value: '',\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: index,\n      end: index\n    }; // Check for most common single-character punctuators.\n\n    str = source[index];\n\n    switch (str) {\n      case '(':\n        if (extra.tokenize) {\n          extra.openParenToken = extra.tokenValues.length;\n        }\n\n        ++index;\n        break;\n\n      case '{':\n        if (extra.tokenize) {\n          extra.openCurlyToken = extra.tokenValues.length;\n        }\n\n        state.curlyStack.push('{');\n        ++index;\n        break;\n\n      case '.':\n        ++index;\n\n        if (source[index] === '.' && source[index + 1] === '.') {\n          // Spread operator: ...\n          index += 2;\n          str = '...';\n        }\n\n        break;\n\n      case '}':\n        ++index;\n        state.curlyStack.pop();\n        break;\n\n      case ')':\n      case ';':\n      case ',':\n      case '[':\n      case ']':\n      case ':':\n      case '?':\n      case '~':\n        ++index;\n        break;\n\n      default:\n        // 4-character punctuator.\n        str = source.substr(index, 4);\n\n        if (str === '>>>=') {\n          index += 4;\n        } else {\n          // 3-character punctuators.\n          str = str.substr(0, 3);\n\n          if (str === '===' || str === '!==' || str === '>>>' || str === '<<=' || str === '>>=') {\n            index += 3;\n          } else {\n            // 2-character punctuators.\n            str = str.substr(0, 2);\n\n            if (str === '&&' || str === '||' || str === '==' || str === '!=' || str === '+=' || str === '-=' || str === '*=' || str === '/=' || str === '++' || str === '--' || str === '<<' || str === '>>' || str === '&=' || str === '|=' || str === '^=' || str === '%=' || str === '<=' || str === '>=' || str === '=>') {\n              index += 2;\n            } else {\n              // 1-character punctuators.\n              str = source[index];\n\n              if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {\n                ++index;\n              }\n            }\n          }\n        }\n\n    }\n\n    if (index === token.start) {\n      throwUnexpectedToken();\n    }\n\n    token.end = index;\n    token.value = str;\n    return token;\n  } // ECMA-262 11.8.3 Numeric Literals\n\n\n  function scanHexLiteral(start) {\n    var number = '';\n\n    while (index < length) {\n      if (!isHexDigit(source[index])) {\n        break;\n      }\n\n      number += source[index++];\n    }\n\n    if (number.length === 0) {\n      throwUnexpectedToken();\n    }\n\n    if (isIdentifierStart(source.charCodeAt(index))) {\n      throwUnexpectedToken();\n    }\n\n    return {\n      type: Token.NumericLiteral,\n      value: parseInt('0x' + number, 16),\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: start,\n      end: index\n    };\n  }\n\n  function scanBinaryLiteral(start) {\n    var ch, number;\n    number = '';\n\n    while (index < length) {\n      ch = source[index];\n\n      if (ch !== '0' && ch !== '1') {\n        break;\n      }\n\n      number += source[index++];\n    }\n\n    if (number.length === 0) {\n      // only 0b or 0B\n      throwUnexpectedToken();\n    }\n\n    if (index < length) {\n      ch = source.charCodeAt(index);\n      /* istanbul ignore else */\n\n      if (isIdentifierStart(ch) || isDecimalDigit(ch)) {\n        throwUnexpectedToken();\n      }\n    }\n\n    return {\n      type: Token.NumericLiteral,\n      value: parseInt(number, 2),\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: start,\n      end: index\n    };\n  }\n\n  function scanOctalLiteral(prefix, start) {\n    var number, octal;\n\n    if (isOctalDigit(prefix)) {\n      octal = true;\n      number = '0' + source[index++];\n    } else {\n      octal = false;\n      ++index;\n      number = '';\n    }\n\n    while (index < length) {\n      if (!isOctalDigit(source[index])) {\n        break;\n      }\n\n      number += source[index++];\n    }\n\n    if (!octal && number.length === 0) {\n      // only 0o or 0O\n      throwUnexpectedToken();\n    }\n\n    if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n      throwUnexpectedToken();\n    }\n\n    return {\n      type: Token.NumericLiteral,\n      value: parseInt(number, 8),\n      octal: octal,\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: start,\n      end: index\n    };\n  }\n\n  function isImplicitOctalLiteral() {\n    var i, ch; // Implicit octal, unless there is a non-octal digit.\n    // (Annex B.1.1 on Numeric Literals)\n\n    for (i = index + 1; i < length; ++i) {\n      ch = source[i];\n\n      if (ch === '8' || ch === '9') {\n        return false;\n      }\n\n      if (!isOctalDigit(ch)) {\n        return true;\n      }\n    }\n\n    return true;\n  }\n\n  function scanNumericLiteral() {\n    var number, start, ch;\n    ch = source[index];\n    assert(isDecimalDigit(ch.charCodeAt(0)) || ch === '.', 'Numeric literal must start with a decimal digit or a decimal point');\n    start = index;\n    number = '';\n\n    if (ch !== '.') {\n      number = source[index++];\n      ch = source[index]; // Hex number starts with '0x'.\n      // Octal number starts with '0'.\n      // Octal number in ES6 starts with '0o'.\n      // Binary number in ES6 starts with '0b'.\n\n      if (number === '0') {\n        if (ch === 'x' || ch === 'X') {\n          ++index;\n          return scanHexLiteral(start);\n        }\n\n        if (ch === 'b' || ch === 'B') {\n          ++index;\n          return scanBinaryLiteral(start);\n        }\n\n        if (ch === 'o' || ch === 'O') {\n          return scanOctalLiteral(ch, start);\n        }\n\n        if (isOctalDigit(ch)) {\n          if (isImplicitOctalLiteral()) {\n            return scanOctalLiteral(ch, start);\n          }\n        }\n      }\n\n      while (isDecimalDigit(source.charCodeAt(index))) {\n        number += source[index++];\n      }\n\n      ch = source[index];\n    }\n\n    if (ch === '.') {\n      number += source[index++];\n\n      while (isDecimalDigit(source.charCodeAt(index))) {\n        number += source[index++];\n      }\n\n      ch = source[index];\n    }\n\n    if (ch === 'e' || ch === 'E') {\n      number += source[index++];\n      ch = source[index];\n\n      if (ch === '+' || ch === '-') {\n        number += source[index++];\n      }\n\n      if (isDecimalDigit(source.charCodeAt(index))) {\n        while (isDecimalDigit(source.charCodeAt(index))) {\n          number += source[index++];\n        }\n      } else {\n        throwUnexpectedToken();\n      }\n    }\n\n    if (isIdentifierStart(source.charCodeAt(index))) {\n      throwUnexpectedToken();\n    }\n\n    return {\n      type: Token.NumericLiteral,\n      value: parseFloat(number),\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: start,\n      end: index\n    };\n  } // ECMA-262 11.8.4 String Literals\n\n\n  function scanStringLiteral() {\n    var str = '',\n        quote,\n        start,\n        ch,\n        unescaped,\n        octToDec,\n        octal = false;\n    quote = source[index];\n    assert(quote === '\\'' || quote === '\"', 'String literal must starts with a quote');\n    start = index;\n    ++index;\n\n    while (index < length) {\n      ch = source[index++];\n\n      if (ch === quote) {\n        quote = '';\n        break;\n      } else if (ch === '\\\\') {\n        ch = source[index++];\n\n        if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n          switch (ch) {\n            case 'u':\n            case 'x':\n              if (source[index] === '{') {\n                ++index;\n                str += scanUnicodeCodePointEscape();\n              } else {\n                unescaped = scanHexEscape(ch);\n\n                if (!unescaped) {\n                  throw throwUnexpectedToken();\n                }\n\n                str += unescaped;\n              }\n\n              break;\n\n            case 'n':\n              str += '\\n';\n              break;\n\n            case 'r':\n              str += '\\r';\n              break;\n\n            case 't':\n              str += '\\t';\n              break;\n\n            case 'b':\n              str += '\\b';\n              break;\n\n            case 'f':\n              str += '\\f';\n              break;\n\n            case 'v':\n              str += '\\x0B';\n              break;\n\n            case '8':\n            case '9':\n              str += ch;\n              tolerateUnexpectedToken();\n              break;\n\n            default:\n              if (isOctalDigit(ch)) {\n                octToDec = octalToDecimal(ch);\n                octal = octToDec.octal || octal;\n                str += String.fromCharCode(octToDec.code);\n              } else {\n                str += ch;\n              }\n\n              break;\n          }\n        } else {\n          ++lineNumber;\n\n          if (ch === '\\r' && source[index] === '\\n') {\n            ++index;\n          }\n\n          lineStart = index;\n        }\n      } else if (isLineTerminator(ch.charCodeAt(0))) {\n        break;\n      } else {\n        str += ch;\n      }\n    }\n\n    if (quote !== '') {\n      index = start;\n      throwUnexpectedToken();\n    }\n\n    return {\n      type: Token.StringLiteral,\n      value: str,\n      octal: octal,\n      lineNumber: startLineNumber,\n      lineStart: startLineStart,\n      start: start,\n      end: index\n    };\n  } // ECMA-262 11.8.6 Template Literal Lexical Components\n\n\n  function scanTemplate() {\n    var cooked = '',\n        ch,\n        start,\n        rawOffset,\n        terminated,\n        head,\n        tail,\n        restore,\n        unescaped;\n    terminated = false;\n    tail = false;\n    start = index;\n    head = source[index] === '`';\n    rawOffset = 2;\n    ++index;\n\n    while (index < length) {\n      ch = source[index++];\n\n      if (ch === '`') {\n        rawOffset = 1;\n        tail = true;\n        terminated = true;\n        break;\n      } else if (ch === '$') {\n        if (source[index] === '{') {\n          state.curlyStack.push('${');\n          ++index;\n          terminated = true;\n          break;\n        }\n\n        cooked += ch;\n      } else if (ch === '\\\\') {\n        ch = source[index++];\n\n        if (!isLineTerminator(ch.charCodeAt(0))) {\n          switch (ch) {\n            case 'n':\n              cooked += '\\n';\n              break;\n\n            case 'r':\n              cooked += '\\r';\n              break;\n\n            case 't':\n              cooked += '\\t';\n              break;\n\n            case 'u':\n            case 'x':\n              if (source[index] === '{') {\n                ++index;\n                cooked += scanUnicodeCodePointEscape();\n              } else {\n                restore = index;\n                unescaped = scanHexEscape(ch);\n\n                if (unescaped) {\n                  cooked += unescaped;\n                } else {\n                  index = restore;\n                  cooked += ch;\n                }\n              }\n\n              break;\n\n            case 'b':\n              cooked += '\\b';\n              break;\n\n            case 'f':\n              cooked += '\\f';\n              break;\n\n            case 'v':\n              cooked += '\\v';\n              break;\n\n            default:\n              if (ch === '0') {\n                if (isDecimalDigit(source.charCodeAt(index))) {\n                  // Illegal: \\01 \\02 and so on\n                  throwError(Messages.TemplateOctalLiteral);\n                }\n\n                cooked += '\\0';\n              } else if (isOctalDigit(ch)) {\n                // Illegal: \\1 \\2\n                throwError(Messages.TemplateOctalLiteral);\n              } else {\n                cooked += ch;\n              }\n\n              break;\n          }\n        } else {\n          ++lineNumber;\n\n          if (ch === '\\r' && source[index] === '\\n') {\n            ++index;\n          }\n\n          lineStart = index;\n        }\n      } else if (isLineTerminator(ch.charCodeAt(0))) {\n        ++lineNumber;\n\n        if (ch === '\\r' && source[index] === '\\n') {\n          ++index;\n        }\n\n        lineStart = index;\n        cooked += '\\n';\n      } else {\n        cooked += ch;\n      }\n    }\n\n    if (!terminated) {\n      throwUnexpectedToken();\n    }\n\n    if (!head) {\n      state.curlyStack.pop();\n    }\n\n    return {\n      type: Token.Template,\n      value: {\n        cooked: cooked,\n        raw: source.slice(start + 1, index - rawOffset)\n      },\n      head: head,\n      tail: tail,\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: start,\n      end: index\n    };\n  } // ECMA-262 11.8.5 Regular Expression Literals\n\n\n  function testRegExp(pattern, flags) {\n    // The BMP character to use as a replacement for astral symbols when\n    // translating an ES6 \"u\"-flagged pattern to an ES5-compatible\n    // approximation.\n    // Note: replacing with '\\uFFFF' enables false positives in unlikely\n    // scenarios. For example, `[\\u{1044f}-\\u{10440}]` is an invalid\n    // pattern that would not be detected by this substitution.\n    var astralSubstitute = '\\uFFFF',\n        tmp = pattern;\n\n    if (flags.indexOf('u') >= 0) {\n      tmp = tmp // Replace every Unicode escape sequence with the equivalent\n      // BMP character or a constant ASCII code point in the case of\n      // astral symbols. (See the above note on `astralSubstitute`\n      // for more information.)\n      .replace(/\\\\u\\{([0-9a-fA-F]+)\\}|\\\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {\n        var codePoint = parseInt($1 || $2, 16);\n\n        if (codePoint > 0x10FFFF) {\n          throwUnexpectedToken(null, Messages.InvalidRegExp);\n        }\n\n        if (codePoint <= 0xFFFF) {\n          return String.fromCharCode(codePoint);\n        }\n\n        return astralSubstitute;\n      }) // Replace each paired surrogate with a single ASCII symbol to\n      // avoid throwing on regular expressions that are only valid in\n      // combination with the \"u\" flag.\n      .replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, astralSubstitute);\n    } // First, detect invalid regular expressions.\n\n\n    try {\n      RegExp(tmp);\n    } catch (e) {\n      throwUnexpectedToken(null, Messages.InvalidRegExp);\n    } // Return a regular expression object for this pattern-flag pair, or\n    // `null` in case the current environment doesn't support the flags it\n    // uses.\n\n\n    try {\n      return new RegExp(pattern, flags);\n    } catch (exception) {\n      /* istanbul ignore next */\n      return null;\n    }\n  }\n\n  function scanRegExpBody() {\n    var ch, str, classMarker, terminated, body;\n    ch = source[index];\n    assert(ch === '/', 'Regular expression literal must start with a slash');\n    str = source[index++];\n    classMarker = false;\n    terminated = false;\n\n    while (index < length) {\n      ch = source[index++];\n      str += ch;\n\n      if (ch === '\\\\') {\n        ch = source[index++]; // ECMA-262 7.8.5\n\n        if (isLineTerminator(ch.charCodeAt(0))) {\n          throwUnexpectedToken(null, Messages.UnterminatedRegExp);\n        }\n\n        str += ch;\n      } else if (isLineTerminator(ch.charCodeAt(0))) {\n        throwUnexpectedToken(null, Messages.UnterminatedRegExp);\n      } else if (classMarker) {\n        if (ch === ']') {\n          classMarker = false;\n        }\n      } else {\n        if (ch === '/') {\n          terminated = true;\n          break;\n        } else if (ch === '[') {\n          classMarker = true;\n        }\n      }\n    }\n\n    if (!terminated) {\n      throwUnexpectedToken(null, Messages.UnterminatedRegExp);\n    } // Exclude leading and trailing slash.\n\n\n    body = str.substr(1, str.length - 2);\n    return {\n      value: body,\n      literal: str\n    };\n  }\n\n  function scanRegExpFlags() {\n    var ch, str, flags, restore;\n    str = '';\n    flags = '';\n\n    while (index < length) {\n      ch = source[index];\n\n      if (!isIdentifierPart(ch.charCodeAt(0))) {\n        break;\n      }\n\n      ++index;\n\n      if (ch === '\\\\' && index < length) {\n        ch = source[index];\n\n        if (ch === 'u') {\n          ++index;\n          restore = index;\n          ch = scanHexEscape('u');\n\n          if (ch) {\n            flags += ch;\n\n            for (str += '\\\\u'; restore < index; ++restore) {\n              str += source[restore];\n            }\n          } else {\n            index = restore;\n            flags += 'u';\n            str += '\\\\u';\n          }\n\n          tolerateUnexpectedToken();\n        } else {\n          str += '\\\\';\n          tolerateUnexpectedToken();\n        }\n      } else {\n        flags += ch;\n        str += ch;\n      }\n    }\n\n    return {\n      value: flags,\n      literal: str\n    };\n  }\n\n  function scanRegExp() {\n    var start, body, flags, value;\n    scanning = true;\n    lookahead = null;\n    skipComment();\n    start = index;\n    body = scanRegExpBody();\n    flags = scanRegExpFlags();\n    value = testRegExp(body.value, flags.value);\n    scanning = false;\n\n    if (extra.tokenize) {\n      return {\n        type: Token.RegularExpression,\n        value: value,\n        regex: {\n          pattern: body.value,\n          flags: flags.value\n        },\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        start: start,\n        end: index\n      };\n    }\n\n    return {\n      literal: body.literal + flags.literal,\n      value: value,\n      regex: {\n        pattern: body.value,\n        flags: flags.value\n      },\n      start: start,\n      end: index\n    };\n  }\n\n  function collectRegex() {\n    var pos, loc, regex, token;\n    skipComment();\n    pos = index;\n    loc = {\n      start: {\n        line: lineNumber,\n        column: index - lineStart\n      }\n    };\n    regex = scanRegExp();\n    loc.end = {\n      line: lineNumber,\n      column: index - lineStart\n    };\n    /* istanbul ignore next */\n\n    if (!extra.tokenize) {\n      // Pop the previous token, which is likely '/' or '/='\n      if (extra.tokens.length > 0) {\n        token = extra.tokens[extra.tokens.length - 1];\n\n        if (token.range[0] === pos && token.type === 'Punctuator') {\n          if (token.value === '/' || token.value === '/=') {\n            extra.tokens.pop();\n          }\n        }\n      }\n\n      extra.tokens.push({\n        type: 'RegularExpression',\n        value: regex.literal,\n        regex: regex.regex,\n        range: [pos, index],\n        loc: loc\n      });\n    }\n\n    return regex;\n  }\n\n  function isIdentifierName(token) {\n    return token.type === Token.Identifier || token.type === Token.Keyword || token.type === Token.BooleanLiteral || token.type === Token.NullLiteral;\n  } // Using the following algorithm:\n  // https://github.com/mozilla/sweet.js/wiki/design\n\n\n  function advanceSlash() {\n    var regex, previous, check;\n\n    function testKeyword(value) {\n      return value && value.length > 1 && value[0] >= 'a' && value[0] <= 'z';\n    }\n\n    previous = extra.tokenValues[extra.tokenValues.length - 1];\n    regex = previous !== null;\n\n    switch (previous) {\n      case 'this':\n      case ']':\n        regex = false;\n        break;\n\n      case ')':\n        check = extra.tokenValues[extra.openParenToken - 1];\n        regex = check === 'if' || check === 'while' || check === 'for' || check === 'with';\n        break;\n\n      case '}':\n        // Dividing a function by anything makes little sense,\n        // but we have to check for that.\n        regex = false;\n\n        if (testKeyword(extra.tokenValues[extra.openCurlyToken - 3])) {\n          // Anonymous function, e.g. function(){} /42\n          check = extra.tokenValues[extra.openCurlyToken - 4];\n          regex = check ? FnExprTokens.indexOf(check) < 0 : false;\n        } else if (testKeyword(extra.tokenValues[extra.openCurlyToken - 4])) {\n          // Named function, e.g. function f(){} /42/\n          check = extra.tokenValues[extra.openCurlyToken - 5];\n          regex = check ? FnExprTokens.indexOf(check) < 0 : true;\n        }\n\n    }\n\n    return regex ? collectRegex() : scanPunctuator();\n  }\n\n  function advance() {\n    var cp, token;\n\n    if (index >= length) {\n      return {\n        type: Token.EOF,\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        start: index,\n        end: index\n      };\n    }\n\n    cp = source.charCodeAt(index);\n\n    if (isIdentifierStart(cp)) {\n      token = scanIdentifier();\n\n      if (strict && isStrictModeReservedWord(token.value)) {\n        token.type = Token.Keyword;\n      }\n\n      return token;\n    } // Very common: ( and ) and ;\n\n\n    if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {\n      return scanPunctuator();\n    } // String literal starts with single quote (U+0027) or double quote (U+0022).\n\n\n    if (cp === 0x27 || cp === 0x22) {\n      return scanStringLiteral();\n    } // Dot (.) U+002E can also start a floating-point number, hence the need\n    // to check the next character.\n\n\n    if (cp === 0x2E) {\n      if (isDecimalDigit(source.charCodeAt(index + 1))) {\n        return scanNumericLiteral();\n      }\n\n      return scanPunctuator();\n    }\n\n    if (isDecimalDigit(cp)) {\n      return scanNumericLiteral();\n    } // Slash (/) U+002F can also start a regex.\n\n\n    if (extra.tokenize && cp === 0x2F) {\n      return advanceSlash();\n    } // Template literals start with ` (U+0060) for template head\n    // or } (U+007D) for template middle or template tail.\n\n\n    if (cp === 0x60 || cp === 0x7D && state.curlyStack[state.curlyStack.length - 1] === '${') {\n      return scanTemplate();\n    } // Possible identifier start in a surrogate pair.\n\n\n    if (cp >= 0xD800 && cp < 0xDFFF) {\n      cp = codePointAt(index);\n\n      if (isIdentifierStart(cp)) {\n        return scanIdentifier();\n      }\n    }\n\n    return scanPunctuator();\n  }\n\n  function collectToken() {\n    var loc, token, value, entry;\n    loc = {\n      start: {\n        line: lineNumber,\n        column: index - lineStart\n      }\n    };\n    token = advance();\n    loc.end = {\n      line: lineNumber,\n      column: index - lineStart\n    };\n\n    if (token.type !== Token.EOF) {\n      value = source.slice(token.start, token.end);\n      entry = {\n        type: TokenName[token.type],\n        value: value,\n        range: [token.start, token.end],\n        loc: loc\n      };\n\n      if (token.regex) {\n        entry.regex = {\n          pattern: token.regex.pattern,\n          flags: token.regex.flags\n        };\n      }\n\n      if (extra.tokenValues) {\n        extra.tokenValues.push(entry.type === 'Punctuator' || entry.type === 'Keyword' ? entry.value : null);\n      }\n\n      if (extra.tokenize) {\n        if (!extra.range) {\n          delete entry.range;\n        }\n\n        if (!extra.loc) {\n          delete entry.loc;\n        }\n\n        if (extra.delegate) {\n          entry = extra.delegate(entry);\n        }\n      }\n\n      extra.tokens.push(entry);\n    }\n\n    return token;\n  }\n\n  function lex() {\n    var token;\n    scanning = true;\n    lastIndex = index;\n    lastLineNumber = lineNumber;\n    lastLineStart = lineStart;\n    skipComment();\n    token = lookahead;\n    startIndex = index;\n    startLineNumber = lineNumber;\n    startLineStart = lineStart;\n    lookahead = typeof extra.tokens !== 'undefined' ? collectToken() : advance();\n    scanning = false;\n    return token;\n  }\n\n  function peek() {\n    scanning = true;\n    skipComment();\n    lastIndex = index;\n    lastLineNumber = lineNumber;\n    lastLineStart = lineStart;\n    startIndex = index;\n    startLineNumber = lineNumber;\n    startLineStart = lineStart;\n    lookahead = typeof extra.tokens !== 'undefined' ? collectToken() : advance();\n    scanning = false;\n  }\n\n  function Position() {\n    this.line = startLineNumber;\n    this.column = startIndex - startLineStart;\n  }\n\n  function SourceLocation() {\n    this.start = new Position();\n    this.end = null;\n  }\n\n  function WrappingSourceLocation(startToken) {\n    this.start = {\n      line: startToken.lineNumber,\n      column: startToken.start - startToken.lineStart\n    };\n    this.end = null;\n  }\n\n  function Node() {\n    if (extra.range) {\n      this.range = [startIndex, 0];\n    }\n\n    if (extra.loc) {\n      this.loc = new SourceLocation();\n    }\n  }\n\n  function WrappingNode(startToken) {\n    if (extra.range) {\n      this.range = [startToken.start, 0];\n    }\n\n    if (extra.loc) {\n      this.loc = new WrappingSourceLocation(startToken);\n    }\n  }\n\n  WrappingNode.prototype = Node.prototype = {\n    processComment: function () {\n      var lastChild,\n          innerComments,\n          leadingComments,\n          trailingComments,\n          bottomRight = extra.bottomRightStack,\n          i,\n          comment,\n          last = bottomRight[bottomRight.length - 1];\n\n      if (this.type === Syntax.Program) {\n        if (this.body.length > 0) {\n          return;\n        }\n      }\n      /**\n       * patch innnerComments for properties empty block\n       * `function a() {/** comments **\\/}`\n       */\n\n\n      if (this.type === Syntax.BlockStatement && this.body.length === 0) {\n        innerComments = [];\n\n        for (i = extra.leadingComments.length - 1; i >= 0; --i) {\n          comment = extra.leadingComments[i];\n\n          if (this.range[1] >= comment.range[1]) {\n            innerComments.unshift(comment);\n            extra.leadingComments.splice(i, 1);\n            extra.trailingComments.splice(i, 1);\n          }\n        }\n\n        if (innerComments.length) {\n          this.innerComments = innerComments; //bottomRight.push(this);\n\n          return;\n        }\n      }\n\n      if (extra.trailingComments.length > 0) {\n        trailingComments = [];\n\n        for (i = extra.trailingComments.length - 1; i >= 0; --i) {\n          comment = extra.trailingComments[i];\n\n          if (comment.range[0] >= this.range[1]) {\n            trailingComments.unshift(comment);\n            extra.trailingComments.splice(i, 1);\n          }\n        }\n\n        extra.trailingComments = [];\n      } else {\n        if (last && last.trailingComments && last.trailingComments[0].range[0] >= this.range[1]) {\n          trailingComments = last.trailingComments;\n          delete last.trailingComments;\n        }\n      } // Eating the stack.\n\n\n      while (last && last.range[0] >= this.range[0]) {\n        lastChild = bottomRight.pop();\n        last = bottomRight[bottomRight.length - 1];\n      }\n\n      if (lastChild) {\n        if (lastChild.leadingComments) {\n          leadingComments = [];\n\n          for (i = lastChild.leadingComments.length - 1; i >= 0; --i) {\n            comment = lastChild.leadingComments[i];\n\n            if (comment.range[1] <= this.range[0]) {\n              leadingComments.unshift(comment);\n              lastChild.leadingComments.splice(i, 1);\n            }\n          }\n\n          if (!lastChild.leadingComments.length) {\n            lastChild.leadingComments = undefined;\n          }\n        }\n      } else if (extra.leadingComments.length > 0) {\n        leadingComments = [];\n\n        for (i = extra.leadingComments.length - 1; i >= 0; --i) {\n          comment = extra.leadingComments[i];\n\n          if (comment.range[1] <= this.range[0]) {\n            leadingComments.unshift(comment);\n            extra.leadingComments.splice(i, 1);\n          }\n        }\n      }\n\n      if (leadingComments && leadingComments.length > 0) {\n        this.leadingComments = leadingComments;\n      }\n\n      if (trailingComments && trailingComments.length > 0) {\n        this.trailingComments = trailingComments;\n      }\n\n      bottomRight.push(this);\n    },\n    finish: function () {\n      if (extra.range) {\n        this.range[1] = lastIndex;\n      }\n\n      if (extra.loc) {\n        this.loc.end = {\n          line: lastLineNumber,\n          column: lastIndex - lastLineStart\n        };\n\n        if (extra.source) {\n          this.loc.source = extra.source;\n        }\n      }\n\n      if (extra.attachComment) {\n        this.processComment();\n      }\n    },\n    finishArrayExpression: function (elements) {\n      this.type = Syntax.ArrayExpression;\n      this.elements = elements;\n      this.finish();\n      return this;\n    },\n    finishArrayPattern: function (elements) {\n      this.type = Syntax.ArrayPattern;\n      this.elements = elements;\n      this.finish();\n      return this;\n    },\n    finishArrowFunctionExpression: function (params, defaults, body, expression) {\n      this.type = Syntax.ArrowFunctionExpression;\n      this.id = null;\n      this.params = params;\n      this.defaults = defaults;\n      this.body = body;\n      this.generator = false;\n      this.expression = expression;\n      this.finish();\n      return this;\n    },\n    finishAssignmentExpression: function (operator, left, right) {\n      this.type = Syntax.AssignmentExpression;\n      this.operator = operator;\n      this.left = left;\n      this.right = right;\n      this.finish();\n      return this;\n    },\n    finishAssignmentPattern: function (left, right) {\n      this.type = Syntax.AssignmentPattern;\n      this.left = left;\n      this.right = right;\n      this.finish();\n      return this;\n    },\n    finishBinaryExpression: function (operator, left, right) {\n      this.type = operator === '||' || operator === '&&' ? Syntax.LogicalExpression : Syntax.BinaryExpression;\n      this.operator = operator;\n      this.left = left;\n      this.right = right;\n      this.finish();\n      return this;\n    },\n    finishBlockStatement: function (body) {\n      this.type = Syntax.BlockStatement;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishBreakStatement: function (label) {\n      this.type = Syntax.BreakStatement;\n      this.label = label;\n      this.finish();\n      return this;\n    },\n    finishCallExpression: function (callee, args) {\n      this.type = Syntax.CallExpression;\n      this.callee = callee;\n      this.arguments = args;\n      this.finish();\n      return this;\n    },\n    finishCatchClause: function (param, body) {\n      this.type = Syntax.CatchClause;\n      this.param = param;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishClassBody: function (body) {\n      this.type = Syntax.ClassBody;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishClassDeclaration: function (id, superClass, body) {\n      this.type = Syntax.ClassDeclaration;\n      this.id = id;\n      this.superClass = superClass;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishClassExpression: function (id, superClass, body) {\n      this.type = Syntax.ClassExpression;\n      this.id = id;\n      this.superClass = superClass;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishConditionalExpression: function (test, consequent, alternate) {\n      this.type = Syntax.ConditionalExpression;\n      this.test = test;\n      this.consequent = consequent;\n      this.alternate = alternate;\n      this.finish();\n      return this;\n    },\n    finishContinueStatement: function (label) {\n      this.type = Syntax.ContinueStatement;\n      this.label = label;\n      this.finish();\n      return this;\n    },\n    finishDebuggerStatement: function () {\n      this.type = Syntax.DebuggerStatement;\n      this.finish();\n      return this;\n    },\n    finishDoWhileStatement: function (body, test) {\n      this.type = Syntax.DoWhileStatement;\n      this.body = body;\n      this.test = test;\n      this.finish();\n      return this;\n    },\n    finishEmptyStatement: function () {\n      this.type = Syntax.EmptyStatement;\n      this.finish();\n      return this;\n    },\n    finishExpressionStatement: function (expression) {\n      this.type = Syntax.ExpressionStatement;\n      this.expression = expression;\n      this.finish();\n      return this;\n    },\n    finishForStatement: function (init, test, update, body) {\n      this.type = Syntax.ForStatement;\n      this.init = init;\n      this.test = test;\n      this.update = update;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishForOfStatement: function (left, right, body) {\n      this.type = Syntax.ForOfStatement;\n      this.left = left;\n      this.right = right;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishForInStatement: function (left, right, body) {\n      this.type = Syntax.ForInStatement;\n      this.left = left;\n      this.right = right;\n      this.body = body;\n      this.each = false;\n      this.finish();\n      return this;\n    },\n    finishFunctionDeclaration: function (id, params, defaults, body, generator) {\n      this.type = Syntax.FunctionDeclaration;\n      this.id = id;\n      this.params = params;\n      this.defaults = defaults;\n      this.body = body;\n      this.generator = generator;\n      this.expression = false;\n      this.finish();\n      return this;\n    },\n    finishFunctionExpression: function (id, params, defaults, body, generator) {\n      this.type = Syntax.FunctionExpression;\n      this.id = id;\n      this.params = params;\n      this.defaults = defaults;\n      this.body = body;\n      this.generator = generator;\n      this.expression = false;\n      this.finish();\n      return this;\n    },\n    finishIdentifier: function (name) {\n      this.type = Syntax.Identifier;\n      this.name = name;\n      this.finish();\n      return this;\n    },\n    finishIfStatement: function (test, consequent, alternate) {\n      this.type = Syntax.IfStatement;\n      this.test = test;\n      this.consequent = consequent;\n      this.alternate = alternate;\n      this.finish();\n      return this;\n    },\n    finishLabeledStatement: function (label, body) {\n      this.type = Syntax.LabeledStatement;\n      this.label = label;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishLiteral: function (token) {\n      this.type = Syntax.Literal;\n      this.value = token.value;\n      this.raw = source.slice(token.start, token.end);\n\n      if (token.regex) {\n        this.regex = token.regex;\n      }\n\n      this.finish();\n      return this;\n    },\n    finishMemberExpression: function (accessor, object, property) {\n      this.type = Syntax.MemberExpression;\n      this.computed = accessor === '[';\n      this.object = object;\n      this.property = property;\n      this.finish();\n      return this;\n    },\n    finishMetaProperty: function (meta, property) {\n      this.type = Syntax.MetaProperty;\n      this.meta = meta;\n      this.property = property;\n      this.finish();\n      return this;\n    },\n    finishNewExpression: function (callee, args) {\n      this.type = Syntax.NewExpression;\n      this.callee = callee;\n      this.arguments = args;\n      this.finish();\n      return this;\n    },\n    finishObjectExpression: function (properties) {\n      this.type = Syntax.ObjectExpression;\n      this.properties = properties;\n      this.finish();\n      return this;\n    },\n    finishObjectPattern: function (properties) {\n      this.type = Syntax.ObjectPattern;\n      this.properties = properties;\n      this.finish();\n      return this;\n    },\n    finishPostfixExpression: function (operator, argument) {\n      this.type = Syntax.UpdateExpression;\n      this.operator = operator;\n      this.argument = argument;\n      this.prefix = false;\n      this.finish();\n      return this;\n    },\n    finishProgram: function (body, sourceType) {\n      this.type = Syntax.Program;\n      this.body = body;\n      this.sourceType = sourceType;\n      this.finish();\n      return this;\n    },\n    finishProperty: function (kind, key, computed, value, method, shorthand) {\n      this.type = Syntax.Property;\n      this.key = key;\n      this.computed = computed;\n      this.value = value;\n      this.kind = kind;\n      this.method = method;\n      this.shorthand = shorthand;\n      this.finish();\n      return this;\n    },\n    finishRestElement: function (argument) {\n      this.type = Syntax.RestElement;\n      this.argument = argument;\n      this.finish();\n      return this;\n    },\n    finishReturnStatement: function (argument) {\n      this.type = Syntax.ReturnStatement;\n      this.argument = argument;\n      this.finish();\n      return this;\n    },\n    finishSequenceExpression: function (expressions) {\n      this.type = Syntax.SequenceExpression;\n      this.expressions = expressions;\n      this.finish();\n      return this;\n    },\n    finishSpreadElement: function (argument) {\n      this.type = Syntax.SpreadElement;\n      this.argument = argument;\n      this.finish();\n      return this;\n    },\n    finishSwitchCase: function (test, consequent) {\n      this.type = Syntax.SwitchCase;\n      this.test = test;\n      this.consequent = consequent;\n      this.finish();\n      return this;\n    },\n    finishSuper: function () {\n      this.type = Syntax.Super;\n      this.finish();\n      return this;\n    },\n    finishSwitchStatement: function (discriminant, cases) {\n      this.type = Syntax.SwitchStatement;\n      this.discriminant = discriminant;\n      this.cases = cases;\n      this.finish();\n      return this;\n    },\n    finishTaggedTemplateExpression: function (tag, quasi) {\n      this.type = Syntax.TaggedTemplateExpression;\n      this.tag = tag;\n      this.quasi = quasi;\n      this.finish();\n      return this;\n    },\n    finishTemplateElement: function (value, tail) {\n      this.type = Syntax.TemplateElement;\n      this.value = value;\n      this.tail = tail;\n      this.finish();\n      return this;\n    },\n    finishTemplateLiteral: function (quasis, expressions) {\n      this.type = Syntax.TemplateLiteral;\n      this.quasis = quasis;\n      this.expressions = expressions;\n      this.finish();\n      return this;\n    },\n    finishThisExpression: function () {\n      this.type = Syntax.ThisExpression;\n      this.finish();\n      return this;\n    },\n    finishThrowStatement: function (argument) {\n      this.type = Syntax.ThrowStatement;\n      this.argument = argument;\n      this.finish();\n      return this;\n    },\n    finishTryStatement: function (block, handler, finalizer) {\n      this.type = Syntax.TryStatement;\n      this.block = block;\n      this.guardedHandlers = [];\n      this.handlers = handler ? [handler] : [];\n      this.handler = handler;\n      this.finalizer = finalizer;\n      this.finish();\n      return this;\n    },\n    finishUnaryExpression: function (operator, argument) {\n      this.type = operator === '++' || operator === '--' ? Syntax.UpdateExpression : Syntax.UnaryExpression;\n      this.operator = operator;\n      this.argument = argument;\n      this.prefix = true;\n      this.finish();\n      return this;\n    },\n    finishVariableDeclaration: function (declarations) {\n      this.type = Syntax.VariableDeclaration;\n      this.declarations = declarations;\n      this.kind = 'var';\n      this.finish();\n      return this;\n    },\n    finishLexicalDeclaration: function (declarations, kind) {\n      this.type = Syntax.VariableDeclaration;\n      this.declarations = declarations;\n      this.kind = kind;\n      this.finish();\n      return this;\n    },\n    finishVariableDeclarator: function (id, init) {\n      this.type = Syntax.VariableDeclarator;\n      this.id = id;\n      this.init = init;\n      this.finish();\n      return this;\n    },\n    finishWhileStatement: function (test, body) {\n      this.type = Syntax.WhileStatement;\n      this.test = test;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishWithStatement: function (object, body) {\n      this.type = Syntax.WithStatement;\n      this.object = object;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishExportSpecifier: function (local, exported) {\n      this.type = Syntax.ExportSpecifier;\n      this.exported = exported || local;\n      this.local = local;\n      this.finish();\n      return this;\n    },\n    finishImportDefaultSpecifier: function (local) {\n      this.type = Syntax.ImportDefaultSpecifier;\n      this.local = local;\n      this.finish();\n      return this;\n    },\n    finishImportNamespaceSpecifier: function (local) {\n      this.type = Syntax.ImportNamespaceSpecifier;\n      this.local = local;\n      this.finish();\n      return this;\n    },\n    finishExportNamedDeclaration: function (declaration, specifiers, src) {\n      this.type = Syntax.ExportNamedDeclaration;\n      this.declaration = declaration;\n      this.specifiers = specifiers;\n      this.source = src;\n      this.finish();\n      return this;\n    },\n    finishExportDefaultDeclaration: function (declaration) {\n      this.type = Syntax.ExportDefaultDeclaration;\n      this.declaration = declaration;\n      this.finish();\n      return this;\n    },\n    finishExportAllDeclaration: function (src) {\n      this.type = Syntax.ExportAllDeclaration;\n      this.source = src;\n      this.finish();\n      return this;\n    },\n    finishImportSpecifier: function (local, imported) {\n      this.type = Syntax.ImportSpecifier;\n      this.local = local || imported;\n      this.imported = imported;\n      this.finish();\n      return this;\n    },\n    finishImportDeclaration: function (specifiers, src) {\n      this.type = Syntax.ImportDeclaration;\n      this.specifiers = specifiers;\n      this.source = src;\n      this.finish();\n      return this;\n    },\n    finishYieldExpression: function (argument, delegate) {\n      this.type = Syntax.YieldExpression;\n      this.argument = argument;\n      this.delegate = delegate;\n      this.finish();\n      return this;\n    }\n  };\n\n  function recordError(error) {\n    var e, existing;\n\n    for (e = 0; e < extra.errors.length; e++) {\n      existing = extra.errors[e]; // Prevent duplicated error.\n\n      /* istanbul ignore next */\n\n      if (existing.index === error.index && existing.message === error.message) {\n        return;\n      }\n    }\n\n    extra.errors.push(error);\n  }\n\n  function constructError(msg, column) {\n    var error = new Error(msg);\n\n    try {\n      throw error;\n    } catch (base) {\n      /* istanbul ignore else */\n      if (Object.create && Object.defineProperty) {\n        error = Object.create(base);\n        Object.defineProperty(error, 'column', {\n          value: column\n        });\n      }\n    } finally {\n      return error;\n    }\n  }\n\n  function createError(line, pos, description) {\n    var msg, column, error;\n    msg = 'Line ' + line + ': ' + description;\n    column = pos - (scanning ? lineStart : lastLineStart) + 1;\n    error = constructError(msg, column);\n    error.lineNumber = line;\n    error.description = description;\n    error.index = pos;\n    return error;\n  } // Throw an exception\n\n\n  function throwError(messageFormat) {\n    var args, msg;\n    args = Array.prototype.slice.call(arguments, 1);\n    msg = messageFormat.replace(/%(\\d)/g, function (whole, idx) {\n      assert(idx < args.length, 'Message reference must be in range');\n      return args[idx];\n    });\n    throw createError(lastLineNumber, lastIndex, msg);\n  }\n\n  function tolerateError(messageFormat) {\n    var args, msg, error;\n    args = Array.prototype.slice.call(arguments, 1);\n    /* istanbul ignore next */\n\n    msg = messageFormat.replace(/%(\\d)/g, function (whole, idx) {\n      assert(idx < args.length, 'Message reference must be in range');\n      return args[idx];\n    });\n    error = createError(lineNumber, lastIndex, msg);\n\n    if (extra.errors) {\n      recordError(error);\n    } else {\n      throw error;\n    }\n  } // Throw an exception because of the token.\n\n\n  function unexpectedTokenError(token, message) {\n    var value,\n        msg = message || Messages.UnexpectedToken;\n\n    if (token) {\n      if (!message) {\n        msg = token.type === Token.EOF ? Messages.UnexpectedEOS : token.type === Token.Identifier ? Messages.UnexpectedIdentifier : token.type === Token.NumericLiteral ? Messages.UnexpectedNumber : token.type === Token.StringLiteral ? Messages.UnexpectedString : token.type === Token.Template ? Messages.UnexpectedTemplate : Messages.UnexpectedToken;\n\n        if (token.type === Token.Keyword) {\n          if (isFutureReservedWord(token.value)) {\n            msg = Messages.UnexpectedReserved;\n          } else if (strict && isStrictModeReservedWord(token.value)) {\n            msg = Messages.StrictReservedWord;\n          }\n        }\n      }\n\n      value = token.type === Token.Template ? token.value.raw : token.value;\n    } else {\n      value = 'ILLEGAL';\n    }\n\n    msg = msg.replace('%0', value);\n    return token && typeof token.lineNumber === 'number' ? createError(token.lineNumber, token.start, msg) : createError(scanning ? lineNumber : lastLineNumber, scanning ? index : lastIndex, msg);\n  }\n\n  function throwUnexpectedToken(token, message) {\n    throw unexpectedTokenError(token, message);\n  }\n\n  function tolerateUnexpectedToken(token, message) {\n    var error = unexpectedTokenError(token, message);\n\n    if (extra.errors) {\n      recordError(error);\n    } else {\n      throw error;\n    }\n  } // Expect the next token to match the specified punctuator.\n  // If not, an exception will be thrown.\n\n\n  function expect(value) {\n    var token = lex();\n\n    if (token.type !== Token.Punctuator || token.value !== value) {\n      throwUnexpectedToken(token);\n    }\n  }\n  /**\n   * @name expectCommaSeparator\n   * @description Quietly expect a comma when in tolerant mode, otherwise delegates\n   * to <code>expect(value)</code>\n   * @since 2.0\n   */\n\n\n  function expectCommaSeparator() {\n    var token;\n\n    if (extra.errors) {\n      token = lookahead;\n\n      if (token.type === Token.Punctuator && token.value === ',') {\n        lex();\n      } else if (token.type === Token.Punctuator && token.value === ';') {\n        lex();\n        tolerateUnexpectedToken(token);\n      } else {\n        tolerateUnexpectedToken(token, Messages.UnexpectedToken);\n      }\n    } else {\n      expect(',');\n    }\n  } // Expect the next token to match the specified keyword.\n  // If not, an exception will be thrown.\n\n\n  function expectKeyword(keyword) {\n    var token = lex();\n\n    if (token.type !== Token.Keyword || token.value !== keyword) {\n      throwUnexpectedToken(token);\n    }\n  } // Return true if the next token matches the specified punctuator.\n\n\n  function match(value) {\n    return lookahead.type === Token.Punctuator && lookahead.value === value;\n  } // Return true if the next token matches the specified keyword\n\n\n  function matchKeyword(keyword) {\n    return lookahead.type === Token.Keyword && lookahead.value === keyword;\n  } // Return true if the next token matches the specified contextual keyword\n  // (where an identifier is sometimes a keyword depending on the context)\n\n\n  function matchContextualKeyword(keyword) {\n    return lookahead.type === Token.Identifier && lookahead.value === keyword;\n  } // Return true if the next token is an assignment operator\n\n\n  function matchAssign() {\n    var op;\n\n    if (lookahead.type !== Token.Punctuator) {\n      return false;\n    }\n\n    op = lookahead.value;\n    return op === '=' || op === '*=' || op === '/=' || op === '%=' || op === '+=' || op === '-=' || op === '<<=' || op === '>>=' || op === '>>>=' || op === '&=' || op === '^=' || op === '|=';\n  }\n\n  function consumeSemicolon() {\n    // Catch the very common case first: immediately a semicolon (U+003B).\n    if (source.charCodeAt(startIndex) === 0x3B || match(';')) {\n      lex();\n      return;\n    }\n\n    if (hasLineTerminator) {\n      return;\n    } // FIXME(ikarienator): this is seemingly an issue in the previous location info convention.\n\n\n    lastIndex = startIndex;\n    lastLineNumber = startLineNumber;\n    lastLineStart = startLineStart;\n\n    if (lookahead.type !== Token.EOF && !match('}')) {\n      throwUnexpectedToken(lookahead);\n    }\n  } // Cover grammar support.\n  //\n  // When an assignment expression position starts with an left parenthesis, the determination of the type\n  // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)\n  // or the first comma. This situation also defers the determination of all the expressions nested in the pair.\n  //\n  // There are three productions that can be parsed in a parentheses pair that needs to be determined\n  // after the outermost pair is closed. They are:\n  //\n  //   1. AssignmentExpression\n  //   2. BindingElements\n  //   3. AssignmentTargets\n  //\n  // In order to avoid exponential backtracking, we use two flags to denote if the production can be\n  // binding element or assignment target.\n  //\n  // The three productions have the relationship:\n  //\n  //   BindingElements  AssignmentTargets  AssignmentExpression\n  //\n  // with a single exception that CoverInitializedName when used directly in an Expression, generates\n  // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the\n  // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.\n  //\n  // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not\n  // effect the current flags. This means the production the parser parses is only used as an expression. Therefore\n  // the CoverInitializedName check is conducted.\n  //\n  // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates\n  // the flags outside of the parser. This means the production the parser parses is used as a part of a potential\n  // pattern. The CoverInitializedName check is deferred.\n\n\n  function isolateCoverGrammar(parser) {\n    var oldIsBindingElement = isBindingElement,\n        oldIsAssignmentTarget = isAssignmentTarget,\n        oldFirstCoverInitializedNameError = firstCoverInitializedNameError,\n        result;\n    isBindingElement = true;\n    isAssignmentTarget = true;\n    firstCoverInitializedNameError = null;\n    result = parser();\n\n    if (firstCoverInitializedNameError !== null) {\n      throwUnexpectedToken(firstCoverInitializedNameError);\n    }\n\n    isBindingElement = oldIsBindingElement;\n    isAssignmentTarget = oldIsAssignmentTarget;\n    firstCoverInitializedNameError = oldFirstCoverInitializedNameError;\n    return result;\n  }\n\n  function inheritCoverGrammar(parser) {\n    var oldIsBindingElement = isBindingElement,\n        oldIsAssignmentTarget = isAssignmentTarget,\n        oldFirstCoverInitializedNameError = firstCoverInitializedNameError,\n        result;\n    isBindingElement = true;\n    isAssignmentTarget = true;\n    firstCoverInitializedNameError = null;\n    result = parser();\n    isBindingElement = isBindingElement && oldIsBindingElement;\n    isAssignmentTarget = isAssignmentTarget && oldIsAssignmentTarget;\n    firstCoverInitializedNameError = oldFirstCoverInitializedNameError || firstCoverInitializedNameError;\n    return result;\n  } // ECMA-262 13.3.3 Destructuring Binding Patterns\n\n\n  function parseArrayPattern(params, kind) {\n    var node = new Node(),\n        elements = [],\n        rest,\n        restNode;\n    expect('[');\n\n    while (!match(']')) {\n      if (match(',')) {\n        lex();\n        elements.push(null);\n      } else {\n        if (match('...')) {\n          restNode = new Node();\n          lex();\n          params.push(lookahead);\n          rest = parseVariableIdentifier(kind);\n          elements.push(restNode.finishRestElement(rest));\n          break;\n        } else {\n          elements.push(parsePatternWithDefault(params, kind));\n        }\n\n        if (!match(']')) {\n          expect(',');\n        }\n      }\n    }\n\n    expect(']');\n    return node.finishArrayPattern(elements);\n  }\n\n  function parsePropertyPattern(params, kind) {\n    var node = new Node(),\n        key,\n        keyToken,\n        computed = match('['),\n        init;\n\n    if (lookahead.type === Token.Identifier) {\n      keyToken = lookahead;\n      key = parseVariableIdentifier();\n\n      if (match('=')) {\n        params.push(keyToken);\n        lex();\n        init = parseAssignmentExpression();\n        return node.finishProperty('init', key, false, new WrappingNode(keyToken).finishAssignmentPattern(key, init), false, true);\n      } else if (!match(':')) {\n        params.push(keyToken);\n        return node.finishProperty('init', key, false, key, false, true);\n      }\n    } else {\n      key = parseObjectPropertyKey();\n    }\n\n    expect(':');\n    init = parsePatternWithDefault(params, kind);\n    return node.finishProperty('init', key, computed, init, false, false);\n  }\n\n  function parseObjectPattern(params, kind) {\n    var node = new Node(),\n        properties = [];\n    expect('{');\n\n    while (!match('}')) {\n      properties.push(parsePropertyPattern(params, kind));\n\n      if (!match('}')) {\n        expect(',');\n      }\n    }\n\n    lex();\n    return node.finishObjectPattern(properties);\n  }\n\n  function parsePattern(params, kind) {\n    if (match('[')) {\n      return parseArrayPattern(params, kind);\n    } else if (match('{')) {\n      return parseObjectPattern(params, kind);\n    } else if (matchKeyword('let')) {\n      if (kind === 'const' || kind === 'let') {\n        tolerateUnexpectedToken(lookahead, Messages.UnexpectedToken);\n      }\n    }\n\n    params.push(lookahead);\n    return parseVariableIdentifier(kind);\n  }\n\n  function parsePatternWithDefault(params, kind) {\n    var startToken = lookahead,\n        pattern,\n        previousAllowYield,\n        right;\n    pattern = parsePattern(params, kind);\n\n    if (match('=')) {\n      lex();\n      previousAllowYield = state.allowYield;\n      state.allowYield = true;\n      right = isolateCoverGrammar(parseAssignmentExpression);\n      state.allowYield = previousAllowYield;\n      pattern = new WrappingNode(startToken).finishAssignmentPattern(pattern, right);\n    }\n\n    return pattern;\n  } // ECMA-262 12.2.5 Array Initializer\n\n\n  function parseArrayInitializer() {\n    var elements = [],\n        node = new Node(),\n        restSpread;\n    expect('[');\n\n    while (!match(']')) {\n      if (match(',')) {\n        lex();\n        elements.push(null);\n      } else if (match('...')) {\n        restSpread = new Node();\n        lex();\n        restSpread.finishSpreadElement(inheritCoverGrammar(parseAssignmentExpression));\n\n        if (!match(']')) {\n          isAssignmentTarget = isBindingElement = false;\n          expect(',');\n        }\n\n        elements.push(restSpread);\n      } else {\n        elements.push(inheritCoverGrammar(parseAssignmentExpression));\n\n        if (!match(']')) {\n          expect(',');\n        }\n      }\n    }\n\n    lex();\n    return node.finishArrayExpression(elements);\n  } // ECMA-262 12.2.6 Object Initializer\n\n\n  function parsePropertyFunction(node, paramInfo, isGenerator) {\n    var previousStrict, body;\n    isAssignmentTarget = isBindingElement = false;\n    previousStrict = strict;\n    body = isolateCoverGrammar(parseFunctionSourceElements);\n\n    if (strict && paramInfo.firstRestricted) {\n      tolerateUnexpectedToken(paramInfo.firstRestricted, paramInfo.message);\n    }\n\n    if (strict && paramInfo.stricted) {\n      tolerateUnexpectedToken(paramInfo.stricted, paramInfo.message);\n    }\n\n    strict = previousStrict;\n    return node.finishFunctionExpression(null, paramInfo.params, paramInfo.defaults, body, isGenerator);\n  }\n\n  function parsePropertyMethodFunction() {\n    var params,\n        method,\n        node = new Node(),\n        previousAllowYield = state.allowYield;\n    state.allowYield = false;\n    params = parseParams();\n    state.allowYield = previousAllowYield;\n    state.allowYield = false;\n    method = parsePropertyFunction(node, params, false);\n    state.allowYield = previousAllowYield;\n    return method;\n  }\n\n  function parseObjectPropertyKey() {\n    var token,\n        node = new Node(),\n        expr;\n    token = lex(); // Note: This function is called only from parseObjectProperty(), where\n    // EOF and Punctuator tokens are already filtered out.\n\n    switch (token.type) {\n      case Token.StringLiteral:\n      case Token.NumericLiteral:\n        if (strict && token.octal) {\n          tolerateUnexpectedToken(token, Messages.StrictOctalLiteral);\n        }\n\n        return node.finishLiteral(token);\n\n      case Token.Identifier:\n      case Token.BooleanLiteral:\n      case Token.NullLiteral:\n      case Token.Keyword:\n        return node.finishIdentifier(token.value);\n\n      case Token.Punctuator:\n        if (token.value === '[') {\n          expr = isolateCoverGrammar(parseAssignmentExpression);\n          expect(']');\n          return expr;\n        }\n\n        break;\n    }\n\n    throwUnexpectedToken(token);\n  }\n\n  function lookaheadPropertyName() {\n    switch (lookahead.type) {\n      case Token.Identifier:\n      case Token.StringLiteral:\n      case Token.BooleanLiteral:\n      case Token.NullLiteral:\n      case Token.NumericLiteral:\n      case Token.Keyword:\n        return true;\n\n      case Token.Punctuator:\n        return lookahead.value === '[';\n    }\n\n    return false;\n  } // This function is to try to parse a MethodDefinition as defined in 14.3. But in the case of object literals,\n  // it might be called at a position where there is in fact a short hand identifier pattern or a data property.\n  // This can only be determined after we consumed up to the left parentheses.\n  //\n  // In order to avoid back tracking, it returns `null` if the position is not a MethodDefinition and the caller\n  // is responsible to visit other options.\n\n\n  function tryParseMethodDefinition(token, key, computed, node) {\n    var value,\n        options,\n        methodNode,\n        params,\n        previousAllowYield = state.allowYield;\n\n    if (token.type === Token.Identifier) {\n      // check for `get` and `set`;\n      if (token.value === 'get' && lookaheadPropertyName()) {\n        computed = match('[');\n        key = parseObjectPropertyKey();\n        methodNode = new Node();\n        expect('(');\n        expect(')');\n        state.allowYield = false;\n        value = parsePropertyFunction(methodNode, {\n          params: [],\n          defaults: [],\n          stricted: null,\n          firstRestricted: null,\n          message: null\n        }, false);\n        state.allowYield = previousAllowYield;\n        return node.finishProperty('get', key, computed, value, false, false);\n      } else if (token.value === 'set' && lookaheadPropertyName()) {\n        computed = match('[');\n        key = parseObjectPropertyKey();\n        methodNode = new Node();\n        expect('(');\n        options = {\n          params: [],\n          defaultCount: 0,\n          defaults: [],\n          firstRestricted: null,\n          paramSet: {}\n        };\n\n        if (match(')')) {\n          tolerateUnexpectedToken(lookahead);\n        } else {\n          state.allowYield = false;\n          parseParam(options);\n          state.allowYield = previousAllowYield;\n\n          if (options.defaultCount === 0) {\n            options.defaults = [];\n          }\n        }\n\n        expect(')');\n        state.allowYield = false;\n        value = parsePropertyFunction(methodNode, options, false);\n        state.allowYield = previousAllowYield;\n        return node.finishProperty('set', key, computed, value, false, false);\n      }\n    } else if (token.type === Token.Punctuator && token.value === '*' && lookaheadPropertyName()) {\n      computed = match('[');\n      key = parseObjectPropertyKey();\n      methodNode = new Node();\n      state.allowYield = true;\n      params = parseParams();\n      state.allowYield = previousAllowYield;\n      state.allowYield = false;\n      value = parsePropertyFunction(methodNode, params, true);\n      state.allowYield = previousAllowYield;\n      return node.finishProperty('init', key, computed, value, true, false);\n    }\n\n    if (key && match('(')) {\n      value = parsePropertyMethodFunction();\n      return node.finishProperty('init', key, computed, value, true, false);\n    } // Not a MethodDefinition.\n\n\n    return null;\n  }\n\n  function parseObjectProperty(hasProto) {\n    var token = lookahead,\n        node = new Node(),\n        computed,\n        key,\n        maybeMethod,\n        proto,\n        value;\n    computed = match('[');\n\n    if (match('*')) {\n      lex();\n    } else {\n      key = parseObjectPropertyKey();\n    }\n\n    maybeMethod = tryParseMethodDefinition(token, key, computed, node);\n\n    if (maybeMethod) {\n      return maybeMethod;\n    }\n\n    if (!key) {\n      throwUnexpectedToken(lookahead);\n    } // Check for duplicated __proto__\n\n\n    if (!computed) {\n      proto = key.type === Syntax.Identifier && key.name === '__proto__' || key.type === Syntax.Literal && key.value === '__proto__';\n\n      if (hasProto.value && proto) {\n        tolerateError(Messages.DuplicateProtoProperty);\n      }\n\n      hasProto.value |= proto;\n    }\n\n    if (match(':')) {\n      lex();\n      value = inheritCoverGrammar(parseAssignmentExpression);\n      return node.finishProperty('init', key, computed, value, false, false);\n    }\n\n    if (token.type === Token.Identifier) {\n      if (match('=')) {\n        firstCoverInitializedNameError = lookahead;\n        lex();\n        value = isolateCoverGrammar(parseAssignmentExpression);\n        return node.finishProperty('init', key, computed, new WrappingNode(token).finishAssignmentPattern(key, value), false, true);\n      }\n\n      return node.finishProperty('init', key, computed, key, false, true);\n    }\n\n    throwUnexpectedToken(lookahead);\n  }\n\n  function parseObjectInitializer() {\n    var properties = [],\n        hasProto = {\n      value: false\n    },\n        node = new Node();\n    expect('{');\n\n    while (!match('}')) {\n      properties.push(parseObjectProperty(hasProto));\n\n      if (!match('}')) {\n        expectCommaSeparator();\n      }\n    }\n\n    expect('}');\n    return node.finishObjectExpression(properties);\n  }\n\n  function reinterpretExpressionAsPattern(expr) {\n    var i;\n\n    switch (expr.type) {\n      case Syntax.Identifier:\n      case Syntax.MemberExpression:\n      case Syntax.RestElement:\n      case Syntax.AssignmentPattern:\n        break;\n\n      case Syntax.SpreadElement:\n        expr.type = Syntax.RestElement;\n        reinterpretExpressionAsPattern(expr.argument);\n        break;\n\n      case Syntax.ArrayExpression:\n        expr.type = Syntax.ArrayPattern;\n\n        for (i = 0; i < expr.elements.length; i++) {\n          if (expr.elements[i] !== null) {\n            reinterpretExpressionAsPattern(expr.elements[i]);\n          }\n        }\n\n        break;\n\n      case Syntax.ObjectExpression:\n        expr.type = Syntax.ObjectPattern;\n\n        for (i = 0; i < expr.properties.length; i++) {\n          reinterpretExpressionAsPattern(expr.properties[i].value);\n        }\n\n        break;\n\n      case Syntax.AssignmentExpression:\n        expr.type = Syntax.AssignmentPattern;\n        reinterpretExpressionAsPattern(expr.left);\n        break;\n\n      default:\n        // Allow other node type for tolerant parsing.\n        break;\n    }\n  } // ECMA-262 12.2.9 Template Literals\n\n\n  function parseTemplateElement(option) {\n    var node, token;\n\n    if (lookahead.type !== Token.Template || option.head && !lookahead.head) {\n      throwUnexpectedToken();\n    }\n\n    node = new Node();\n    token = lex();\n    return node.finishTemplateElement({\n      raw: token.value.raw,\n      cooked: token.value.cooked\n    }, token.tail);\n  }\n\n  function parseTemplateLiteral() {\n    var quasi,\n        quasis,\n        expressions,\n        node = new Node();\n    quasi = parseTemplateElement({\n      head: true\n    });\n    quasis = [quasi];\n    expressions = [];\n\n    while (!quasi.tail) {\n      expressions.push(parseExpression());\n      quasi = parseTemplateElement({\n        head: false\n      });\n      quasis.push(quasi);\n    }\n\n    return node.finishTemplateLiteral(quasis, expressions);\n  } // ECMA-262 12.2.10 The Grouping Operator\n\n\n  function parseGroupExpression() {\n    var expr,\n        expressions,\n        startToken,\n        i,\n        params = [];\n    expect('(');\n\n    if (match(')')) {\n      lex();\n\n      if (!match('=>')) {\n        expect('=>');\n      }\n\n      return {\n        type: PlaceHolders.ArrowParameterPlaceHolder,\n        params: [],\n        rawParams: []\n      };\n    }\n\n    startToken = lookahead;\n\n    if (match('...')) {\n      expr = parseRestElement(params);\n      expect(')');\n\n      if (!match('=>')) {\n        expect('=>');\n      }\n\n      return {\n        type: PlaceHolders.ArrowParameterPlaceHolder,\n        params: [expr]\n      };\n    }\n\n    isBindingElement = true;\n    expr = inheritCoverGrammar(parseAssignmentExpression);\n\n    if (match(',')) {\n      isAssignmentTarget = false;\n      expressions = [expr];\n\n      while (startIndex < length) {\n        if (!match(',')) {\n          break;\n        }\n\n        lex();\n\n        if (match('...')) {\n          if (!isBindingElement) {\n            throwUnexpectedToken(lookahead);\n          }\n\n          expressions.push(parseRestElement(params));\n          expect(')');\n\n          if (!match('=>')) {\n            expect('=>');\n          }\n\n          isBindingElement = false;\n\n          for (i = 0; i < expressions.length; i++) {\n            reinterpretExpressionAsPattern(expressions[i]);\n          }\n\n          return {\n            type: PlaceHolders.ArrowParameterPlaceHolder,\n            params: expressions\n          };\n        }\n\n        expressions.push(inheritCoverGrammar(parseAssignmentExpression));\n      }\n\n      expr = new WrappingNode(startToken).finishSequenceExpression(expressions);\n    }\n\n    expect(')');\n\n    if (match('=>')) {\n      if (expr.type === Syntax.Identifier && expr.name === 'yield') {\n        return {\n          type: PlaceHolders.ArrowParameterPlaceHolder,\n          params: [expr]\n        };\n      }\n\n      if (!isBindingElement) {\n        throwUnexpectedToken(lookahead);\n      }\n\n      if (expr.type === Syntax.SequenceExpression) {\n        for (i = 0; i < expr.expressions.length; i++) {\n          reinterpretExpressionAsPattern(expr.expressions[i]);\n        }\n      } else {\n        reinterpretExpressionAsPattern(expr);\n      }\n\n      expr = {\n        type: PlaceHolders.ArrowParameterPlaceHolder,\n        params: expr.type === Syntax.SequenceExpression ? expr.expressions : [expr]\n      };\n    }\n\n    isBindingElement = false;\n    return expr;\n  } // ECMA-262 12.2 Primary Expressions\n\n\n  function parsePrimaryExpression() {\n    var type, token, expr, node;\n\n    if (match('(')) {\n      isBindingElement = false;\n      return inheritCoverGrammar(parseGroupExpression);\n    }\n\n    if (match('[')) {\n      return inheritCoverGrammar(parseArrayInitializer);\n    }\n\n    if (match('{')) {\n      return inheritCoverGrammar(parseObjectInitializer);\n    }\n\n    type = lookahead.type;\n    node = new Node();\n\n    if (type === Token.Identifier) {\n      if (state.sourceType === 'module' && lookahead.value === 'await') {\n        tolerateUnexpectedToken(lookahead);\n      }\n\n      expr = node.finishIdentifier(lex().value);\n    } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n      isAssignmentTarget = isBindingElement = false;\n\n      if (strict && lookahead.octal) {\n        tolerateUnexpectedToken(lookahead, Messages.StrictOctalLiteral);\n      }\n\n      expr = node.finishLiteral(lex());\n    } else if (type === Token.Keyword) {\n      if (!strict && state.allowYield && matchKeyword('yield')) {\n        return parseNonComputedProperty();\n      }\n\n      if (!strict && matchKeyword('let')) {\n        return node.finishIdentifier(lex().value);\n      }\n\n      isAssignmentTarget = isBindingElement = false;\n\n      if (matchKeyword('function')) {\n        return parseFunctionExpression();\n      }\n\n      if (matchKeyword('this')) {\n        lex();\n        return node.finishThisExpression();\n      }\n\n      if (matchKeyword('class')) {\n        return parseClassExpression();\n      }\n\n      throwUnexpectedToken(lex());\n    } else if (type === Token.BooleanLiteral) {\n      isAssignmentTarget = isBindingElement = false;\n      token = lex();\n      token.value = token.value === 'true';\n      expr = node.finishLiteral(token);\n    } else if (type === Token.NullLiteral) {\n      isAssignmentTarget = isBindingElement = false;\n      token = lex();\n      token.value = null;\n      expr = node.finishLiteral(token);\n    } else if (match('/') || match('/=')) {\n      isAssignmentTarget = isBindingElement = false;\n      index = startIndex;\n\n      if (typeof extra.tokens !== 'undefined') {\n        token = collectRegex();\n      } else {\n        token = scanRegExp();\n      }\n\n      lex();\n      expr = node.finishLiteral(token);\n    } else if (type === Token.Template) {\n      expr = parseTemplateLiteral();\n    } else {\n      throwUnexpectedToken(lex());\n    }\n\n    return expr;\n  } // ECMA-262 12.3 Left-Hand-Side Expressions\n\n\n  function parseArguments() {\n    var args = [],\n        expr;\n    expect('(');\n\n    if (!match(')')) {\n      while (startIndex < length) {\n        if (match('...')) {\n          expr = new Node();\n          lex();\n          expr.finishSpreadElement(isolateCoverGrammar(parseAssignmentExpression));\n        } else {\n          expr = isolateCoverGrammar(parseAssignmentExpression);\n        }\n\n        args.push(expr);\n\n        if (match(')')) {\n          break;\n        }\n\n        expectCommaSeparator();\n      }\n    }\n\n    expect(')');\n    return args;\n  }\n\n  function parseNonComputedProperty() {\n    var token,\n        node = new Node();\n    token = lex();\n\n    if (!isIdentifierName(token)) {\n      throwUnexpectedToken(token);\n    }\n\n    return node.finishIdentifier(token.value);\n  }\n\n  function parseNonComputedMember() {\n    expect('.');\n    return parseNonComputedProperty();\n  }\n\n  function parseComputedMember() {\n    var expr;\n    expect('[');\n    expr = isolateCoverGrammar(parseExpression);\n    expect(']');\n    return expr;\n  } // ECMA-262 12.3.3 The new Operator\n\n\n  function parseNewExpression() {\n    var callee,\n        args,\n        node = new Node();\n    expectKeyword('new');\n\n    if (match('.')) {\n      lex();\n\n      if (lookahead.type === Token.Identifier && lookahead.value === 'target') {\n        if (state.inFunctionBody) {\n          lex();\n          return node.finishMetaProperty('new', 'target');\n        }\n      }\n\n      throwUnexpectedToken(lookahead);\n    }\n\n    callee = isolateCoverGrammar(parseLeftHandSideExpression);\n    args = match('(') ? parseArguments() : [];\n    isAssignmentTarget = isBindingElement = false;\n    return node.finishNewExpression(callee, args);\n  } // ECMA-262 12.3.4 Function Calls\n\n\n  function parseLeftHandSideExpressionAllowCall() {\n    var quasi,\n        expr,\n        args,\n        property,\n        startToken,\n        previousAllowIn = state.allowIn;\n    startToken = lookahead;\n    state.allowIn = true;\n\n    if (matchKeyword('super') && state.inFunctionBody) {\n      expr = new Node();\n      lex();\n      expr = expr.finishSuper();\n\n      if (!match('(') && !match('.') && !match('[')) {\n        throwUnexpectedToken(lookahead);\n      }\n    } else {\n      expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);\n    }\n\n    for (;;) {\n      if (match('.')) {\n        isBindingElement = false;\n        isAssignmentTarget = true;\n        property = parseNonComputedMember();\n        expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n      } else if (match('(')) {\n        isBindingElement = false;\n        isAssignmentTarget = false;\n        args = parseArguments();\n        expr = new WrappingNode(startToken).finishCallExpression(expr, args);\n      } else if (match('[')) {\n        isBindingElement = false;\n        isAssignmentTarget = true;\n        property = parseComputedMember();\n        expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n      } else if (lookahead.type === Token.Template && lookahead.head) {\n        quasi = parseTemplateLiteral();\n        expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);\n      } else {\n        break;\n      }\n    }\n\n    state.allowIn = previousAllowIn;\n    return expr;\n  } // ECMA-262 12.3 Left-Hand-Side Expressions\n\n\n  function parseLeftHandSideExpression() {\n    var quasi, expr, property, startToken;\n    assert(state.allowIn, 'callee of new expression always allow in keyword.');\n    startToken = lookahead;\n\n    if (matchKeyword('super') && state.inFunctionBody) {\n      expr = new Node();\n      lex();\n      expr = expr.finishSuper();\n\n      if (!match('[') && !match('.')) {\n        throwUnexpectedToken(lookahead);\n      }\n    } else {\n      expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);\n    }\n\n    for (;;) {\n      if (match('[')) {\n        isBindingElement = false;\n        isAssignmentTarget = true;\n        property = parseComputedMember();\n        expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n      } else if (match('.')) {\n        isBindingElement = false;\n        isAssignmentTarget = true;\n        property = parseNonComputedMember();\n        expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n      } else if (lookahead.type === Token.Template && lookahead.head) {\n        quasi = parseTemplateLiteral();\n        expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);\n      } else {\n        break;\n      }\n    }\n\n    return expr;\n  } // ECMA-262 12.4 Postfix Expressions\n\n\n  function parsePostfixExpression() {\n    var expr,\n        token,\n        startToken = lookahead;\n    expr = inheritCoverGrammar(parseLeftHandSideExpressionAllowCall);\n\n    if (!hasLineTerminator && lookahead.type === Token.Punctuator) {\n      if (match('++') || match('--')) {\n        // ECMA-262 11.3.1, 11.3.2\n        if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n          tolerateError(Messages.StrictLHSPostfix);\n        }\n\n        if (!isAssignmentTarget) {\n          tolerateError(Messages.InvalidLHSInAssignment);\n        }\n\n        isAssignmentTarget = isBindingElement = false;\n        token = lex();\n        expr = new WrappingNode(startToken).finishPostfixExpression(token.value, expr);\n      }\n    }\n\n    return expr;\n  } // ECMA-262 12.5 Unary Operators\n\n\n  function parseUnaryExpression() {\n    var token, expr, startToken;\n\n    if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n      expr = parsePostfixExpression();\n    } else if (match('++') || match('--')) {\n      startToken = lookahead;\n      token = lex();\n      expr = inheritCoverGrammar(parseUnaryExpression); // ECMA-262 11.4.4, 11.4.5\n\n      if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n        tolerateError(Messages.StrictLHSPrefix);\n      }\n\n      if (!isAssignmentTarget) {\n        tolerateError(Messages.InvalidLHSInAssignment);\n      }\n\n      expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n      isAssignmentTarget = isBindingElement = false;\n    } else if (match('+') || match('-') || match('~') || match('!')) {\n      startToken = lookahead;\n      token = lex();\n      expr = inheritCoverGrammar(parseUnaryExpression);\n      expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n      isAssignmentTarget = isBindingElement = false;\n    } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n      startToken = lookahead;\n      token = lex();\n      expr = inheritCoverGrammar(parseUnaryExpression);\n      expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n\n      if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {\n        tolerateError(Messages.StrictDelete);\n      }\n\n      isAssignmentTarget = isBindingElement = false;\n    } else {\n      expr = parsePostfixExpression();\n    }\n\n    return expr;\n  }\n\n  function binaryPrecedence(token, allowIn) {\n    var prec = 0;\n\n    if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n      return 0;\n    }\n\n    switch (token.value) {\n      case '||':\n        prec = 1;\n        break;\n\n      case '&&':\n        prec = 2;\n        break;\n\n      case '|':\n        prec = 3;\n        break;\n\n      case '^':\n        prec = 4;\n        break;\n\n      case '&':\n        prec = 5;\n        break;\n\n      case '==':\n      case '!=':\n      case '===':\n      case '!==':\n        prec = 6;\n        break;\n\n      case '<':\n      case '>':\n      case '<=':\n      case '>=':\n      case 'instanceof':\n        prec = 7;\n        break;\n\n      case 'in':\n        prec = allowIn ? 7 : 0;\n        break;\n\n      case '<<':\n      case '>>':\n      case '>>>':\n        prec = 8;\n        break;\n\n      case '+':\n      case '-':\n        prec = 9;\n        break;\n\n      case '*':\n      case '/':\n      case '%':\n        prec = 11;\n        break;\n\n      default:\n        break;\n    }\n\n    return prec;\n  } // ECMA-262 12.6 Multiplicative Operators\n  // ECMA-262 12.7 Additive Operators\n  // ECMA-262 12.8 Bitwise Shift Operators\n  // ECMA-262 12.9 Relational Operators\n  // ECMA-262 12.10 Equality Operators\n  // ECMA-262 12.11 Binary Bitwise Operators\n  // ECMA-262 12.12 Binary Logical Operators\n\n\n  function parseBinaryExpression() {\n    var marker, markers, expr, token, prec, stack, right, operator, left, i;\n    marker = lookahead;\n    left = inheritCoverGrammar(parseUnaryExpression);\n    token = lookahead;\n    prec = binaryPrecedence(token, state.allowIn);\n\n    if (prec === 0) {\n      return left;\n    }\n\n    isAssignmentTarget = isBindingElement = false;\n    token.prec = prec;\n    lex();\n    markers = [marker, lookahead];\n    right = isolateCoverGrammar(parseUnaryExpression);\n    stack = [left, token, right];\n\n    while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {\n      // Reduce: make a binary expression from the three topmost entries.\n      while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {\n        right = stack.pop();\n        operator = stack.pop().value;\n        left = stack.pop();\n        markers.pop();\n        expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);\n        stack.push(expr);\n      } // Shift.\n\n\n      token = lex();\n      token.prec = prec;\n      stack.push(token);\n      markers.push(lookahead);\n      expr = isolateCoverGrammar(parseUnaryExpression);\n      stack.push(expr);\n    } // Final reduce to clean-up the stack.\n\n\n    i = stack.length - 1;\n    expr = stack[i];\n    markers.pop();\n\n    while (i > 1) {\n      expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n      i -= 2;\n    }\n\n    return expr;\n  } // ECMA-262 12.13 Conditional Operator\n\n\n  function parseConditionalExpression() {\n    var expr, previousAllowIn, consequent, alternate, startToken;\n    startToken = lookahead;\n    expr = inheritCoverGrammar(parseBinaryExpression);\n\n    if (match('?')) {\n      lex();\n      previousAllowIn = state.allowIn;\n      state.allowIn = true;\n      consequent = isolateCoverGrammar(parseAssignmentExpression);\n      state.allowIn = previousAllowIn;\n      expect(':');\n      alternate = isolateCoverGrammar(parseAssignmentExpression);\n      expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);\n      isAssignmentTarget = isBindingElement = false;\n    }\n\n    return expr;\n  } // ECMA-262 14.2 Arrow Function Definitions\n\n\n  function parseConciseBody() {\n    if (match('{')) {\n      return parseFunctionSourceElements();\n    }\n\n    return isolateCoverGrammar(parseAssignmentExpression);\n  }\n\n  function checkPatternParam(options, param) {\n    var i;\n\n    switch (param.type) {\n      case Syntax.Identifier:\n        validateParam(options, param, param.name);\n        break;\n\n      case Syntax.RestElement:\n        checkPatternParam(options, param.argument);\n        break;\n\n      case Syntax.AssignmentPattern:\n        checkPatternParam(options, param.left);\n        break;\n\n      case Syntax.ArrayPattern:\n        for (i = 0; i < param.elements.length; i++) {\n          if (param.elements[i] !== null) {\n            checkPatternParam(options, param.elements[i]);\n          }\n        }\n\n        break;\n\n      case Syntax.YieldExpression:\n        break;\n\n      default:\n        assert(param.type === Syntax.ObjectPattern, 'Invalid type');\n\n        for (i = 0; i < param.properties.length; i++) {\n          checkPatternParam(options, param.properties[i].value);\n        }\n\n        break;\n    }\n  }\n\n  function reinterpretAsCoverFormalsList(expr) {\n    var i, len, param, params, defaults, defaultCount, options, token;\n    defaults = [];\n    defaultCount = 0;\n    params = [expr];\n\n    switch (expr.type) {\n      case Syntax.Identifier:\n        break;\n\n      case PlaceHolders.ArrowParameterPlaceHolder:\n        params = expr.params;\n        break;\n\n      default:\n        return null;\n    }\n\n    options = {\n      paramSet: {}\n    };\n\n    for (i = 0, len = params.length; i < len; i += 1) {\n      param = params[i];\n\n      switch (param.type) {\n        case Syntax.AssignmentPattern:\n          params[i] = param.left;\n\n          if (param.right.type === Syntax.YieldExpression) {\n            if (param.right.argument) {\n              throwUnexpectedToken(lookahead);\n            }\n\n            param.right.type = Syntax.Identifier;\n            param.right.name = 'yield';\n            delete param.right.argument;\n            delete param.right.delegate;\n          }\n\n          defaults.push(param.right);\n          ++defaultCount;\n          checkPatternParam(options, param.left);\n          break;\n\n        default:\n          checkPatternParam(options, param);\n          params[i] = param;\n          defaults.push(null);\n          break;\n      }\n    }\n\n    if (strict || !state.allowYield) {\n      for (i = 0, len = params.length; i < len; i += 1) {\n        param = params[i];\n\n        if (param.type === Syntax.YieldExpression) {\n          throwUnexpectedToken(lookahead);\n        }\n      }\n    }\n\n    if (options.message === Messages.StrictParamDupe) {\n      token = strict ? options.stricted : options.firstRestricted;\n      throwUnexpectedToken(token, options.message);\n    }\n\n    if (defaultCount === 0) {\n      defaults = [];\n    }\n\n    return {\n      params: params,\n      defaults: defaults,\n      stricted: options.stricted,\n      firstRestricted: options.firstRestricted,\n      message: options.message\n    };\n  }\n\n  function parseArrowFunctionExpression(options, node) {\n    var previousStrict, previousAllowYield, body;\n\n    if (hasLineTerminator) {\n      tolerateUnexpectedToken(lookahead);\n    }\n\n    expect('=>');\n    previousStrict = strict;\n    previousAllowYield = state.allowYield;\n    state.allowYield = true;\n    body = parseConciseBody();\n\n    if (strict && options.firstRestricted) {\n      throwUnexpectedToken(options.firstRestricted, options.message);\n    }\n\n    if (strict && options.stricted) {\n      tolerateUnexpectedToken(options.stricted, options.message);\n    }\n\n    strict = previousStrict;\n    state.allowYield = previousAllowYield;\n    return node.finishArrowFunctionExpression(options.params, options.defaults, body, body.type !== Syntax.BlockStatement);\n  } // ECMA-262 14.4 Yield expression\n\n\n  function parseYieldExpression() {\n    var argument, expr, delegate, previousAllowYield;\n    argument = null;\n    expr = new Node();\n    delegate = false;\n    expectKeyword('yield');\n\n    if (!hasLineTerminator) {\n      previousAllowYield = state.allowYield;\n      state.allowYield = false;\n      delegate = match('*');\n\n      if (delegate) {\n        lex();\n        argument = parseAssignmentExpression();\n      } else {\n        if (!match(';') && !match('}') && !match(')') && lookahead.type !== Token.EOF) {\n          argument = parseAssignmentExpression();\n        }\n      }\n\n      state.allowYield = previousAllowYield;\n    }\n\n    return expr.finishYieldExpression(argument, delegate);\n  } // ECMA-262 12.14 Assignment Operators\n\n\n  function parseAssignmentExpression() {\n    var token, expr, right, list, startToken;\n    startToken = lookahead;\n    token = lookahead;\n\n    if (!state.allowYield && matchKeyword('yield')) {\n      return parseYieldExpression();\n    }\n\n    expr = parseConditionalExpression();\n\n    if (expr.type === PlaceHolders.ArrowParameterPlaceHolder || match('=>')) {\n      isAssignmentTarget = isBindingElement = false;\n      list = reinterpretAsCoverFormalsList(expr);\n\n      if (list) {\n        firstCoverInitializedNameError = null;\n        return parseArrowFunctionExpression(list, new WrappingNode(startToken));\n      }\n\n      return expr;\n    }\n\n    if (matchAssign()) {\n      if (!isAssignmentTarget) {\n        tolerateError(Messages.InvalidLHSInAssignment);\n      } // ECMA-262 12.1.1\n\n\n      if (strict && expr.type === Syntax.Identifier) {\n        if (isRestrictedWord(expr.name)) {\n          tolerateUnexpectedToken(token, Messages.StrictLHSAssignment);\n        }\n\n        if (isStrictModeReservedWord(expr.name)) {\n          tolerateUnexpectedToken(token, Messages.StrictReservedWord);\n        }\n      }\n\n      if (!match('=')) {\n        isAssignmentTarget = isBindingElement = false;\n      } else {\n        reinterpretExpressionAsPattern(expr);\n      }\n\n      token = lex();\n      right = isolateCoverGrammar(parseAssignmentExpression);\n      expr = new WrappingNode(startToken).finishAssignmentExpression(token.value, expr, right);\n      firstCoverInitializedNameError = null;\n    }\n\n    return expr;\n  } // ECMA-262 12.15 Comma Operator\n\n\n  function parseExpression() {\n    var expr,\n        startToken = lookahead,\n        expressions;\n    expr = isolateCoverGrammar(parseAssignmentExpression);\n\n    if (match(',')) {\n      expressions = [expr];\n\n      while (startIndex < length) {\n        if (!match(',')) {\n          break;\n        }\n\n        lex();\n        expressions.push(isolateCoverGrammar(parseAssignmentExpression));\n      }\n\n      expr = new WrappingNode(startToken).finishSequenceExpression(expressions);\n    }\n\n    return expr;\n  } // ECMA-262 13.2 Block\n\n\n  function parseStatementListItem() {\n    if (lookahead.type === Token.Keyword) {\n      switch (lookahead.value) {\n        case 'export':\n          if (state.sourceType !== 'module') {\n            tolerateUnexpectedToken(lookahead, Messages.IllegalExportDeclaration);\n          }\n\n          return parseExportDeclaration();\n\n        case 'import':\n          if (state.sourceType !== 'module') {\n            tolerateUnexpectedToken(lookahead, Messages.IllegalImportDeclaration);\n          }\n\n          return parseImportDeclaration();\n\n        case 'const':\n          return parseLexicalDeclaration({\n            inFor: false\n          });\n\n        case 'function':\n          return parseFunctionDeclaration(new Node());\n\n        case 'class':\n          return parseClassDeclaration();\n      }\n    }\n\n    if (matchKeyword('let') && isLexicalDeclaration()) {\n      return parseLexicalDeclaration({\n        inFor: false\n      });\n    }\n\n    return parseStatement();\n  }\n\n  function parseStatementList() {\n    var list = [];\n\n    while (startIndex < length) {\n      if (match('}')) {\n        break;\n      }\n\n      list.push(parseStatementListItem());\n    }\n\n    return list;\n  }\n\n  function parseBlock() {\n    var block,\n        node = new Node();\n    expect('{');\n    block = parseStatementList();\n    expect('}');\n    return node.finishBlockStatement(block);\n  } // ECMA-262 13.3.2 Variable Statement\n\n\n  function parseVariableIdentifier(kind) {\n    var token,\n        node = new Node();\n    token = lex();\n\n    if (token.type === Token.Keyword && token.value === 'yield') {\n      if (strict) {\n        tolerateUnexpectedToken(token, Messages.StrictReservedWord);\n      }\n\n      if (!state.allowYield) {\n        throwUnexpectedToken(token);\n      }\n    } else if (token.type !== Token.Identifier) {\n      if (strict && token.type === Token.Keyword && isStrictModeReservedWord(token.value)) {\n        tolerateUnexpectedToken(token, Messages.StrictReservedWord);\n      } else {\n        if (strict || token.value !== 'let' || kind !== 'var') {\n          throwUnexpectedToken(token);\n        }\n      }\n    } else if (state.sourceType === 'module' && token.type === Token.Identifier && token.value === 'await') {\n      tolerateUnexpectedToken(token);\n    }\n\n    return node.finishIdentifier(token.value);\n  }\n\n  function parseVariableDeclaration(options) {\n    var init = null,\n        id,\n        node = new Node(),\n        params = [];\n    id = parsePattern(params, 'var'); // ECMA-262 12.2.1\n\n    if (strict && isRestrictedWord(id.name)) {\n      tolerateError(Messages.StrictVarName);\n    }\n\n    if (match('=')) {\n      lex();\n      init = isolateCoverGrammar(parseAssignmentExpression);\n    } else if (id.type !== Syntax.Identifier && !options.inFor) {\n      expect('=');\n    }\n\n    return node.finishVariableDeclarator(id, init);\n  }\n\n  function parseVariableDeclarationList(options) {\n    var opt, list;\n    opt = {\n      inFor: options.inFor\n    };\n    list = [parseVariableDeclaration(opt)];\n\n    while (match(',')) {\n      lex();\n      list.push(parseVariableDeclaration(opt));\n    }\n\n    return list;\n  }\n\n  function parseVariableStatement(node) {\n    var declarations;\n    expectKeyword('var');\n    declarations = parseVariableDeclarationList({\n      inFor: false\n    });\n    consumeSemicolon();\n    return node.finishVariableDeclaration(declarations);\n  } // ECMA-262 13.3.1 Let and Const Declarations\n\n\n  function parseLexicalBinding(kind, options) {\n    var init = null,\n        id,\n        node = new Node(),\n        params = [];\n    id = parsePattern(params, kind); // ECMA-262 12.2.1\n\n    if (strict && id.type === Syntax.Identifier && isRestrictedWord(id.name)) {\n      tolerateError(Messages.StrictVarName);\n    }\n\n    if (kind === 'const') {\n      if (!matchKeyword('in') && !matchContextualKeyword('of')) {\n        expect('=');\n        init = isolateCoverGrammar(parseAssignmentExpression);\n      }\n    } else if (!options.inFor && id.type !== Syntax.Identifier || match('=')) {\n      expect('=');\n      init = isolateCoverGrammar(parseAssignmentExpression);\n    }\n\n    return node.finishVariableDeclarator(id, init);\n  }\n\n  function parseBindingList(kind, options) {\n    var list = [parseLexicalBinding(kind, options)];\n\n    while (match(',')) {\n      lex();\n      list.push(parseLexicalBinding(kind, options));\n    }\n\n    return list;\n  }\n\n  function tokenizerState() {\n    return {\n      index: index,\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      hasLineTerminator: hasLineTerminator,\n      lastIndex: lastIndex,\n      lastLineNumber: lastLineNumber,\n      lastLineStart: lastLineStart,\n      startIndex: startIndex,\n      startLineNumber: startLineNumber,\n      startLineStart: startLineStart,\n      lookahead: lookahead,\n      tokenCount: extra.tokens ? extra.tokens.length : 0\n    };\n  }\n\n  function resetTokenizerState(ts) {\n    index = ts.index;\n    lineNumber = ts.lineNumber;\n    lineStart = ts.lineStart;\n    hasLineTerminator = ts.hasLineTerminator;\n    lastIndex = ts.lastIndex;\n    lastLineNumber = ts.lastLineNumber;\n    lastLineStart = ts.lastLineStart;\n    startIndex = ts.startIndex;\n    startLineNumber = ts.startLineNumber;\n    startLineStart = ts.startLineStart;\n    lookahead = ts.lookahead;\n\n    if (extra.tokens) {\n      extra.tokens.splice(ts.tokenCount, extra.tokens.length);\n    }\n  }\n\n  function isLexicalDeclaration() {\n    var lexical, ts;\n    ts = tokenizerState();\n    lex();\n    lexical = lookahead.type === Token.Identifier || match('[') || match('{') || matchKeyword('let') || matchKeyword('yield');\n    resetTokenizerState(ts);\n    return lexical;\n  }\n\n  function parseLexicalDeclaration(options) {\n    var kind,\n        declarations,\n        node = new Node();\n    kind = lex().value;\n    assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');\n    declarations = parseBindingList(kind, options);\n    consumeSemicolon();\n    return node.finishLexicalDeclaration(declarations, kind);\n  }\n\n  function parseRestElement(params) {\n    var param,\n        node = new Node();\n    lex();\n\n    if (match('{')) {\n      throwError(Messages.ObjectPatternAsRestParameter);\n    }\n\n    params.push(lookahead);\n    param = parseVariableIdentifier();\n\n    if (match('=')) {\n      throwError(Messages.DefaultRestParameter);\n    }\n\n    if (!match(')')) {\n      throwError(Messages.ParameterAfterRestParameter);\n    }\n\n    return node.finishRestElement(param);\n  } // ECMA-262 13.4 Empty Statement\n\n\n  function parseEmptyStatement(node) {\n    expect(';');\n    return node.finishEmptyStatement();\n  } // ECMA-262 12.4 Expression Statement\n\n\n  function parseExpressionStatement(node) {\n    var expr = parseExpression();\n    consumeSemicolon();\n    return node.finishExpressionStatement(expr);\n  } // ECMA-262 13.6 If statement\n\n\n  function parseIfStatement(node) {\n    var test, consequent, alternate;\n    expectKeyword('if');\n    expect('(');\n    test = parseExpression();\n    expect(')');\n    consequent = parseStatement();\n\n    if (matchKeyword('else')) {\n      lex();\n      alternate = parseStatement();\n    } else {\n      alternate = null;\n    }\n\n    return node.finishIfStatement(test, consequent, alternate);\n  } // ECMA-262 13.7 Iteration Statements\n\n\n  function parseDoWhileStatement(node) {\n    var body, test, oldInIteration;\n    expectKeyword('do');\n    oldInIteration = state.inIteration;\n    state.inIteration = true;\n    body = parseStatement();\n    state.inIteration = oldInIteration;\n    expectKeyword('while');\n    expect('(');\n    test = parseExpression();\n    expect(')');\n\n    if (match(';')) {\n      lex();\n    }\n\n    return node.finishDoWhileStatement(body, test);\n  }\n\n  function parseWhileStatement(node) {\n    var test, body, oldInIteration;\n    expectKeyword('while');\n    expect('(');\n    test = parseExpression();\n    expect(')');\n    oldInIteration = state.inIteration;\n    state.inIteration = true;\n    body = parseStatement();\n    state.inIteration = oldInIteration;\n    return node.finishWhileStatement(test, body);\n  }\n\n  function parseForStatement(node) {\n    var init,\n        forIn,\n        initSeq,\n        initStartToken,\n        test,\n        update,\n        left,\n        right,\n        kind,\n        declarations,\n        body,\n        oldInIteration,\n        previousAllowIn = state.allowIn;\n    init = test = update = null;\n    forIn = true;\n    expectKeyword('for');\n    expect('(');\n\n    if (match(';')) {\n      lex();\n    } else {\n      if (matchKeyword('var')) {\n        init = new Node();\n        lex();\n        state.allowIn = false;\n        declarations = parseVariableDeclarationList({\n          inFor: true\n        });\n        state.allowIn = previousAllowIn;\n\n        if (declarations.length === 1 && matchKeyword('in')) {\n          init = init.finishVariableDeclaration(declarations);\n          lex();\n          left = init;\n          right = parseExpression();\n          init = null;\n        } else if (declarations.length === 1 && declarations[0].init === null && matchContextualKeyword('of')) {\n          init = init.finishVariableDeclaration(declarations);\n          lex();\n          left = init;\n          right = parseAssignmentExpression();\n          init = null;\n          forIn = false;\n        } else {\n          init = init.finishVariableDeclaration(declarations);\n          expect(';');\n        }\n      } else if (matchKeyword('const') || matchKeyword('let')) {\n        init = new Node();\n        kind = lex().value;\n\n        if (!strict && lookahead.value === 'in') {\n          init = init.finishIdentifier(kind);\n          lex();\n          left = init;\n          right = parseExpression();\n          init = null;\n        } else {\n          state.allowIn = false;\n          declarations = parseBindingList(kind, {\n            inFor: true\n          });\n          state.allowIn = previousAllowIn;\n\n          if (declarations.length === 1 && declarations[0].init === null && matchKeyword('in')) {\n            init = init.finishLexicalDeclaration(declarations, kind);\n            lex();\n            left = init;\n            right = parseExpression();\n            init = null;\n          } else if (declarations.length === 1 && declarations[0].init === null && matchContextualKeyword('of')) {\n            init = init.finishLexicalDeclaration(declarations, kind);\n            lex();\n            left = init;\n            right = parseAssignmentExpression();\n            init = null;\n            forIn = false;\n          } else {\n            consumeSemicolon();\n            init = init.finishLexicalDeclaration(declarations, kind);\n          }\n        }\n      } else {\n        initStartToken = lookahead;\n        state.allowIn = false;\n        init = inheritCoverGrammar(parseAssignmentExpression);\n        state.allowIn = previousAllowIn;\n\n        if (matchKeyword('in')) {\n          if (!isAssignmentTarget) {\n            tolerateError(Messages.InvalidLHSInForIn);\n          }\n\n          lex();\n          reinterpretExpressionAsPattern(init);\n          left = init;\n          right = parseExpression();\n          init = null;\n        } else if (matchContextualKeyword('of')) {\n          if (!isAssignmentTarget) {\n            tolerateError(Messages.InvalidLHSInForLoop);\n          }\n\n          lex();\n          reinterpretExpressionAsPattern(init);\n          left = init;\n          right = parseAssignmentExpression();\n          init = null;\n          forIn = false;\n        } else {\n          if (match(',')) {\n            initSeq = [init];\n\n            while (match(',')) {\n              lex();\n              initSeq.push(isolateCoverGrammar(parseAssignmentExpression));\n            }\n\n            init = new WrappingNode(initStartToken).finishSequenceExpression(initSeq);\n          }\n\n          expect(';');\n        }\n      }\n    }\n\n    if (typeof left === 'undefined') {\n      if (!match(';')) {\n        test = parseExpression();\n      }\n\n      expect(';');\n\n      if (!match(')')) {\n        update = parseExpression();\n      }\n    }\n\n    expect(')');\n    oldInIteration = state.inIteration;\n    state.inIteration = true;\n    body = isolateCoverGrammar(parseStatement);\n    state.inIteration = oldInIteration;\n    return typeof left === 'undefined' ? node.finishForStatement(init, test, update, body) : forIn ? node.finishForInStatement(left, right, body) : node.finishForOfStatement(left, right, body);\n  } // ECMA-262 13.8 The continue statement\n\n\n  function parseContinueStatement(node) {\n    var label = null,\n        key;\n    expectKeyword('continue'); // Optimize the most common form: 'continue;'.\n\n    if (source.charCodeAt(startIndex) === 0x3B) {\n      lex();\n\n      if (!state.inIteration) {\n        throwError(Messages.IllegalContinue);\n      }\n\n      return node.finishContinueStatement(null);\n    }\n\n    if (hasLineTerminator) {\n      if (!state.inIteration) {\n        throwError(Messages.IllegalContinue);\n      }\n\n      return node.finishContinueStatement(null);\n    }\n\n    if (lookahead.type === Token.Identifier) {\n      label = parseVariableIdentifier();\n      key = '$' + label.name;\n\n      if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n        throwError(Messages.UnknownLabel, label.name);\n      }\n    }\n\n    consumeSemicolon();\n\n    if (label === null && !state.inIteration) {\n      throwError(Messages.IllegalContinue);\n    }\n\n    return node.finishContinueStatement(label);\n  } // ECMA-262 13.9 The break statement\n\n\n  function parseBreakStatement(node) {\n    var label = null,\n        key;\n    expectKeyword('break'); // Catch the very common case first: immediately a semicolon (U+003B).\n\n    if (source.charCodeAt(lastIndex) === 0x3B) {\n      lex();\n\n      if (!(state.inIteration || state.inSwitch)) {\n        throwError(Messages.IllegalBreak);\n      }\n\n      return node.finishBreakStatement(null);\n    }\n\n    if (hasLineTerminator) {\n      if (!(state.inIteration || state.inSwitch)) {\n        throwError(Messages.IllegalBreak);\n      }\n    } else if (lookahead.type === Token.Identifier) {\n      label = parseVariableIdentifier();\n      key = '$' + label.name;\n\n      if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n        throwError(Messages.UnknownLabel, label.name);\n      }\n    }\n\n    consumeSemicolon();\n\n    if (label === null && !(state.inIteration || state.inSwitch)) {\n      throwError(Messages.IllegalBreak);\n    }\n\n    return node.finishBreakStatement(label);\n  } // ECMA-262 13.10 The return statement\n\n\n  function parseReturnStatement(node) {\n    var argument = null;\n    expectKeyword('return');\n\n    if (!state.inFunctionBody) {\n      tolerateError(Messages.IllegalReturn);\n    } // 'return' followed by a space and an identifier is very common.\n\n\n    if (source.charCodeAt(lastIndex) === 0x20) {\n      if (isIdentifierStart(source.charCodeAt(lastIndex + 1))) {\n        argument = parseExpression();\n        consumeSemicolon();\n        return node.finishReturnStatement(argument);\n      }\n    }\n\n    if (hasLineTerminator) {\n      // HACK\n      return node.finishReturnStatement(null);\n    }\n\n    if (!match(';')) {\n      if (!match('}') && lookahead.type !== Token.EOF) {\n        argument = parseExpression();\n      }\n    }\n\n    consumeSemicolon();\n    return node.finishReturnStatement(argument);\n  } // ECMA-262 13.11 The with statement\n\n\n  function parseWithStatement(node) {\n    var object, body;\n\n    if (strict) {\n      tolerateError(Messages.StrictModeWith);\n    }\n\n    expectKeyword('with');\n    expect('(');\n    object = parseExpression();\n    expect(')');\n    body = parseStatement();\n    return node.finishWithStatement(object, body);\n  } // ECMA-262 13.12 The switch statement\n\n\n  function parseSwitchCase() {\n    var test,\n        consequent = [],\n        statement,\n        node = new Node();\n\n    if (matchKeyword('default')) {\n      lex();\n      test = null;\n    } else {\n      expectKeyword('case');\n      test = parseExpression();\n    }\n\n    expect(':');\n\n    while (startIndex < length) {\n      if (match('}') || matchKeyword('default') || matchKeyword('case')) {\n        break;\n      }\n\n      statement = parseStatementListItem();\n      consequent.push(statement);\n    }\n\n    return node.finishSwitchCase(test, consequent);\n  }\n\n  function parseSwitchStatement(node) {\n    var discriminant, cases, clause, oldInSwitch, defaultFound;\n    expectKeyword('switch');\n    expect('(');\n    discriminant = parseExpression();\n    expect(')');\n    expect('{');\n    cases = [];\n\n    if (match('}')) {\n      lex();\n      return node.finishSwitchStatement(discriminant, cases);\n    }\n\n    oldInSwitch = state.inSwitch;\n    state.inSwitch = true;\n    defaultFound = false;\n\n    while (startIndex < length) {\n      if (match('}')) {\n        break;\n      }\n\n      clause = parseSwitchCase();\n\n      if (clause.test === null) {\n        if (defaultFound) {\n          throwError(Messages.MultipleDefaultsInSwitch);\n        }\n\n        defaultFound = true;\n      }\n\n      cases.push(clause);\n    }\n\n    state.inSwitch = oldInSwitch;\n    expect('}');\n    return node.finishSwitchStatement(discriminant, cases);\n  } // ECMA-262 13.14 The throw statement\n\n\n  function parseThrowStatement(node) {\n    var argument;\n    expectKeyword('throw');\n\n    if (hasLineTerminator) {\n      throwError(Messages.NewlineAfterThrow);\n    }\n\n    argument = parseExpression();\n    consumeSemicolon();\n    return node.finishThrowStatement(argument);\n  } // ECMA-262 13.15 The try statement\n\n\n  function parseCatchClause() {\n    var param,\n        params = [],\n        paramMap = {},\n        key,\n        i,\n        body,\n        node = new Node();\n    expectKeyword('catch');\n    expect('(');\n\n    if (match(')')) {\n      throwUnexpectedToken(lookahead);\n    }\n\n    param = parsePattern(params);\n\n    for (i = 0; i < params.length; i++) {\n      key = '$' + params[i].value;\n\n      if (Object.prototype.hasOwnProperty.call(paramMap, key)) {\n        tolerateError(Messages.DuplicateBinding, params[i].value);\n      }\n\n      paramMap[key] = true;\n    } // ECMA-262 12.14.1\n\n\n    if (strict && isRestrictedWord(param.name)) {\n      tolerateError(Messages.StrictCatchVariable);\n    }\n\n    expect(')');\n    body = parseBlock();\n    return node.finishCatchClause(param, body);\n  }\n\n  function parseTryStatement(node) {\n    var block,\n        handler = null,\n        finalizer = null;\n    expectKeyword('try');\n    block = parseBlock();\n\n    if (matchKeyword('catch')) {\n      handler = parseCatchClause();\n    }\n\n    if (matchKeyword('finally')) {\n      lex();\n      finalizer = parseBlock();\n    }\n\n    if (!handler && !finalizer) {\n      throwError(Messages.NoCatchOrFinally);\n    }\n\n    return node.finishTryStatement(block, handler, finalizer);\n  } // ECMA-262 13.16 The debugger statement\n\n\n  function parseDebuggerStatement(node) {\n    expectKeyword('debugger');\n    consumeSemicolon();\n    return node.finishDebuggerStatement();\n  } // 13 Statements\n\n\n  function parseStatement() {\n    var type = lookahead.type,\n        expr,\n        labeledBody,\n        key,\n        node;\n\n    if (type === Token.EOF) {\n      throwUnexpectedToken(lookahead);\n    }\n\n    if (type === Token.Punctuator && lookahead.value === '{') {\n      return parseBlock();\n    }\n\n    isAssignmentTarget = isBindingElement = true;\n    node = new Node();\n\n    if (type === Token.Punctuator) {\n      switch (lookahead.value) {\n        case ';':\n          return parseEmptyStatement(node);\n\n        case '(':\n          return parseExpressionStatement(node);\n\n        default:\n          break;\n      }\n    } else if (type === Token.Keyword) {\n      switch (lookahead.value) {\n        case 'break':\n          return parseBreakStatement(node);\n\n        case 'continue':\n          return parseContinueStatement(node);\n\n        case 'debugger':\n          return parseDebuggerStatement(node);\n\n        case 'do':\n          return parseDoWhileStatement(node);\n\n        case 'for':\n          return parseForStatement(node);\n\n        case 'function':\n          return parseFunctionDeclaration(node);\n\n        case 'if':\n          return parseIfStatement(node);\n\n        case 'return':\n          return parseReturnStatement(node);\n\n        case 'switch':\n          return parseSwitchStatement(node);\n\n        case 'throw':\n          return parseThrowStatement(node);\n\n        case 'try':\n          return parseTryStatement(node);\n\n        case 'var':\n          return parseVariableStatement(node);\n\n        case 'while':\n          return parseWhileStatement(node);\n\n        case 'with':\n          return parseWithStatement(node);\n\n        default:\n          break;\n      }\n    }\n\n    expr = parseExpression(); // ECMA-262 12.12 Labelled Statements\n\n    if (expr.type === Syntax.Identifier && match(':')) {\n      lex();\n      key = '$' + expr.name;\n\n      if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n        throwError(Messages.Redeclaration, 'Label', expr.name);\n      }\n\n      state.labelSet[key] = true;\n      labeledBody = parseStatement();\n      delete state.labelSet[key];\n      return node.finishLabeledStatement(expr, labeledBody);\n    }\n\n    consumeSemicolon();\n    return node.finishExpressionStatement(expr);\n  } // ECMA-262 14.1 Function Definition\n\n\n  function parseFunctionSourceElements() {\n    var statement,\n        body = [],\n        token,\n        directive,\n        firstRestricted,\n        oldLabelSet,\n        oldInIteration,\n        oldInSwitch,\n        oldInFunctionBody,\n        node = new Node();\n    expect('{');\n\n    while (startIndex < length) {\n      if (lookahead.type !== Token.StringLiteral) {\n        break;\n      }\n\n      token = lookahead;\n      statement = parseStatementListItem();\n      body.push(statement);\n\n      if (statement.expression.type !== Syntax.Literal) {\n        // this is not directive\n        break;\n      }\n\n      directive = source.slice(token.start + 1, token.end - 1);\n\n      if (directive === 'use strict') {\n        strict = true;\n\n        if (firstRestricted) {\n          tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);\n        }\n      } else {\n        if (!firstRestricted && token.octal) {\n          firstRestricted = token;\n        }\n      }\n    }\n\n    oldLabelSet = state.labelSet;\n    oldInIteration = state.inIteration;\n    oldInSwitch = state.inSwitch;\n    oldInFunctionBody = state.inFunctionBody;\n    state.labelSet = {};\n    state.inIteration = false;\n    state.inSwitch = false;\n    state.inFunctionBody = true;\n\n    while (startIndex < length) {\n      if (match('}')) {\n        break;\n      }\n\n      body.push(parseStatementListItem());\n    }\n\n    expect('}');\n    state.labelSet = oldLabelSet;\n    state.inIteration = oldInIteration;\n    state.inSwitch = oldInSwitch;\n    state.inFunctionBody = oldInFunctionBody;\n    return node.finishBlockStatement(body);\n  }\n\n  function validateParam(options, param, name) {\n    var key = '$' + name;\n\n    if (strict) {\n      if (isRestrictedWord(name)) {\n        options.stricted = param;\n        options.message = Messages.StrictParamName;\n      }\n\n      if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {\n        options.stricted = param;\n        options.message = Messages.StrictParamDupe;\n      }\n    } else if (!options.firstRestricted) {\n      if (isRestrictedWord(name)) {\n        options.firstRestricted = param;\n        options.message = Messages.StrictParamName;\n      } else if (isStrictModeReservedWord(name)) {\n        options.firstRestricted = param;\n        options.message = Messages.StrictReservedWord;\n      } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {\n        options.stricted = param;\n        options.message = Messages.StrictParamDupe;\n      }\n    }\n\n    options.paramSet[key] = true;\n  }\n\n  function parseParam(options) {\n    var token,\n        param,\n        params = [],\n        i,\n        def;\n    token = lookahead;\n\n    if (token.value === '...') {\n      param = parseRestElement(params);\n      validateParam(options, param.argument, param.argument.name);\n      options.params.push(param);\n      options.defaults.push(null);\n      return false;\n    }\n\n    param = parsePatternWithDefault(params);\n\n    for (i = 0; i < params.length; i++) {\n      validateParam(options, params[i], params[i].value);\n    }\n\n    if (param.type === Syntax.AssignmentPattern) {\n      def = param.right;\n      param = param.left;\n      ++options.defaultCount;\n    }\n\n    options.params.push(param);\n    options.defaults.push(def);\n    return !match(')');\n  }\n\n  function parseParams(firstRestricted) {\n    var options;\n    options = {\n      params: [],\n      defaultCount: 0,\n      defaults: [],\n      firstRestricted: firstRestricted\n    };\n    expect('(');\n\n    if (!match(')')) {\n      options.paramSet = {};\n\n      while (startIndex < length) {\n        if (!parseParam(options)) {\n          break;\n        }\n\n        expect(',');\n      }\n    }\n\n    expect(')');\n\n    if (options.defaultCount === 0) {\n      options.defaults = [];\n    }\n\n    return {\n      params: options.params,\n      defaults: options.defaults,\n      stricted: options.stricted,\n      firstRestricted: options.firstRestricted,\n      message: options.message\n    };\n  }\n\n  function parseFunctionDeclaration(node, identifierIsOptional) {\n    var id = null,\n        params = [],\n        defaults = [],\n        body,\n        token,\n        stricted,\n        tmp,\n        firstRestricted,\n        message,\n        previousStrict,\n        isGenerator,\n        previousAllowYield;\n    previousAllowYield = state.allowYield;\n    expectKeyword('function');\n    isGenerator = match('*');\n\n    if (isGenerator) {\n      lex();\n    }\n\n    if (!identifierIsOptional || !match('(')) {\n      token = lookahead;\n      id = parseVariableIdentifier();\n\n      if (strict) {\n        if (isRestrictedWord(token.value)) {\n          tolerateUnexpectedToken(token, Messages.StrictFunctionName);\n        }\n      } else {\n        if (isRestrictedWord(token.value)) {\n          firstRestricted = token;\n          message = Messages.StrictFunctionName;\n        } else if (isStrictModeReservedWord(token.value)) {\n          firstRestricted = token;\n          message = Messages.StrictReservedWord;\n        }\n      }\n    }\n\n    state.allowYield = !isGenerator;\n    tmp = parseParams(firstRestricted);\n    params = tmp.params;\n    defaults = tmp.defaults;\n    stricted = tmp.stricted;\n    firstRestricted = tmp.firstRestricted;\n\n    if (tmp.message) {\n      message = tmp.message;\n    }\n\n    previousStrict = strict;\n    body = parseFunctionSourceElements();\n\n    if (strict && firstRestricted) {\n      throwUnexpectedToken(firstRestricted, message);\n    }\n\n    if (strict && stricted) {\n      tolerateUnexpectedToken(stricted, message);\n    }\n\n    strict = previousStrict;\n    state.allowYield = previousAllowYield;\n    return node.finishFunctionDeclaration(id, params, defaults, body, isGenerator);\n  }\n\n  function parseFunctionExpression() {\n    var token,\n        id = null,\n        stricted,\n        firstRestricted,\n        message,\n        tmp,\n        params = [],\n        defaults = [],\n        body,\n        previousStrict,\n        node = new Node(),\n        isGenerator,\n        previousAllowYield;\n    previousAllowYield = state.allowYield;\n    expectKeyword('function');\n    isGenerator = match('*');\n\n    if (isGenerator) {\n      lex();\n    }\n\n    state.allowYield = !isGenerator;\n\n    if (!match('(')) {\n      token = lookahead;\n      id = !strict && !isGenerator && matchKeyword('yield') ? parseNonComputedProperty() : parseVariableIdentifier();\n\n      if (strict) {\n        if (isRestrictedWord(token.value)) {\n          tolerateUnexpectedToken(token, Messages.StrictFunctionName);\n        }\n      } else {\n        if (isRestrictedWord(token.value)) {\n          firstRestricted = token;\n          message = Messages.StrictFunctionName;\n        } else if (isStrictModeReservedWord(token.value)) {\n          firstRestricted = token;\n          message = Messages.StrictReservedWord;\n        }\n      }\n    }\n\n    tmp = parseParams(firstRestricted);\n    params = tmp.params;\n    defaults = tmp.defaults;\n    stricted = tmp.stricted;\n    firstRestricted = tmp.firstRestricted;\n\n    if (tmp.message) {\n      message = tmp.message;\n    }\n\n    previousStrict = strict;\n    body = parseFunctionSourceElements();\n\n    if (strict && firstRestricted) {\n      throwUnexpectedToken(firstRestricted, message);\n    }\n\n    if (strict && stricted) {\n      tolerateUnexpectedToken(stricted, message);\n    }\n\n    strict = previousStrict;\n    state.allowYield = previousAllowYield;\n    return node.finishFunctionExpression(id, params, defaults, body, isGenerator);\n  } // ECMA-262 14.5 Class Definitions\n\n\n  function parseClassBody() {\n    var classBody,\n        token,\n        isStatic,\n        hasConstructor = false,\n        body,\n        method,\n        computed,\n        key;\n    classBody = new Node();\n    expect('{');\n    body = [];\n\n    while (!match('}')) {\n      if (match(';')) {\n        lex();\n      } else {\n        method = new Node();\n        token = lookahead;\n        isStatic = false;\n        computed = match('[');\n\n        if (match('*')) {\n          lex();\n        } else {\n          key = parseObjectPropertyKey();\n\n          if (key.name === 'static' && (lookaheadPropertyName() || match('*'))) {\n            token = lookahead;\n            isStatic = true;\n            computed = match('[');\n\n            if (match('*')) {\n              lex();\n            } else {\n              key = parseObjectPropertyKey();\n            }\n          }\n        }\n\n        method = tryParseMethodDefinition(token, key, computed, method);\n\n        if (method) {\n          method['static'] = isStatic; // jscs:ignore requireDotNotation\n\n          if (method.kind === 'init') {\n            method.kind = 'method';\n          }\n\n          if (!isStatic) {\n            if (!method.computed && (method.key.name || method.key.value.toString()) === 'constructor') {\n              if (method.kind !== 'method' || !method.method || method.value.generator) {\n                throwUnexpectedToken(token, Messages.ConstructorSpecialMethod);\n              }\n\n              if (hasConstructor) {\n                throwUnexpectedToken(token, Messages.DuplicateConstructor);\n              } else {\n                hasConstructor = true;\n              }\n\n              method.kind = 'constructor';\n            }\n          } else {\n            if (!method.computed && (method.key.name || method.key.value.toString()) === 'prototype') {\n              throwUnexpectedToken(token, Messages.StaticPrototype);\n            }\n          }\n\n          method.type = Syntax.MethodDefinition;\n          delete method.method;\n          delete method.shorthand;\n          body.push(method);\n        } else {\n          throwUnexpectedToken(lookahead);\n        }\n      }\n    }\n\n    lex();\n    return classBody.finishClassBody(body);\n  }\n\n  function parseClassDeclaration(identifierIsOptional) {\n    var id = null,\n        superClass = null,\n        classNode = new Node(),\n        classBody,\n        previousStrict = strict;\n    strict = true;\n    expectKeyword('class');\n\n    if (!identifierIsOptional || lookahead.type === Token.Identifier) {\n      id = parseVariableIdentifier();\n    }\n\n    if (matchKeyword('extends')) {\n      lex();\n      superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);\n    }\n\n    classBody = parseClassBody();\n    strict = previousStrict;\n    return classNode.finishClassDeclaration(id, superClass, classBody);\n  }\n\n  function parseClassExpression() {\n    var id = null,\n        superClass = null,\n        classNode = new Node(),\n        classBody,\n        previousStrict = strict;\n    strict = true;\n    expectKeyword('class');\n\n    if (lookahead.type === Token.Identifier) {\n      id = parseVariableIdentifier();\n    }\n\n    if (matchKeyword('extends')) {\n      lex();\n      superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);\n    }\n\n    classBody = parseClassBody();\n    strict = previousStrict;\n    return classNode.finishClassExpression(id, superClass, classBody);\n  } // ECMA-262 15.2 Modules\n\n\n  function parseModuleSpecifier() {\n    var node = new Node();\n\n    if (lookahead.type !== Token.StringLiteral) {\n      throwError(Messages.InvalidModuleSpecifier);\n    }\n\n    return node.finishLiteral(lex());\n  } // ECMA-262 15.2.3 Exports\n\n\n  function parseExportSpecifier() {\n    var exported,\n        local,\n        node = new Node(),\n        def;\n\n    if (matchKeyword('default')) {\n      // export {default} from 'something';\n      def = new Node();\n      lex();\n      local = def.finishIdentifier('default');\n    } else {\n      local = parseVariableIdentifier();\n    }\n\n    if (matchContextualKeyword('as')) {\n      lex();\n      exported = parseNonComputedProperty();\n    }\n\n    return node.finishExportSpecifier(local, exported);\n  }\n\n  function parseExportNamedDeclaration(node) {\n    var declaration = null,\n        isExportFromIdentifier,\n        src = null,\n        specifiers = []; // non-default export\n\n    if (lookahead.type === Token.Keyword) {\n      // covers:\n      // export var f = 1;\n      switch (lookahead.value) {\n        case 'let':\n        case 'const':\n          declaration = parseLexicalDeclaration({\n            inFor: false\n          });\n          return node.finishExportNamedDeclaration(declaration, specifiers, null);\n\n        case 'var':\n        case 'class':\n        case 'function':\n          declaration = parseStatementListItem();\n          return node.finishExportNamedDeclaration(declaration, specifiers, null);\n      }\n    }\n\n    expect('{');\n\n    while (!match('}')) {\n      isExportFromIdentifier = isExportFromIdentifier || matchKeyword('default');\n      specifiers.push(parseExportSpecifier());\n\n      if (!match('}')) {\n        expect(',');\n\n        if (match('}')) {\n          break;\n        }\n      }\n    }\n\n    expect('}');\n\n    if (matchContextualKeyword('from')) {\n      // covering:\n      // export {default} from 'foo';\n      // export {foo} from 'foo';\n      lex();\n      src = parseModuleSpecifier();\n      consumeSemicolon();\n    } else if (isExportFromIdentifier) {\n      // covering:\n      // export {default}; // missing fromClause\n      throwError(lookahead.value ? Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n    } else {\n      // cover\n      // export {foo};\n      consumeSemicolon();\n    }\n\n    return node.finishExportNamedDeclaration(declaration, specifiers, src);\n  }\n\n  function parseExportDefaultDeclaration(node) {\n    var declaration = null,\n        expression = null; // covers:\n    // export default ...\n\n    expectKeyword('default');\n\n    if (matchKeyword('function')) {\n      // covers:\n      // export default function foo () {}\n      // export default function () {}\n      declaration = parseFunctionDeclaration(new Node(), true);\n      return node.finishExportDefaultDeclaration(declaration);\n    }\n\n    if (matchKeyword('class')) {\n      declaration = parseClassDeclaration(true);\n      return node.finishExportDefaultDeclaration(declaration);\n    }\n\n    if (matchContextualKeyword('from')) {\n      throwError(Messages.UnexpectedToken, lookahead.value);\n    } // covers:\n    // export default {};\n    // export default [];\n    // export default (1 + 2);\n\n\n    if (match('{')) {\n      expression = parseObjectInitializer();\n    } else if (match('[')) {\n      expression = parseArrayInitializer();\n    } else {\n      expression = parseAssignmentExpression();\n    }\n\n    consumeSemicolon();\n    return node.finishExportDefaultDeclaration(expression);\n  }\n\n  function parseExportAllDeclaration(node) {\n    var src; // covers:\n    // export * from 'foo';\n\n    expect('*');\n\n    if (!matchContextualKeyword('from')) {\n      throwError(lookahead.value ? Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n    }\n\n    lex();\n    src = parseModuleSpecifier();\n    consumeSemicolon();\n    return node.finishExportAllDeclaration(src);\n  }\n\n  function parseExportDeclaration() {\n    var node = new Node();\n\n    if (state.inFunctionBody) {\n      throwError(Messages.IllegalExportDeclaration);\n    }\n\n    expectKeyword('export');\n\n    if (matchKeyword('default')) {\n      return parseExportDefaultDeclaration(node);\n    }\n\n    if (match('*')) {\n      return parseExportAllDeclaration(node);\n    }\n\n    return parseExportNamedDeclaration(node);\n  } // ECMA-262 15.2.2 Imports\n\n\n  function parseImportSpecifier() {\n    // import {<foo as bar>} ...;\n    var local,\n        imported,\n        node = new Node();\n    imported = parseNonComputedProperty();\n\n    if (matchContextualKeyword('as')) {\n      lex();\n      local = parseVariableIdentifier();\n    }\n\n    return node.finishImportSpecifier(local, imported);\n  }\n\n  function parseNamedImports() {\n    var specifiers = []; // {foo, bar as bas}\n\n    expect('{');\n\n    while (!match('}')) {\n      specifiers.push(parseImportSpecifier());\n\n      if (!match('}')) {\n        expect(',');\n\n        if (match('}')) {\n          break;\n        }\n      }\n    }\n\n    expect('}');\n    return specifiers;\n  }\n\n  function parseImportDefaultSpecifier() {\n    // import <foo> ...;\n    var local,\n        node = new Node();\n    local = parseNonComputedProperty();\n    return node.finishImportDefaultSpecifier(local);\n  }\n\n  function parseImportNamespaceSpecifier() {\n    // import <* as foo> ...;\n    var local,\n        node = new Node();\n    expect('*');\n\n    if (!matchContextualKeyword('as')) {\n      throwError(Messages.NoAsAfterImportNamespace);\n    }\n\n    lex();\n    local = parseNonComputedProperty();\n    return node.finishImportNamespaceSpecifier(local);\n  }\n\n  function parseImportDeclaration() {\n    var specifiers = [],\n        src,\n        node = new Node();\n\n    if (state.inFunctionBody) {\n      throwError(Messages.IllegalImportDeclaration);\n    }\n\n    expectKeyword('import');\n\n    if (lookahead.type === Token.StringLiteral) {\n      // import 'foo';\n      src = parseModuleSpecifier();\n    } else {\n      if (match('{')) {\n        // import {bar}\n        specifiers = specifiers.concat(parseNamedImports());\n      } else if (match('*')) {\n        // import * as foo\n        specifiers.push(parseImportNamespaceSpecifier());\n      } else if (isIdentifierName(lookahead) && !matchKeyword('default')) {\n        // import foo\n        specifiers.push(parseImportDefaultSpecifier());\n\n        if (match(',')) {\n          lex();\n\n          if (match('*')) {\n            // import foo, * as foo\n            specifiers.push(parseImportNamespaceSpecifier());\n          } else if (match('{')) {\n            // import foo, {bar}\n            specifiers = specifiers.concat(parseNamedImports());\n          } else {\n            throwUnexpectedToken(lookahead);\n          }\n        }\n      } else {\n        throwUnexpectedToken(lex());\n      }\n\n      if (!matchContextualKeyword('from')) {\n        throwError(lookahead.value ? Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n      }\n\n      lex();\n      src = parseModuleSpecifier();\n    }\n\n    consumeSemicolon();\n    return node.finishImportDeclaration(specifiers, src);\n  } // ECMA-262 15.1 Scripts\n\n\n  function parseScriptBody() {\n    var statement,\n        body = [],\n        token,\n        directive,\n        firstRestricted;\n\n    while (startIndex < length) {\n      token = lookahead;\n\n      if (token.type !== Token.StringLiteral) {\n        break;\n      }\n\n      statement = parseStatementListItem();\n      body.push(statement);\n\n      if (statement.expression.type !== Syntax.Literal) {\n        // this is not directive\n        break;\n      }\n\n      directive = source.slice(token.start + 1, token.end - 1);\n\n      if (directive === 'use strict') {\n        strict = true;\n\n        if (firstRestricted) {\n          tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);\n        }\n      } else {\n        if (!firstRestricted && token.octal) {\n          firstRestricted = token;\n        }\n      }\n    }\n\n    while (startIndex < length) {\n      statement = parseStatementListItem();\n      /* istanbul ignore if */\n\n      if (typeof statement === 'undefined') {\n        break;\n      }\n\n      body.push(statement);\n    }\n\n    return body;\n  }\n\n  function parseProgram() {\n    var body, node;\n    peek();\n    node = new Node();\n    body = parseScriptBody();\n    return node.finishProgram(body, state.sourceType);\n  }\n\n  function filterTokenLocation() {\n    var i,\n        entry,\n        token,\n        tokens = [];\n\n    for (i = 0; i < extra.tokens.length; ++i) {\n      entry = extra.tokens[i];\n      token = {\n        type: entry.type,\n        value: entry.value\n      };\n\n      if (entry.regex) {\n        token.regex = {\n          pattern: entry.regex.pattern,\n          flags: entry.regex.flags\n        };\n      }\n\n      if (extra.range) {\n        token.range = entry.range;\n      }\n\n      if (extra.loc) {\n        token.loc = entry.loc;\n      }\n\n      tokens.push(token);\n    }\n\n    extra.tokens = tokens;\n  }\n\n  function tokenize(code, options, delegate) {\n    var toString, tokens;\n    toString = String;\n\n    if (typeof code !== 'string' && !(code instanceof String)) {\n      code = toString(code);\n    }\n\n    source = code;\n    index = 0;\n    lineNumber = source.length > 0 ? 1 : 0;\n    lineStart = 0;\n    startIndex = index;\n    startLineNumber = lineNumber;\n    startLineStart = lineStart;\n    length = source.length;\n    lookahead = null;\n    state = {\n      allowIn: true,\n      allowYield: true,\n      labelSet: {},\n      inFunctionBody: false,\n      inIteration: false,\n      inSwitch: false,\n      lastCommentStart: -1,\n      curlyStack: []\n    };\n    extra = {}; // Options matching.\n\n    options = options || {}; // Of course we collect tokens here.\n\n    options.tokens = true;\n    extra.tokens = [];\n    extra.tokenValues = [];\n    extra.tokenize = true;\n    extra.delegate = delegate; // The following two fields are necessary to compute the Regex tokens.\n\n    extra.openParenToken = -1;\n    extra.openCurlyToken = -1;\n    extra.range = typeof options.range === 'boolean' && options.range;\n    extra.loc = typeof options.loc === 'boolean' && options.loc;\n\n    if (typeof options.comment === 'boolean' && options.comment) {\n      extra.comments = [];\n    }\n\n    if (typeof options.tolerant === 'boolean' && options.tolerant) {\n      extra.errors = [];\n    }\n\n    try {\n      peek();\n\n      if (lookahead.type === Token.EOF) {\n        return extra.tokens;\n      }\n\n      lex();\n\n      while (lookahead.type !== Token.EOF) {\n        try {\n          lex();\n        } catch (lexError) {\n          if (extra.errors) {\n            recordError(lexError); // We have to break on the first error\n            // to avoid infinite loops.\n\n            break;\n          } else {\n            throw lexError;\n          }\n        }\n      }\n\n      tokens = extra.tokens;\n\n      if (typeof extra.errors !== 'undefined') {\n        tokens.errors = extra.errors;\n      }\n    } catch (e) {\n      throw e;\n    } finally {\n      extra = {};\n    }\n\n    return tokens;\n  }\n\n  function parse(code, options) {\n    var program, toString;\n    toString = String;\n\n    if (typeof code !== 'string' && !(code instanceof String)) {\n      code = toString(code);\n    }\n\n    source = code;\n    index = 0;\n    lineNumber = source.length > 0 ? 1 : 0;\n    lineStart = 0;\n    startIndex = index;\n    startLineNumber = lineNumber;\n    startLineStart = lineStart;\n    length = source.length;\n    lookahead = null;\n    state = {\n      allowIn: true,\n      allowYield: true,\n      labelSet: {},\n      inFunctionBody: false,\n      inIteration: false,\n      inSwitch: false,\n      lastCommentStart: -1,\n      curlyStack: [],\n      sourceType: 'script'\n    };\n    strict = false;\n    extra = {};\n\n    if (typeof options !== 'undefined') {\n      extra.range = typeof options.range === 'boolean' && options.range;\n      extra.loc = typeof options.loc === 'boolean' && options.loc;\n      extra.attachComment = typeof options.attachComment === 'boolean' && options.attachComment;\n\n      if (extra.loc && options.source !== null && options.source !== undefined) {\n        extra.source = toString(options.source);\n      }\n\n      if (typeof options.tokens === 'boolean' && options.tokens) {\n        extra.tokens = [];\n      }\n\n      if (typeof options.comment === 'boolean' && options.comment) {\n        extra.comments = [];\n      }\n\n      if (typeof options.tolerant === 'boolean' && options.tolerant) {\n        extra.errors = [];\n      }\n\n      if (extra.attachComment) {\n        extra.range = true;\n        extra.comments = [];\n        extra.bottomRightStack = [];\n        extra.trailingComments = [];\n        extra.leadingComments = [];\n      }\n\n      if (options.sourceType === 'module') {\n        // very restrictive condition for now\n        state.sourceType = options.sourceType;\n        strict = true;\n      }\n    }\n\n    try {\n      program = parseProgram();\n\n      if (typeof extra.comments !== 'undefined') {\n        program.comments = extra.comments;\n      }\n\n      if (typeof extra.tokens !== 'undefined') {\n        filterTokenLocation();\n        program.tokens = extra.tokens;\n      }\n\n      if (typeof extra.errors !== 'undefined') {\n        program.errors = extra.errors;\n      }\n    } catch (e) {\n      throw e;\n    } finally {\n      extra = {};\n    }\n\n    return program;\n  } // Sync with *.json manifests.\n\n\n  exports.version = '2.7.3';\n  exports.tokenize = tokenize;\n  exports.parse = parse; // Deep copy.\n\n  /* istanbul ignore next */\n\n  exports.Syntax = function () {\n    var name,\n        types = {};\n\n    if (typeof Object.create === 'function') {\n      types = Object.create(null);\n    }\n\n    for (name in Syntax) {\n      if (Syntax.hasOwnProperty(name)) {\n        types[name] = Syntax[name];\n      }\n    }\n\n    if (typeof Object.freeze === 'function') {\n      Object.freeze(types);\n    }\n\n    return types;\n  }();\n});\n/* vim: set sw=4 ts=4 et tw=80 : */","map":{"version":3,"sources":["C:/Users/guido/Documents/GitHub/myreactapp/node_modules/globalize-compiler/node_modules/esprima/esprima.js"],"names":["root","factory","define","amd","exports","esprima","Token","TokenName","FnExprTokens","Syntax","PlaceHolders","Messages","Regex","source","strict","index","lineNumber","lineStart","hasLineTerminator","lastIndex","lastLineNumber","lastLineStart","startIndex","startLineNumber","startLineStart","scanning","length","lookahead","state","extra","isBindingElement","isAssignmentTarget","firstCoverInitializedNameError","BooleanLiteral","EOF","Identifier","Keyword","NullLiteral","NumericLiteral","Punctuator","StringLiteral","RegularExpression","Template","AssignmentExpression","AssignmentPattern","ArrayExpression","ArrayPattern","ArrowFunctionExpression","BlockStatement","BinaryExpression","BreakStatement","CallExpression","CatchClause","ClassBody","ClassDeclaration","ClassExpression","ConditionalExpression","ContinueStatement","DoWhileStatement","DebuggerStatement","EmptyStatement","ExportAllDeclaration","ExportDefaultDeclaration","ExportNamedDeclaration","ExportSpecifier","ExpressionStatement","ForStatement","ForOfStatement","ForInStatement","FunctionDeclaration","FunctionExpression","IfStatement","ImportDeclaration","ImportDefaultSpecifier","ImportNamespaceSpecifier","ImportSpecifier","Literal","LabeledStatement","LogicalExpression","MemberExpression","MetaProperty","MethodDefinition","NewExpression","ObjectExpression","ObjectPattern","Program","Property","RestElement","ReturnStatement","SequenceExpression","SpreadElement","Super","SwitchCase","SwitchStatement","TaggedTemplateExpression","TemplateElement","TemplateLiteral","ThisExpression","ThrowStatement","TryStatement","UnaryExpression","UpdateExpression","VariableDeclaration","VariableDeclarator","WhileStatement","WithStatement","YieldExpression","ArrowParameterPlaceHolder","UnexpectedToken","UnexpectedNumber","UnexpectedString","UnexpectedIdentifier","UnexpectedReserved","UnexpectedTemplate","UnexpectedEOS","NewlineAfterThrow","InvalidRegExp","UnterminatedRegExp","InvalidLHSInAssignment","InvalidLHSInForIn","InvalidLHSInForLoop","MultipleDefaultsInSwitch","NoCatchOrFinally","UnknownLabel","Redeclaration","IllegalContinue","IllegalBreak","IllegalReturn","StrictModeWith","StrictCatchVariable","StrictVarName","StrictParamName","StrictParamDupe","StrictFunctionName","StrictOctalLiteral","StrictDelete","StrictLHSAssignment","StrictLHSPostfix","StrictLHSPrefix","StrictReservedWord","TemplateOctalLiteral","ParameterAfterRestParameter","DefaultRestParameter","ObjectPatternAsRestParameter","DuplicateProtoProperty","ConstructorSpecialMethod","DuplicateConstructor","StaticPrototype","MissingFromClause","NoAsAfterImportNamespace","InvalidModuleSpecifier","IllegalImportDeclaration","IllegalExportDeclaration","DuplicateBinding","NonAsciiIdentifierStart","NonAsciiIdentifierPart","assert","condition","message","Error","isDecimalDigit","ch","isHexDigit","indexOf","isOctalDigit","octalToDecimal","octal","code","isWhiteSpace","isLineTerminator","fromCodePoint","cp","String","fromCharCode","isIdentifierStart","test","isIdentifierPart","isFutureReservedWord","id","isStrictModeReservedWord","isRestrictedWord","isKeyword","addComment","type","value","start","end","loc","comment","lastCommentStart","range","comments","push","attachComment","leadingComments","trailingComments","tokenize","delegate","tokens","skipSingleLineComment","offset","line","column","charCodeAt","slice","skipMultiLineComment","tolerateUnexpectedToken","skipComment","scanHexEscape","prefix","i","len","toLowerCase","scanUnicodeCodePointEscape","throwUnexpectedToken","codePointAt","first","second","getComplexIdentifier","substr","getIdentifier","scanIdentifier","scanPunctuator","token","str","openParenToken","tokenValues","openCurlyToken","curlyStack","pop","scanHexLiteral","number","parseInt","scanBinaryLiteral","scanOctalLiteral","isImplicitOctalLiteral","scanNumericLiteral","parseFloat","scanStringLiteral","quote","unescaped","octToDec","scanTemplate","cooked","rawOffset","terminated","head","tail","restore","throwError","raw","testRegExp","pattern","flags","astralSubstitute","tmp","replace","$0","$1","$2","codePoint","RegExp","e","exception","scanRegExpBody","classMarker","body","literal","scanRegExpFlags","scanRegExp","regex","collectRegex","pos","isIdentifierName","advanceSlash","previous","check","testKeyword","advance","collectToken","entry","lex","peek","Position","SourceLocation","WrappingSourceLocation","startToken","Node","WrappingNode","prototype","processComment","lastChild","innerComments","bottomRight","bottomRightStack","last","unshift","splice","undefined","finish","finishArrayExpression","elements","finishArrayPattern","finishArrowFunctionExpression","params","defaults","expression","generator","finishAssignmentExpression","operator","left","right","finishAssignmentPattern","finishBinaryExpression","finishBlockStatement","finishBreakStatement","label","finishCallExpression","callee","args","arguments","finishCatchClause","param","finishClassBody","finishClassDeclaration","superClass","finishClassExpression","finishConditionalExpression","consequent","alternate","finishContinueStatement","finishDebuggerStatement","finishDoWhileStatement","finishEmptyStatement","finishExpressionStatement","finishForStatement","init","update","finishForOfStatement","finishForInStatement","each","finishFunctionDeclaration","finishFunctionExpression","finishIdentifier","name","finishIfStatement","finishLabeledStatement","finishLiteral","finishMemberExpression","accessor","object","property","computed","finishMetaProperty","meta","finishNewExpression","finishObjectExpression","properties","finishObjectPattern","finishPostfixExpression","argument","finishProgram","sourceType","finishProperty","kind","key","method","shorthand","finishRestElement","finishReturnStatement","finishSequenceExpression","expressions","finishSpreadElement","finishSwitchCase","finishSuper","finishSwitchStatement","discriminant","cases","finishTaggedTemplateExpression","tag","quasi","finishTemplateElement","finishTemplateLiteral","quasis","finishThisExpression","finishThrowStatement","finishTryStatement","block","handler","finalizer","guardedHandlers","handlers","finishUnaryExpression","finishVariableDeclaration","declarations","finishLexicalDeclaration","finishVariableDeclarator","finishWhileStatement","finishWithStatement","finishExportSpecifier","local","exported","finishImportDefaultSpecifier","finishImportNamespaceSpecifier","finishExportNamedDeclaration","declaration","specifiers","src","finishExportDefaultDeclaration","finishExportAllDeclaration","finishImportSpecifier","imported","finishImportDeclaration","finishYieldExpression","recordError","error","existing","errors","constructError","msg","base","Object","create","defineProperty","createError","description","messageFormat","Array","call","whole","idx","tolerateError","unexpectedTokenError","expect","expectCommaSeparator","expectKeyword","keyword","match","matchKeyword","matchContextualKeyword","matchAssign","op","consumeSemicolon","isolateCoverGrammar","parser","oldIsBindingElement","oldIsAssignmentTarget","oldFirstCoverInitializedNameError","result","inheritCoverGrammar","parseArrayPattern","node","rest","restNode","parseVariableIdentifier","parsePatternWithDefault","parsePropertyPattern","keyToken","parseAssignmentExpression","parseObjectPropertyKey","parseObjectPattern","parsePattern","previousAllowYield","allowYield","parseArrayInitializer","restSpread","parsePropertyFunction","paramInfo","isGenerator","previousStrict","parseFunctionSourceElements","firstRestricted","stricted","parsePropertyMethodFunction","parseParams","expr","lookaheadPropertyName","tryParseMethodDefinition","options","methodNode","defaultCount","paramSet","parseParam","parseObjectProperty","hasProto","maybeMethod","proto","parseObjectInitializer","reinterpretExpressionAsPattern","parseTemplateElement","option","parseTemplateLiteral","parseExpression","parseGroupExpression","rawParams","parseRestElement","parsePrimaryExpression","parseNonComputedProperty","parseFunctionExpression","parseClassExpression","parseArguments","parseNonComputedMember","parseComputedMember","parseNewExpression","inFunctionBody","parseLeftHandSideExpression","parseLeftHandSideExpressionAllowCall","previousAllowIn","allowIn","parsePostfixExpression","parseUnaryExpression","binaryPrecedence","prec","parseBinaryExpression","marker","markers","stack","parseConditionalExpression","parseConciseBody","checkPatternParam","validateParam","reinterpretAsCoverFormalsList","parseArrowFunctionExpression","parseYieldExpression","list","parseStatementListItem","parseExportDeclaration","parseImportDeclaration","parseLexicalDeclaration","inFor","parseFunctionDeclaration","parseClassDeclaration","isLexicalDeclaration","parseStatement","parseStatementList","parseBlock","parseVariableDeclaration","parseVariableDeclarationList","opt","parseVariableStatement","parseLexicalBinding","parseBindingList","tokenizerState","tokenCount","resetTokenizerState","ts","lexical","parseEmptyStatement","parseExpressionStatement","parseIfStatement","parseDoWhileStatement","oldInIteration","inIteration","parseWhileStatement","parseForStatement","forIn","initSeq","initStartToken","parseContinueStatement","hasOwnProperty","labelSet","parseBreakStatement","inSwitch","parseReturnStatement","parseWithStatement","parseSwitchCase","statement","parseSwitchStatement","clause","oldInSwitch","defaultFound","parseThrowStatement","parseCatchClause","paramMap","parseTryStatement","parseDebuggerStatement","labeledBody","directive","oldLabelSet","oldInFunctionBody","def","identifierIsOptional","parseClassBody","classBody","isStatic","hasConstructor","toString","classNode","parseModuleSpecifier","parseExportSpecifier","parseExportNamedDeclaration","isExportFromIdentifier","parseExportDefaultDeclaration","parseExportAllDeclaration","parseImportSpecifier","parseNamedImports","parseImportDefaultSpecifier","parseImportNamespaceSpecifier","concat","parseScriptBody","parseProgram","filterTokenLocation","tolerant","lexError","parse","program","version","types","freeze"],"mappings":"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","sourcesContent":["/*\n  Copyright (c) jQuery Foundation, Inc. and Contributors, All Rights Reserved.\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n(function (root, factory) {\n    'use strict';\n\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n    // Rhino, and plain browser loading.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define(['exports'], factory);\n    } else if (typeof exports !== 'undefined') {\n        factory(exports);\n    } else {\n        factory((root.esprima = {}));\n    }\n}(this, function (exports) {\n    'use strict';\n\n    var Token,\n        TokenName,\n        FnExprTokens,\n        Syntax,\n        PlaceHolders,\n        Messages,\n        Regex,\n        source,\n        strict,\n        index,\n        lineNumber,\n        lineStart,\n        hasLineTerminator,\n        lastIndex,\n        lastLineNumber,\n        lastLineStart,\n        startIndex,\n        startLineNumber,\n        startLineStart,\n        scanning,\n        length,\n        lookahead,\n        state,\n        extra,\n        isBindingElement,\n        isAssignmentTarget,\n        firstCoverInitializedNameError;\n\n    Token = {\n        BooleanLiteral: 1,\n        EOF: 2,\n        Identifier: 3,\n        Keyword: 4,\n        NullLiteral: 5,\n        NumericLiteral: 6,\n        Punctuator: 7,\n        StringLiteral: 8,\n        RegularExpression: 9,\n        Template: 10\n    };\n\n    TokenName = {};\n    TokenName[Token.BooleanLiteral] = 'Boolean';\n    TokenName[Token.EOF] = '<end>';\n    TokenName[Token.Identifier] = 'Identifier';\n    TokenName[Token.Keyword] = 'Keyword';\n    TokenName[Token.NullLiteral] = 'Null';\n    TokenName[Token.NumericLiteral] = 'Numeric';\n    TokenName[Token.Punctuator] = 'Punctuator';\n    TokenName[Token.StringLiteral] = 'String';\n    TokenName[Token.RegularExpression] = 'RegularExpression';\n    TokenName[Token.Template] = 'Template';\n\n    // A function following one of those tokens is an expression.\n    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',\n                    'return', 'case', 'delete', 'throw', 'void',\n                    // assignment operators\n                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',\n                    '&=', '|=', '^=', ',',\n                    // binary/unary operators\n                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',\n                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',\n                    '<=', '<', '>', '!=', '!=='];\n\n    Syntax = {\n        AssignmentExpression: 'AssignmentExpression',\n        AssignmentPattern: 'AssignmentPattern',\n        ArrayExpression: 'ArrayExpression',\n        ArrayPattern: 'ArrayPattern',\n        ArrowFunctionExpression: 'ArrowFunctionExpression',\n        BlockStatement: 'BlockStatement',\n        BinaryExpression: 'BinaryExpression',\n        BreakStatement: 'BreakStatement',\n        CallExpression: 'CallExpression',\n        CatchClause: 'CatchClause',\n        ClassBody: 'ClassBody',\n        ClassDeclaration: 'ClassDeclaration',\n        ClassExpression: 'ClassExpression',\n        ConditionalExpression: 'ConditionalExpression',\n        ContinueStatement: 'ContinueStatement',\n        DoWhileStatement: 'DoWhileStatement',\n        DebuggerStatement: 'DebuggerStatement',\n        EmptyStatement: 'EmptyStatement',\n        ExportAllDeclaration: 'ExportAllDeclaration',\n        ExportDefaultDeclaration: 'ExportDefaultDeclaration',\n        ExportNamedDeclaration: 'ExportNamedDeclaration',\n        ExportSpecifier: 'ExportSpecifier',\n        ExpressionStatement: 'ExpressionStatement',\n        ForStatement: 'ForStatement',\n        ForOfStatement: 'ForOfStatement',\n        ForInStatement: 'ForInStatement',\n        FunctionDeclaration: 'FunctionDeclaration',\n        FunctionExpression: 'FunctionExpression',\n        Identifier: 'Identifier',\n        IfStatement: 'IfStatement',\n        ImportDeclaration: 'ImportDeclaration',\n        ImportDefaultSpecifier: 'ImportDefaultSpecifier',\n        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',\n        ImportSpecifier: 'ImportSpecifier',\n        Literal: 'Literal',\n        LabeledStatement: 'LabeledStatement',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        MetaProperty: 'MetaProperty',\n        MethodDefinition: 'MethodDefinition',\n        NewExpression: 'NewExpression',\n        ObjectExpression: 'ObjectExpression',\n        ObjectPattern: 'ObjectPattern',\n        Program: 'Program',\n        Property: 'Property',\n        RestElement: 'RestElement',\n        ReturnStatement: 'ReturnStatement',\n        SequenceExpression: 'SequenceExpression',\n        SpreadElement: 'SpreadElement',\n        Super: 'Super',\n        SwitchCase: 'SwitchCase',\n        SwitchStatement: 'SwitchStatement',\n        TaggedTemplateExpression: 'TaggedTemplateExpression',\n        TemplateElement: 'TemplateElement',\n        TemplateLiteral: 'TemplateLiteral',\n        ThisExpression: 'ThisExpression',\n        ThrowStatement: 'ThrowStatement',\n        TryStatement: 'TryStatement',\n        UnaryExpression: 'UnaryExpression',\n        UpdateExpression: 'UpdateExpression',\n        VariableDeclaration: 'VariableDeclaration',\n        VariableDeclarator: 'VariableDeclarator',\n        WhileStatement: 'WhileStatement',\n        WithStatement: 'WithStatement',\n        YieldExpression: 'YieldExpression'\n    };\n\n    PlaceHolders = {\n        ArrowParameterPlaceHolder: 'ArrowParameterPlaceHolder'\n    };\n\n    // Error messages should be identical to V8.\n    Messages = {\n        UnexpectedToken: 'Unexpected token %0',\n        UnexpectedNumber: 'Unexpected number',\n        UnexpectedString: 'Unexpected string',\n        UnexpectedIdentifier: 'Unexpected identifier',\n        UnexpectedReserved: 'Unexpected reserved word',\n        UnexpectedTemplate: 'Unexpected quasi %0',\n        UnexpectedEOS: 'Unexpected end of input',\n        NewlineAfterThrow: 'Illegal newline after throw',\n        InvalidRegExp: 'Invalid regular expression',\n        UnterminatedRegExp: 'Invalid regular expression: missing /',\n        InvalidLHSInAssignment: 'Invalid left-hand side in assignment',\n        InvalidLHSInForIn: 'Invalid left-hand side in for-in',\n        InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',\n        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n        NoCatchOrFinally: 'Missing catch or finally after try',\n        UnknownLabel: 'Undefined label \\'%0\\'',\n        Redeclaration: '%0 \\'%1\\' has already been declared',\n        IllegalContinue: 'Illegal continue statement',\n        IllegalBreak: 'Illegal break statement',\n        IllegalReturn: 'Illegal return statement',\n        StrictModeWith: 'Strict mode code may not include a with statement',\n        StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',\n        StrictVarName: 'Variable name may not be eval or arguments in strict mode',\n        StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',\n        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n        StrictFunctionName: 'Function name may not be eval or arguments in strict mode',\n        StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',\n        StrictDelete: 'Delete of an unqualified identifier in strict mode.',\n        StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',\n        StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictReservedWord: 'Use of future reserved word in strict mode',\n        TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',\n        ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',\n        DefaultRestParameter: 'Unexpected token =',\n        ObjectPatternAsRestParameter: 'Unexpected token {',\n        DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',\n        ConstructorSpecialMethod: 'Class constructor may not be an accessor',\n        DuplicateConstructor: 'A class may only have one constructor',\n        StaticPrototype: 'Classes may not have static property named prototype',\n        MissingFromClause: 'Unexpected token',\n        NoAsAfterImportNamespace: 'Unexpected token',\n        InvalidModuleSpecifier: 'Unexpected token',\n        IllegalImportDeclaration: 'Unexpected token',\n        IllegalExportDeclaration: 'Unexpected token',\n        DuplicateBinding: 'Duplicate binding %0'\n    };\n\n    // See also tools/generate-unicode-regex.js.\n    Regex = {\n        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierStart:\n        NonAsciiIdentifierStart: /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF5D-\\uDF61]|\\uD805[\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA]|\\uD806[\\uDCA0-\\uDCDF\\uDCFF\\uDEC0-\\uDEF8]|\\uD808[\\uDC00-\\uDF98]|\\uD809[\\uDC00-\\uDC6E]|[\\uD80C\\uD840-\\uD868\\uD86A-\\uD86C][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50\\uDF93-\\uDF9F]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD83A[\\uDC00-\\uDCC4]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D]|\\uD87E[\\uDC00-\\uDE1D]/,\n\n        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierPart:\n        NonAsciiIdentifierPart: /[\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC6F\\uDC7F-\\uDCBA\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDD0-\\uDDDA\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF01-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3C-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB7\\uDEC0-\\uDEC9]|\\uD806[\\uDCA0-\\uDCE9\\uDCFF\\uDEC0-\\uDEF8]|\\uD808[\\uDC00-\\uDF98]|\\uD809[\\uDC00-\\uDC6E]|[\\uD80C\\uD840-\\uD868\\uD86A-\\uD86C][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50-\\uDF7E\\uDF8F-\\uDF9F]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D]|\\uD87E[\\uDC00-\\uDE1D]|\\uDB40[\\uDD00-\\uDDEF]/\n    };\n\n    // Ensure the condition is true, otherwise throw an error.\n    // This is only to have a better contract semantic, i.e. another safety net\n    // to catch a logic error. The condition shall be fulfilled in normal case.\n    // Do NOT use this to enforce a certain condition on any user input.\n\n    function assert(condition, message) {\n        /* istanbul ignore if */\n        if (!condition) {\n            throw new Error('ASSERT: ' + message);\n        }\n    }\n\n    function isDecimalDigit(ch) {\n        return (ch >= 0x30 && ch <= 0x39);   // 0..9\n    }\n\n    function isHexDigit(ch) {\n        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n    }\n\n    function isOctalDigit(ch) {\n        return '01234567'.indexOf(ch) >= 0;\n    }\n\n    function octalToDecimal(ch) {\n        // \\0 is not octal escape sequence\n        var octal = (ch !== '0'), code = '01234567'.indexOf(ch);\n\n        if (index < length && isOctalDigit(source[index])) {\n            octal = true;\n            code = code * 8 + '01234567'.indexOf(source[index++]);\n\n            // 3 digits are only allowed when string starts\n            // with 0, 1, 2, 3\n            if ('0123'.indexOf(ch) >= 0 &&\n                    index < length &&\n                    isOctalDigit(source[index])) {\n                code = code * 8 + '01234567'.indexOf(source[index++]);\n            }\n        }\n\n        return {\n            code: code,\n            octal: octal\n        };\n    }\n\n    // ECMA-262 11.2 White Space\n\n    function isWhiteSpace(ch) {\n        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\n            (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);\n    }\n\n    // ECMA-262 11.3 Line Terminators\n\n    function isLineTerminator(ch) {\n        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);\n    }\n\n    // ECMA-262 11.6 Identifier Names and Identifiers\n\n    function fromCodePoint(cp) {\n        return (cp < 0x10000) ? String.fromCharCode(cp) :\n            String.fromCharCode(0xD800 + ((cp - 0x10000) >> 10)) +\n            String.fromCharCode(0xDC00 + ((cp - 0x10000) & 1023));\n    }\n\n    function isIdentifierStart(ch) {\n        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n            (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n            (ch === 0x5C) ||                      // \\ (backslash)\n            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch)));\n    }\n\n    function isIdentifierPart(ch) {\n        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n            (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n            (ch >= 0x30 && ch <= 0x39) ||         // 0..9\n            (ch === 0x5C) ||                      // \\ (backslash)\n            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch)));\n    }\n\n    // ECMA-262 11.6.2.2 Future Reserved Words\n\n    function isFutureReservedWord(id) {\n        switch (id) {\n        case 'enum':\n        case 'export':\n        case 'import':\n        case 'super':\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    function isStrictModeReservedWord(id) {\n        switch (id) {\n        case 'implements':\n        case 'interface':\n        case 'package':\n        case 'private':\n        case 'protected':\n        case 'public':\n        case 'static':\n        case 'yield':\n        case 'let':\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    function isRestrictedWord(id) {\n        return id === 'eval' || id === 'arguments';\n    }\n\n    // ECMA-262 11.6.2.1 Keywords\n\n    function isKeyword(id) {\n        switch (id.length) {\n        case 2:\n            return (id === 'if') || (id === 'in') || (id === 'do');\n        case 3:\n            return (id === 'var') || (id === 'for') || (id === 'new') ||\n                (id === 'try') || (id === 'let');\n        case 4:\n            return (id === 'this') || (id === 'else') || (id === 'case') ||\n                (id === 'void') || (id === 'with') || (id === 'enum');\n        case 5:\n            return (id === 'while') || (id === 'break') || (id === 'catch') ||\n                (id === 'throw') || (id === 'const') || (id === 'yield') ||\n                (id === 'class') || (id === 'super');\n        case 6:\n            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||\n                (id === 'switch') || (id === 'export') || (id === 'import');\n        case 7:\n            return (id === 'default') || (id === 'finally') || (id === 'extends');\n        case 8:\n            return (id === 'function') || (id === 'continue') || (id === 'debugger');\n        case 10:\n            return (id === 'instanceof');\n        default:\n            return false;\n        }\n    }\n\n    // ECMA-262 11.4 Comments\n\n    function addComment(type, value, start, end, loc) {\n        var comment;\n\n        assert(typeof start === 'number', 'Comment must have valid position');\n\n        state.lastCommentStart = start;\n\n        comment = {\n            type: type,\n            value: value\n        };\n        if (extra.range) {\n            comment.range = [start, end];\n        }\n        if (extra.loc) {\n            comment.loc = loc;\n        }\n        extra.comments.push(comment);\n        if (extra.attachComment) {\n            extra.leadingComments.push(comment);\n            extra.trailingComments.push(comment);\n        }\n        if (extra.tokenize) {\n            comment.type = comment.type + 'Comment';\n            if (extra.delegate) {\n                comment = extra.delegate(comment);\n            }\n            extra.tokens.push(comment);\n        }\n    }\n\n    function skipSingleLineComment(offset) {\n        var start, loc, ch, comment;\n\n        start = index - offset;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart - offset\n            }\n        };\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            ++index;\n            if (isLineTerminator(ch)) {\n                hasLineTerminator = true;\n                if (extra.comments) {\n                    comment = source.slice(start + offset, index - 1);\n                    loc.end = {\n                        line: lineNumber,\n                        column: index - lineStart - 1\n                    };\n                    addComment('Line', comment, start, index - 1, loc);\n                }\n                if (ch === 13 && source.charCodeAt(index) === 10) {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n                return;\n            }\n        }\n\n        if (extra.comments) {\n            comment = source.slice(start + offset, index);\n            loc.end = {\n                line: lineNumber,\n                column: index - lineStart\n            };\n            addComment('Line', comment, start, index, loc);\n        }\n    }\n\n    function skipMultiLineComment() {\n        var start, loc, ch, comment;\n\n        if (extra.comments) {\n            start = index - 2;\n            loc = {\n                start: {\n                    line: lineNumber,\n                    column: index - lineStart - 2\n                }\n            };\n        }\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (isLineTerminator(ch)) {\n                if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {\n                    ++index;\n                }\n                hasLineTerminator = true;\n                ++lineNumber;\n                ++index;\n                lineStart = index;\n            } else if (ch === 0x2A) {\n                // Block comment ends with '*/'.\n                if (source.charCodeAt(index + 1) === 0x2F) {\n                    ++index;\n                    ++index;\n                    if (extra.comments) {\n                        comment = source.slice(start + 2, index - 2);\n                        loc.end = {\n                            line: lineNumber,\n                            column: index - lineStart\n                        };\n                        addComment('Block', comment, start, index, loc);\n                    }\n                    return;\n                }\n                ++index;\n            } else {\n                ++index;\n            }\n        }\n\n        // Ran off the end of the file - the whole thing is a comment\n        if (extra.comments) {\n            loc.end = {\n                line: lineNumber,\n                column: index - lineStart\n            };\n            comment = source.slice(start + 2, index);\n            addComment('Block', comment, start, index, loc);\n        }\n        tolerateUnexpectedToken();\n    }\n\n    function skipComment() {\n        var ch, start;\n        hasLineTerminator = false;\n\n        start = (index === 0);\n        while (index < length) {\n            ch = source.charCodeAt(index);\n\n            if (isWhiteSpace(ch)) {\n                ++index;\n            } else if (isLineTerminator(ch)) {\n                hasLineTerminator = true;\n                ++index;\n                if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n                start = true;\n            } else if (ch === 0x2F) { // U+002F is '/'\n                ch = source.charCodeAt(index + 1);\n                if (ch === 0x2F) {\n                    ++index;\n                    ++index;\n                    skipSingleLineComment(2);\n                    start = true;\n                } else if (ch === 0x2A) {  // U+002A is '*'\n                    ++index;\n                    ++index;\n                    skipMultiLineComment();\n                } else {\n                    break;\n                }\n            } else if (start && ch === 0x2D) { // U+002D is '-'\n                // U+003E is '>'\n                if ((source.charCodeAt(index + 1) === 0x2D) && (source.charCodeAt(index + 2) === 0x3E)) {\n                    // '-->' is a single-line comment\n                    index += 3;\n                    skipSingleLineComment(3);\n                } else {\n                    break;\n                }\n            } else if (ch === 0x3C) { // U+003C is '<'\n                if (source.slice(index + 1, index + 4) === '!--') {\n                    ++index; // `<`\n                    ++index; // `!`\n                    ++index; // `-`\n                    ++index; // `-`\n                    skipSingleLineComment(4);\n                } else {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n    }\n\n    function scanHexEscape(prefix) {\n        var i, len, ch, code = 0;\n\n        len = (prefix === 'u') ? 4 : 2;\n        for (i = 0; i < len; ++i) {\n            if (index < length && isHexDigit(source[index])) {\n                ch = source[index++];\n                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n            } else {\n                return '';\n            }\n        }\n        return String.fromCharCode(code);\n    }\n\n    function scanUnicodeCodePointEscape() {\n        var ch, code;\n\n        ch = source[index];\n        code = 0;\n\n        // At least, one hex digit is required.\n        if (ch === '}') {\n            throwUnexpectedToken();\n        }\n\n        while (index < length) {\n            ch = source[index++];\n            if (!isHexDigit(ch)) {\n                break;\n            }\n            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n        }\n\n        if (code > 0x10FFFF || ch !== '}') {\n            throwUnexpectedToken();\n        }\n\n        return fromCodePoint(code);\n    }\n\n    function codePointAt(i) {\n        var cp, first, second;\n\n        cp = source.charCodeAt(i);\n        if (cp >= 0xD800 && cp <= 0xDBFF) {\n            second = source.charCodeAt(i + 1);\n            if (second >= 0xDC00 && second <= 0xDFFF) {\n                first = cp;\n                cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n            }\n        }\n\n        return cp;\n    }\n\n    function getComplexIdentifier() {\n        var cp, ch, id;\n\n        cp = codePointAt(index);\n        id = fromCodePoint(cp);\n        index += id.length;\n\n        // '\\u' (U+005C, U+0075) denotes an escaped character.\n        if (cp === 0x5C) {\n            if (source.charCodeAt(index) !== 0x75) {\n                throwUnexpectedToken();\n            }\n            ++index;\n            if (source[index] === '{') {\n                ++index;\n                ch = scanUnicodeCodePointEscape();\n            } else {\n                ch = scanHexEscape('u');\n                cp = ch.charCodeAt(0);\n                if (!ch || ch === '\\\\' || !isIdentifierStart(cp)) {\n                    throwUnexpectedToken();\n                }\n            }\n            id = ch;\n        }\n\n        while (index < length) {\n            cp = codePointAt(index);\n            if (!isIdentifierPart(cp)) {\n                break;\n            }\n            ch = fromCodePoint(cp);\n            id += ch;\n            index += ch.length;\n\n            // '\\u' (U+005C, U+0075) denotes an escaped character.\n            if (cp === 0x5C) {\n                id = id.substr(0, id.length - 1);\n                if (source.charCodeAt(index) !== 0x75) {\n                    throwUnexpectedToken();\n                }\n                ++index;\n                if (source[index] === '{') {\n                    ++index;\n                    ch = scanUnicodeCodePointEscape();\n                } else {\n                    ch = scanHexEscape('u');\n                    cp = ch.charCodeAt(0);\n                    if (!ch || ch === '\\\\' || !isIdentifierPart(cp)) {\n                        throwUnexpectedToken();\n                    }\n                }\n                id += ch;\n            }\n        }\n\n        return id;\n    }\n\n    function getIdentifier() {\n        var start, ch;\n\n        start = index++;\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (ch === 0x5C) {\n                // Blackslash (U+005C) marks Unicode escape sequence.\n                index = start;\n                return getComplexIdentifier();\n            } else if (ch >= 0xD800 && ch < 0xDFFF) {\n                // Need to handle surrogate pairs.\n                index = start;\n                return getComplexIdentifier();\n            }\n            if (isIdentifierPart(ch)) {\n                ++index;\n            } else {\n                break;\n            }\n        }\n\n        return source.slice(start, index);\n    }\n\n    function scanIdentifier() {\n        var start, id, type;\n\n        start = index;\n\n        // Backslash (U+005C) starts an escaped character.\n        id = (source.charCodeAt(index) === 0x5C) ? getComplexIdentifier() : getIdentifier();\n\n        // There is no keyword or literal with only one character.\n        // Thus, it must be an identifier.\n        if (id.length === 1) {\n            type = Token.Identifier;\n        } else if (isKeyword(id)) {\n            type = Token.Keyword;\n        } else if (id === 'null') {\n            type = Token.NullLiteral;\n        } else if (id === 'true' || id === 'false') {\n            type = Token.BooleanLiteral;\n        } else {\n            type = Token.Identifier;\n        }\n\n        return {\n            type: type,\n            value: id,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n\n    // ECMA-262 11.7 Punctuators\n\n    function scanPunctuator() {\n        var token, str;\n\n        token = {\n            type: Token.Punctuator,\n            value: '',\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: index,\n            end: index\n        };\n\n        // Check for most common single-character punctuators.\n        str = source[index];\n        switch (str) {\n\n        case '(':\n            if (extra.tokenize) {\n                extra.openParenToken = extra.tokenValues.length;\n            }\n            ++index;\n            break;\n\n        case '{':\n            if (extra.tokenize) {\n                extra.openCurlyToken = extra.tokenValues.length;\n            }\n            state.curlyStack.push('{');\n            ++index;\n            break;\n\n        case '.':\n            ++index;\n            if (source[index] === '.' && source[index + 1] === '.') {\n                // Spread operator: ...\n                index += 2;\n                str = '...';\n            }\n            break;\n\n        case '}':\n            ++index;\n            state.curlyStack.pop();\n            break;\n        case ')':\n        case ';':\n        case ',':\n        case '[':\n        case ']':\n        case ':':\n        case '?':\n        case '~':\n            ++index;\n            break;\n\n        default:\n            // 4-character punctuator.\n            str = source.substr(index, 4);\n            if (str === '>>>=') {\n                index += 4;\n            } else {\n\n                // 3-character punctuators.\n                str = str.substr(0, 3);\n                if (str === '===' || str === '!==' || str === '>>>' ||\n                    str === '<<=' || str === '>>=') {\n                    index += 3;\n                } else {\n\n                    // 2-character punctuators.\n                    str = str.substr(0, 2);\n                    if (str === '&&' || str === '||' || str === '==' || str === '!=' ||\n                        str === '+=' || str === '-=' || str === '*=' || str === '/=' ||\n                        str === '++' || str === '--' || str === '<<' || str === '>>' ||\n                        str === '&=' || str === '|=' || str === '^=' || str === '%=' ||\n                        str === '<=' || str === '>=' || str === '=>') {\n                        index += 2;\n                    } else {\n\n                        // 1-character punctuators.\n                        str = source[index];\n                        if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {\n                            ++index;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (index === token.start) {\n            throwUnexpectedToken();\n        }\n\n        token.end = index;\n        token.value = str;\n        return token;\n    }\n\n    // ECMA-262 11.8.3 Numeric Literals\n\n    function scanHexLiteral(start) {\n        var number = '';\n\n        while (index < length) {\n            if (!isHexDigit(source[index])) {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (number.length === 0) {\n            throwUnexpectedToken();\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index))) {\n            throwUnexpectedToken();\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt('0x' + number, 16),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    function scanBinaryLiteral(start) {\n        var ch, number;\n\n        number = '';\n\n        while (index < length) {\n            ch = source[index];\n            if (ch !== '0' && ch !== '1') {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (number.length === 0) {\n            // only 0b or 0B\n            throwUnexpectedToken();\n        }\n\n        if (index < length) {\n            ch = source.charCodeAt(index);\n            /* istanbul ignore else */\n            if (isIdentifierStart(ch) || isDecimalDigit(ch)) {\n                throwUnexpectedToken();\n            }\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt(number, 2),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    function scanOctalLiteral(prefix, start) {\n        var number, octal;\n\n        if (isOctalDigit(prefix)) {\n            octal = true;\n            number = '0' + source[index++];\n        } else {\n            octal = false;\n            ++index;\n            number = '';\n        }\n\n        while (index < length) {\n            if (!isOctalDigit(source[index])) {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (!octal && number.length === 0) {\n            // only 0o or 0O\n            throwUnexpectedToken();\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n            throwUnexpectedToken();\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt(number, 8),\n            octal: octal,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    function isImplicitOctalLiteral() {\n        var i, ch;\n\n        // Implicit octal, unless there is a non-octal digit.\n        // (Annex B.1.1 on Numeric Literals)\n        for (i = index + 1; i < length; ++i) {\n            ch = source[i];\n            if (ch === '8' || ch === '9') {\n                return false;\n            }\n            if (!isOctalDigit(ch)) {\n                return true;\n            }\n        }\n\n        return true;\n    }\n\n    function scanNumericLiteral() {\n        var number, start, ch;\n\n        ch = source[index];\n        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),\n            'Numeric literal must start with a decimal digit or a decimal point');\n\n        start = index;\n        number = '';\n        if (ch !== '.') {\n            number = source[index++];\n            ch = source[index];\n\n            // Hex number starts with '0x'.\n            // Octal number starts with '0'.\n            // Octal number in ES6 starts with '0o'.\n            // Binary number in ES6 starts with '0b'.\n            if (number === '0') {\n                if (ch === 'x' || ch === 'X') {\n                    ++index;\n                    return scanHexLiteral(start);\n                }\n                if (ch === 'b' || ch === 'B') {\n                    ++index;\n                    return scanBinaryLiteral(start);\n                }\n                if (ch === 'o' || ch === 'O') {\n                    return scanOctalLiteral(ch, start);\n                }\n\n                if (isOctalDigit(ch)) {\n                    if (isImplicitOctalLiteral()) {\n                        return scanOctalLiteral(ch, start);\n                    }\n                }\n            }\n\n            while (isDecimalDigit(source.charCodeAt(index))) {\n                number += source[index++];\n            }\n            ch = source[index];\n        }\n\n        if (ch === '.') {\n            number += source[index++];\n            while (isDecimalDigit(source.charCodeAt(index))) {\n                number += source[index++];\n            }\n            ch = source[index];\n        }\n\n        if (ch === 'e' || ch === 'E') {\n            number += source[index++];\n\n            ch = source[index];\n            if (ch === '+' || ch === '-') {\n                number += source[index++];\n            }\n            if (isDecimalDigit(source.charCodeAt(index))) {\n                while (isDecimalDigit(source.charCodeAt(index))) {\n                    number += source[index++];\n                }\n            } else {\n                throwUnexpectedToken();\n            }\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index))) {\n            throwUnexpectedToken();\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseFloat(number),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    // ECMA-262 11.8.4 String Literals\n\n    function scanStringLiteral() {\n        var str = '', quote, start, ch, unescaped, octToDec, octal = false;\n\n        quote = source[index];\n        assert((quote === '\\'' || quote === '\"'),\n            'String literal must starts with a quote');\n\n        start = index;\n        ++index;\n\n        while (index < length) {\n            ch = source[index++];\n\n            if (ch === quote) {\n                quote = '';\n                break;\n            } else if (ch === '\\\\') {\n                ch = source[index++];\n                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n                    switch (ch) {\n                    case 'u':\n                    case 'x':\n                        if (source[index] === '{') {\n                            ++index;\n                            str += scanUnicodeCodePointEscape();\n                        } else {\n                            unescaped = scanHexEscape(ch);\n                            if (!unescaped) {\n                                throw throwUnexpectedToken();\n                            }\n                            str += unescaped;\n                        }\n                        break;\n                    case 'n':\n                        str += '\\n';\n                        break;\n                    case 'r':\n                        str += '\\r';\n                        break;\n                    case 't':\n                        str += '\\t';\n                        break;\n                    case 'b':\n                        str += '\\b';\n                        break;\n                    case 'f':\n                        str += '\\f';\n                        break;\n                    case 'v':\n                        str += '\\x0B';\n                        break;\n                    case '8':\n                    case '9':\n                        str += ch;\n                        tolerateUnexpectedToken();\n                        break;\n\n                    default:\n                        if (isOctalDigit(ch)) {\n                            octToDec = octalToDecimal(ch);\n\n                            octal = octToDec.octal || octal;\n                            str += String.fromCharCode(octToDec.code);\n                        } else {\n                            str += ch;\n                        }\n                        break;\n                    }\n                } else {\n                    ++lineNumber;\n                    if (ch === '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                    lineStart = index;\n                }\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                break;\n            } else {\n                str += ch;\n            }\n        }\n\n        if (quote !== '') {\n            index = start;\n            throwUnexpectedToken();\n        }\n\n        return {\n            type: Token.StringLiteral,\n            value: str,\n            octal: octal,\n            lineNumber: startLineNumber,\n            lineStart: startLineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    // ECMA-262 11.8.6 Template Literal Lexical Components\n\n    function scanTemplate() {\n        var cooked = '', ch, start, rawOffset, terminated, head, tail, restore, unescaped;\n\n        terminated = false;\n        tail = false;\n        start = index;\n        head = (source[index] === '`');\n        rawOffset = 2;\n\n        ++index;\n\n        while (index < length) {\n            ch = source[index++];\n            if (ch === '`') {\n                rawOffset = 1;\n                tail = true;\n                terminated = true;\n                break;\n            } else if (ch === '$') {\n                if (source[index] === '{') {\n                    state.curlyStack.push('${');\n                    ++index;\n                    terminated = true;\n                    break;\n                }\n                cooked += ch;\n            } else if (ch === '\\\\') {\n                ch = source[index++];\n                if (!isLineTerminator(ch.charCodeAt(0))) {\n                    switch (ch) {\n                    case 'n':\n                        cooked += '\\n';\n                        break;\n                    case 'r':\n                        cooked += '\\r';\n                        break;\n                    case 't':\n                        cooked += '\\t';\n                        break;\n                    case 'u':\n                    case 'x':\n                        if (source[index] === '{') {\n                            ++index;\n                            cooked += scanUnicodeCodePointEscape();\n                        } else {\n                            restore = index;\n                            unescaped = scanHexEscape(ch);\n                            if (unescaped) {\n                                cooked += unescaped;\n                            } else {\n                                index = restore;\n                                cooked += ch;\n                            }\n                        }\n                        break;\n                    case 'b':\n                        cooked += '\\b';\n                        break;\n                    case 'f':\n                        cooked += '\\f';\n                        break;\n                    case 'v':\n                        cooked += '\\v';\n                        break;\n\n                    default:\n                        if (ch === '0') {\n                            if (isDecimalDigit(source.charCodeAt(index))) {\n                                // Illegal: \\01 \\02 and so on\n                                throwError(Messages.TemplateOctalLiteral);\n                            }\n                            cooked += '\\0';\n                        } else if (isOctalDigit(ch)) {\n                            // Illegal: \\1 \\2\n                            throwError(Messages.TemplateOctalLiteral);\n                        } else {\n                            cooked += ch;\n                        }\n                        break;\n                    }\n                } else {\n                    ++lineNumber;\n                    if (ch === '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                    lineStart = index;\n                }\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                ++lineNumber;\n                if (ch === '\\r' && source[index] === '\\n') {\n                    ++index;\n                }\n                lineStart = index;\n                cooked += '\\n';\n            } else {\n                cooked += ch;\n            }\n        }\n\n        if (!terminated) {\n            throwUnexpectedToken();\n        }\n\n        if (!head) {\n            state.curlyStack.pop();\n        }\n\n        return {\n            type: Token.Template,\n            value: {\n                cooked: cooked,\n                raw: source.slice(start + 1, index - rawOffset)\n            },\n            head: head,\n            tail: tail,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    // ECMA-262 11.8.5 Regular Expression Literals\n\n    function testRegExp(pattern, flags) {\n        // The BMP character to use as a replacement for astral symbols when\n        // translating an ES6 \"u\"-flagged pattern to an ES5-compatible\n        // approximation.\n        // Note: replacing with '\\uFFFF' enables false positives in unlikely\n        // scenarios. For example, `[\\u{1044f}-\\u{10440}]` is an invalid\n        // pattern that would not be detected by this substitution.\n        var astralSubstitute = '\\uFFFF',\n            tmp = pattern;\n\n        if (flags.indexOf('u') >= 0) {\n            tmp = tmp\n                // Replace every Unicode escape sequence with the equivalent\n                // BMP character or a constant ASCII code point in the case of\n                // astral symbols. (See the above note on `astralSubstitute`\n                // for more information.)\n                .replace(/\\\\u\\{([0-9a-fA-F]+)\\}|\\\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {\n                    var codePoint = parseInt($1 || $2, 16);\n                    if (codePoint > 0x10FFFF) {\n                        throwUnexpectedToken(null, Messages.InvalidRegExp);\n                    }\n                    if (codePoint <= 0xFFFF) {\n                        return String.fromCharCode(codePoint);\n                    }\n                    return astralSubstitute;\n                })\n                // Replace each paired surrogate with a single ASCII symbol to\n                // avoid throwing on regular expressions that are only valid in\n                // combination with the \"u\" flag.\n                .replace(\n                    /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,\n                    astralSubstitute\n                );\n        }\n\n        // First, detect invalid regular expressions.\n        try {\n            RegExp(tmp);\n        } catch (e) {\n            throwUnexpectedToken(null, Messages.InvalidRegExp);\n        }\n\n        // Return a regular expression object for this pattern-flag pair, or\n        // `null` in case the current environment doesn't support the flags it\n        // uses.\n        try {\n            return new RegExp(pattern, flags);\n        } catch (exception) {\n            /* istanbul ignore next */\n            return null;\n        }\n    }\n\n    function scanRegExpBody() {\n        var ch, str, classMarker, terminated, body;\n\n        ch = source[index];\n        assert(ch === '/', 'Regular expression literal must start with a slash');\n        str = source[index++];\n\n        classMarker = false;\n        terminated = false;\n        while (index < length) {\n            ch = source[index++];\n            str += ch;\n            if (ch === '\\\\') {\n                ch = source[index++];\n                // ECMA-262 7.8.5\n                if (isLineTerminator(ch.charCodeAt(0))) {\n                    throwUnexpectedToken(null, Messages.UnterminatedRegExp);\n                }\n                str += ch;\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                throwUnexpectedToken(null, Messages.UnterminatedRegExp);\n            } else if (classMarker) {\n                if (ch === ']') {\n                    classMarker = false;\n                }\n            } else {\n                if (ch === '/') {\n                    terminated = true;\n                    break;\n                } else if (ch === '[') {\n                    classMarker = true;\n                }\n            }\n        }\n\n        if (!terminated) {\n            throwUnexpectedToken(null, Messages.UnterminatedRegExp);\n        }\n\n        // Exclude leading and trailing slash.\n        body = str.substr(1, str.length - 2);\n        return {\n            value: body,\n            literal: str\n        };\n    }\n\n    function scanRegExpFlags() {\n        var ch, str, flags, restore;\n\n        str = '';\n        flags = '';\n        while (index < length) {\n            ch = source[index];\n            if (!isIdentifierPart(ch.charCodeAt(0))) {\n                break;\n            }\n\n            ++index;\n            if (ch === '\\\\' && index < length) {\n                ch = source[index];\n                if (ch === 'u') {\n                    ++index;\n                    restore = index;\n                    ch = scanHexEscape('u');\n                    if (ch) {\n                        flags += ch;\n                        for (str += '\\\\u'; restore < index; ++restore) {\n                            str += source[restore];\n                        }\n                    } else {\n                        index = restore;\n                        flags += 'u';\n                        str += '\\\\u';\n                    }\n                    tolerateUnexpectedToken();\n                } else {\n                    str += '\\\\';\n                    tolerateUnexpectedToken();\n                }\n            } else {\n                flags += ch;\n                str += ch;\n            }\n        }\n\n        return {\n            value: flags,\n            literal: str\n        };\n    }\n\n    function scanRegExp() {\n        var start, body, flags, value;\n        scanning = true;\n\n        lookahead = null;\n        skipComment();\n        start = index;\n\n        body = scanRegExpBody();\n        flags = scanRegExpFlags();\n        value = testRegExp(body.value, flags.value);\n        scanning = false;\n        if (extra.tokenize) {\n            return {\n                type: Token.RegularExpression,\n                value: value,\n                regex: {\n                    pattern: body.value,\n                    flags: flags.value\n                },\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: start,\n                end: index\n            };\n        }\n\n        return {\n            literal: body.literal + flags.literal,\n            value: value,\n            regex: {\n                pattern: body.value,\n                flags: flags.value\n            },\n            start: start,\n            end: index\n        };\n    }\n\n    function collectRegex() {\n        var pos, loc, regex, token;\n\n        skipComment();\n\n        pos = index;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        regex = scanRegExp();\n\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        /* istanbul ignore next */\n        if (!extra.tokenize) {\n            // Pop the previous token, which is likely '/' or '/='\n            if (extra.tokens.length > 0) {\n                token = extra.tokens[extra.tokens.length - 1];\n                if (token.range[0] === pos && token.type === 'Punctuator') {\n                    if (token.value === '/' || token.value === '/=') {\n                        extra.tokens.pop();\n                    }\n                }\n            }\n\n            extra.tokens.push({\n                type: 'RegularExpression',\n                value: regex.literal,\n                regex: regex.regex,\n                range: [pos, index],\n                loc: loc\n            });\n        }\n\n        return regex;\n    }\n\n    function isIdentifierName(token) {\n        return token.type === Token.Identifier ||\n            token.type === Token.Keyword ||\n            token.type === Token.BooleanLiteral ||\n            token.type === Token.NullLiteral;\n    }\n\n    // Using the following algorithm:\n    // https://github.com/mozilla/sweet.js/wiki/design\n\n    function advanceSlash() {\n        var regex, previous, check;\n\n        function testKeyword(value) {\n            return value && (value.length > 1) && (value[0] >= 'a') && (value[0] <= 'z');\n        }\n\n        previous = extra.tokenValues[extra.tokenValues.length - 1];\n        regex = (previous !== null);\n\n        switch (previous) {\n        case 'this':\n        case ']':\n            regex = false;\n            break;\n\n        case ')':\n            check = extra.tokenValues[extra.openParenToken - 1];\n            regex = (check === 'if' || check === 'while' || check === 'for' || check === 'with');\n            break;\n\n        case '}':\n            // Dividing a function by anything makes little sense,\n            // but we have to check for that.\n            regex = false;\n            if (testKeyword(extra.tokenValues[extra.openCurlyToken - 3])) {\n                // Anonymous function, e.g. function(){} /42\n                check = extra.tokenValues[extra.openCurlyToken - 4];\n                regex = check ? (FnExprTokens.indexOf(check) < 0) : false;\n            } else if (testKeyword(extra.tokenValues[extra.openCurlyToken - 4])) {\n                // Named function, e.g. function f(){} /42/\n                check = extra.tokenValues[extra.openCurlyToken - 5];\n                regex = check ? (FnExprTokens.indexOf(check) < 0) : true;\n            }\n        }\n\n        return regex ? collectRegex() : scanPunctuator();\n    }\n\n    function advance() {\n        var cp, token;\n\n        if (index >= length) {\n            return {\n                type: Token.EOF,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: index,\n                end: index\n            };\n        }\n\n        cp = source.charCodeAt(index);\n\n        if (isIdentifierStart(cp)) {\n            token = scanIdentifier();\n            if (strict && isStrictModeReservedWord(token.value)) {\n                token.type = Token.Keyword;\n            }\n            return token;\n        }\n\n        // Very common: ( and ) and ;\n        if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {\n            return scanPunctuator();\n        }\n\n        // String literal starts with single quote (U+0027) or double quote (U+0022).\n        if (cp === 0x27 || cp === 0x22) {\n            return scanStringLiteral();\n        }\n\n        // Dot (.) U+002E can also start a floating-point number, hence the need\n        // to check the next character.\n        if (cp === 0x2E) {\n            if (isDecimalDigit(source.charCodeAt(index + 1))) {\n                return scanNumericLiteral();\n            }\n            return scanPunctuator();\n        }\n\n        if (isDecimalDigit(cp)) {\n            return scanNumericLiteral();\n        }\n\n        // Slash (/) U+002F can also start a regex.\n        if (extra.tokenize && cp === 0x2F) {\n            return advanceSlash();\n        }\n\n        // Template literals start with ` (U+0060) for template head\n        // or } (U+007D) for template middle or template tail.\n        if (cp === 0x60 || (cp === 0x7D && state.curlyStack[state.curlyStack.length - 1] === '${')) {\n            return scanTemplate();\n        }\n\n        // Possible identifier start in a surrogate pair.\n        if (cp >= 0xD800 && cp < 0xDFFF) {\n            cp = codePointAt(index);\n            if (isIdentifierStart(cp)) {\n                return scanIdentifier();\n            }\n        }\n\n        return scanPunctuator();\n    }\n\n    function collectToken() {\n        var loc, token, value, entry;\n\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        token = advance();\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        if (token.type !== Token.EOF) {\n            value = source.slice(token.start, token.end);\n            entry = {\n                type: TokenName[token.type],\n                value: value,\n                range: [token.start, token.end],\n                loc: loc\n            };\n            if (token.regex) {\n                entry.regex = {\n                    pattern: token.regex.pattern,\n                    flags: token.regex.flags\n                };\n            }\n            if (extra.tokenValues) {\n                extra.tokenValues.push((entry.type === 'Punctuator' || entry.type === 'Keyword') ? entry.value : null);\n            }\n            if (extra.tokenize) {\n                if (!extra.range) {\n                    delete entry.range;\n                }\n                if (!extra.loc) {\n                    delete entry.loc;\n                }\n                if (extra.delegate) {\n                    entry = extra.delegate(entry);\n                }\n            }\n            extra.tokens.push(entry);\n        }\n\n        return token;\n    }\n\n    function lex() {\n        var token;\n        scanning = true;\n\n        lastIndex = index;\n        lastLineNumber = lineNumber;\n        lastLineStart = lineStart;\n\n        skipComment();\n\n        token = lookahead;\n\n        startIndex = index;\n        startLineNumber = lineNumber;\n        startLineStart = lineStart;\n\n        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n        scanning = false;\n        return token;\n    }\n\n    function peek() {\n        scanning = true;\n\n        skipComment();\n\n        lastIndex = index;\n        lastLineNumber = lineNumber;\n        lastLineStart = lineStart;\n\n        startIndex = index;\n        startLineNumber = lineNumber;\n        startLineStart = lineStart;\n\n        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n        scanning = false;\n    }\n\n    function Position() {\n        this.line = startLineNumber;\n        this.column = startIndex - startLineStart;\n    }\n\n    function SourceLocation() {\n        this.start = new Position();\n        this.end = null;\n    }\n\n    function WrappingSourceLocation(startToken) {\n        this.start = {\n            line: startToken.lineNumber,\n            column: startToken.start - startToken.lineStart\n        };\n        this.end = null;\n    }\n\n    function Node() {\n        if (extra.range) {\n            this.range = [startIndex, 0];\n        }\n        if (extra.loc) {\n            this.loc = new SourceLocation();\n        }\n    }\n\n    function WrappingNode(startToken) {\n        if (extra.range) {\n            this.range = [startToken.start, 0];\n        }\n        if (extra.loc) {\n            this.loc = new WrappingSourceLocation(startToken);\n        }\n    }\n\n    WrappingNode.prototype = Node.prototype = {\n\n        processComment: function () {\n            var lastChild,\n                innerComments,\n                leadingComments,\n                trailingComments,\n                bottomRight = extra.bottomRightStack,\n                i,\n                comment,\n                last = bottomRight[bottomRight.length - 1];\n\n            if (this.type === Syntax.Program) {\n                if (this.body.length > 0) {\n                    return;\n                }\n            }\n            /**\n             * patch innnerComments for properties empty block\n             * `function a() {/** comments **\\/}`\n             */\n\n            if (this.type === Syntax.BlockStatement && this.body.length === 0) {\n                innerComments = [];\n                for (i = extra.leadingComments.length - 1; i >= 0; --i) {\n                    comment = extra.leadingComments[i];\n                    if (this.range[1] >= comment.range[1]) {\n                        innerComments.unshift(comment);\n                        extra.leadingComments.splice(i, 1);\n                        extra.trailingComments.splice(i, 1);\n                    }\n                }\n                if (innerComments.length) {\n                    this.innerComments = innerComments;\n                    //bottomRight.push(this);\n                    return;\n                }\n            }\n\n            if (extra.trailingComments.length > 0) {\n                trailingComments = [];\n                for (i = extra.trailingComments.length - 1; i >= 0; --i) {\n                    comment = extra.trailingComments[i];\n                    if (comment.range[0] >= this.range[1]) {\n                        trailingComments.unshift(comment);\n                        extra.trailingComments.splice(i, 1);\n                    }\n                }\n                extra.trailingComments = [];\n            } else {\n                if (last && last.trailingComments && last.trailingComments[0].range[0] >= this.range[1]) {\n                    trailingComments = last.trailingComments;\n                    delete last.trailingComments;\n                }\n            }\n\n            // Eating the stack.\n            while (last && last.range[0] >= this.range[0]) {\n                lastChild = bottomRight.pop();\n                last = bottomRight[bottomRight.length - 1];\n            }\n\n            if (lastChild) {\n                if (lastChild.leadingComments) {\n                    leadingComments = [];\n                    for (i = lastChild.leadingComments.length - 1; i >= 0; --i) {\n                        comment = lastChild.leadingComments[i];\n                        if (comment.range[1] <= this.range[0]) {\n                            leadingComments.unshift(comment);\n                            lastChild.leadingComments.splice(i, 1);\n                        }\n                    }\n\n                    if (!lastChild.leadingComments.length) {\n                        lastChild.leadingComments = undefined;\n                    }\n                }\n            } else if (extra.leadingComments.length > 0) {\n                leadingComments = [];\n                for (i = extra.leadingComments.length - 1; i >= 0; --i) {\n                    comment = extra.leadingComments[i];\n                    if (comment.range[1] <= this.range[0]) {\n                        leadingComments.unshift(comment);\n                        extra.leadingComments.splice(i, 1);\n                    }\n                }\n            }\n\n\n            if (leadingComments && leadingComments.length > 0) {\n                this.leadingComments = leadingComments;\n            }\n            if (trailingComments && trailingComments.length > 0) {\n                this.trailingComments = trailingComments;\n            }\n\n            bottomRight.push(this);\n        },\n\n        finish: function () {\n            if (extra.range) {\n                this.range[1] = lastIndex;\n            }\n            if (extra.loc) {\n                this.loc.end = {\n                    line: lastLineNumber,\n                    column: lastIndex - lastLineStart\n                };\n                if (extra.source) {\n                    this.loc.source = extra.source;\n                }\n            }\n\n            if (extra.attachComment) {\n                this.processComment();\n            }\n        },\n\n        finishArrayExpression: function (elements) {\n            this.type = Syntax.ArrayExpression;\n            this.elements = elements;\n            this.finish();\n            return this;\n        },\n\n        finishArrayPattern: function (elements) {\n            this.type = Syntax.ArrayPattern;\n            this.elements = elements;\n            this.finish();\n            return this;\n        },\n\n        finishArrowFunctionExpression: function (params, defaults, body, expression) {\n            this.type = Syntax.ArrowFunctionExpression;\n            this.id = null;\n            this.params = params;\n            this.defaults = defaults;\n            this.body = body;\n            this.generator = false;\n            this.expression = expression;\n            this.finish();\n            return this;\n        },\n\n        finishAssignmentExpression: function (operator, left, right) {\n            this.type = Syntax.AssignmentExpression;\n            this.operator = operator;\n            this.left = left;\n            this.right = right;\n            this.finish();\n            return this;\n        },\n\n        finishAssignmentPattern: function (left, right) {\n            this.type = Syntax.AssignmentPattern;\n            this.left = left;\n            this.right = right;\n            this.finish();\n            return this;\n        },\n\n        finishBinaryExpression: function (operator, left, right) {\n            this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;\n            this.operator = operator;\n            this.left = left;\n            this.right = right;\n            this.finish();\n            return this;\n        },\n\n        finishBlockStatement: function (body) {\n            this.type = Syntax.BlockStatement;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishBreakStatement: function (label) {\n            this.type = Syntax.BreakStatement;\n            this.label = label;\n            this.finish();\n            return this;\n        },\n\n        finishCallExpression: function (callee, args) {\n            this.type = Syntax.CallExpression;\n            this.callee = callee;\n            this.arguments = args;\n            this.finish();\n            return this;\n        },\n\n        finishCatchClause: function (param, body) {\n            this.type = Syntax.CatchClause;\n            this.param = param;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishClassBody: function (body) {\n            this.type = Syntax.ClassBody;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishClassDeclaration: function (id, superClass, body) {\n            this.type = Syntax.ClassDeclaration;\n            this.id = id;\n            this.superClass = superClass;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishClassExpression: function (id, superClass, body) {\n            this.type = Syntax.ClassExpression;\n            this.id = id;\n            this.superClass = superClass;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishConditionalExpression: function (test, consequent, alternate) {\n            this.type = Syntax.ConditionalExpression;\n            this.test = test;\n            this.consequent = consequent;\n            this.alternate = alternate;\n            this.finish();\n            return this;\n        },\n\n        finishContinueStatement: function (label) {\n            this.type = Syntax.ContinueStatement;\n            this.label = label;\n            this.finish();\n            return this;\n        },\n\n        finishDebuggerStatement: function () {\n            this.type = Syntax.DebuggerStatement;\n            this.finish();\n            return this;\n        },\n\n        finishDoWhileStatement: function (body, test) {\n            this.type = Syntax.DoWhileStatement;\n            this.body = body;\n            this.test = test;\n            this.finish();\n            return this;\n        },\n\n        finishEmptyStatement: function () {\n            this.type = Syntax.EmptyStatement;\n            this.finish();\n            return this;\n        },\n\n        finishExpressionStatement: function (expression) {\n            this.type = Syntax.ExpressionStatement;\n            this.expression = expression;\n            this.finish();\n            return this;\n        },\n\n        finishForStatement: function (init, test, update, body) {\n            this.type = Syntax.ForStatement;\n            this.init = init;\n            this.test = test;\n            this.update = update;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishForOfStatement: function (left, right, body) {\n            this.type = Syntax.ForOfStatement;\n            this.left = left;\n            this.right = right;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishForInStatement: function (left, right, body) {\n            this.type = Syntax.ForInStatement;\n            this.left = left;\n            this.right = right;\n            this.body = body;\n            this.each = false;\n            this.finish();\n            return this;\n        },\n\n        finishFunctionDeclaration: function (id, params, defaults, body, generator) {\n            this.type = Syntax.FunctionDeclaration;\n            this.id = id;\n            this.params = params;\n            this.defaults = defaults;\n            this.body = body;\n            this.generator = generator;\n            this.expression = false;\n            this.finish();\n            return this;\n        },\n\n        finishFunctionExpression: function (id, params, defaults, body, generator) {\n            this.type = Syntax.FunctionExpression;\n            this.id = id;\n            this.params = params;\n            this.defaults = defaults;\n            this.body = body;\n            this.generator = generator;\n            this.expression = false;\n            this.finish();\n            return this;\n        },\n\n        finishIdentifier: function (name) {\n            this.type = Syntax.Identifier;\n            this.name = name;\n            this.finish();\n            return this;\n        },\n\n        finishIfStatement: function (test, consequent, alternate) {\n            this.type = Syntax.IfStatement;\n            this.test = test;\n            this.consequent = consequent;\n            this.alternate = alternate;\n            this.finish();\n            return this;\n        },\n\n        finishLabeledStatement: function (label, body) {\n            this.type = Syntax.LabeledStatement;\n            this.label = label;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishLiteral: function (token) {\n            this.type = Syntax.Literal;\n            this.value = token.value;\n            this.raw = source.slice(token.start, token.end);\n            if (token.regex) {\n                this.regex = token.regex;\n            }\n            this.finish();\n            return this;\n        },\n\n        finishMemberExpression: function (accessor, object, property) {\n            this.type = Syntax.MemberExpression;\n            this.computed = accessor === '[';\n            this.object = object;\n            this.property = property;\n            this.finish();\n            return this;\n        },\n\n        finishMetaProperty: function (meta, property) {\n            this.type = Syntax.MetaProperty;\n            this.meta = meta;\n            this.property = property;\n            this.finish();\n            return this;\n        },\n\n        finishNewExpression: function (callee, args) {\n            this.type = Syntax.NewExpression;\n            this.callee = callee;\n            this.arguments = args;\n            this.finish();\n            return this;\n        },\n\n        finishObjectExpression: function (properties) {\n            this.type = Syntax.ObjectExpression;\n            this.properties = properties;\n            this.finish();\n            return this;\n        },\n\n        finishObjectPattern: function (properties) {\n            this.type = Syntax.ObjectPattern;\n            this.properties = properties;\n            this.finish();\n            return this;\n        },\n\n        finishPostfixExpression: function (operator, argument) {\n            this.type = Syntax.UpdateExpression;\n            this.operator = operator;\n            this.argument = argument;\n            this.prefix = false;\n            this.finish();\n            return this;\n        },\n\n        finishProgram: function (body, sourceType) {\n            this.type = Syntax.Program;\n            this.body = body;\n            this.sourceType = sourceType;\n            this.finish();\n            return this;\n        },\n\n        finishProperty: function (kind, key, computed, value, method, shorthand) {\n            this.type = Syntax.Property;\n            this.key = key;\n            this.computed = computed;\n            this.value = value;\n            this.kind = kind;\n            this.method = method;\n            this.shorthand = shorthand;\n            this.finish();\n            return this;\n        },\n\n        finishRestElement: function (argument) {\n            this.type = Syntax.RestElement;\n            this.argument = argument;\n            this.finish();\n            return this;\n        },\n\n        finishReturnStatement: function (argument) {\n            this.type = Syntax.ReturnStatement;\n            this.argument = argument;\n            this.finish();\n            return this;\n        },\n\n        finishSequenceExpression: function (expressions) {\n            this.type = Syntax.SequenceExpression;\n            this.expressions = expressions;\n            this.finish();\n            return this;\n        },\n\n        finishSpreadElement: function (argument) {\n            this.type = Syntax.SpreadElement;\n            this.argument = argument;\n            this.finish();\n            return this;\n        },\n\n        finishSwitchCase: function (test, consequent) {\n            this.type = Syntax.SwitchCase;\n            this.test = test;\n            this.consequent = consequent;\n            this.finish();\n            return this;\n        },\n\n        finishSuper: function () {\n            this.type = Syntax.Super;\n            this.finish();\n            return this;\n        },\n\n        finishSwitchStatement: function (discriminant, cases) {\n            this.type = Syntax.SwitchStatement;\n            this.discriminant = discriminant;\n            this.cases = cases;\n            this.finish();\n            return this;\n        },\n\n        finishTaggedTemplateExpression: function (tag, quasi) {\n            this.type = Syntax.TaggedTemplateExpression;\n            this.tag = tag;\n            this.quasi = quasi;\n            this.finish();\n            return this;\n        },\n\n        finishTemplateElement: function (value, tail) {\n            this.type = Syntax.TemplateElement;\n            this.value = value;\n            this.tail = tail;\n            this.finish();\n            return this;\n        },\n\n        finishTemplateLiteral: function (quasis, expressions) {\n            this.type = Syntax.TemplateLiteral;\n            this.quasis = quasis;\n            this.expressions = expressions;\n            this.finish();\n            return this;\n        },\n\n        finishThisExpression: function () {\n            this.type = Syntax.ThisExpression;\n            this.finish();\n            return this;\n        },\n\n        finishThrowStatement: function (argument) {\n            this.type = Syntax.ThrowStatement;\n            this.argument = argument;\n            this.finish();\n            return this;\n        },\n\n        finishTryStatement: function (block, handler, finalizer) {\n            this.type = Syntax.TryStatement;\n            this.block = block;\n            this.guardedHandlers = [];\n            this.handlers = handler ? [handler] : [];\n            this.handler = handler;\n            this.finalizer = finalizer;\n            this.finish();\n            return this;\n        },\n\n        finishUnaryExpression: function (operator, argument) {\n            this.type = (operator === '++' || operator === '--') ? Syntax.UpdateExpression : Syntax.UnaryExpression;\n            this.operator = operator;\n            this.argument = argument;\n            this.prefix = true;\n            this.finish();\n            return this;\n        },\n\n        finishVariableDeclaration: function (declarations) {\n            this.type = Syntax.VariableDeclaration;\n            this.declarations = declarations;\n            this.kind = 'var';\n            this.finish();\n            return this;\n        },\n\n        finishLexicalDeclaration: function (declarations, kind) {\n            this.type = Syntax.VariableDeclaration;\n            this.declarations = declarations;\n            this.kind = kind;\n            this.finish();\n            return this;\n        },\n\n        finishVariableDeclarator: function (id, init) {\n            this.type = Syntax.VariableDeclarator;\n            this.id = id;\n            this.init = init;\n            this.finish();\n            return this;\n        },\n\n        finishWhileStatement: function (test, body) {\n            this.type = Syntax.WhileStatement;\n            this.test = test;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishWithStatement: function (object, body) {\n            this.type = Syntax.WithStatement;\n            this.object = object;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishExportSpecifier: function (local, exported) {\n            this.type = Syntax.ExportSpecifier;\n            this.exported = exported || local;\n            this.local = local;\n            this.finish();\n            return this;\n        },\n\n        finishImportDefaultSpecifier: function (local) {\n            this.type = Syntax.ImportDefaultSpecifier;\n            this.local = local;\n            this.finish();\n            return this;\n        },\n\n        finishImportNamespaceSpecifier: function (local) {\n            this.type = Syntax.ImportNamespaceSpecifier;\n            this.local = local;\n            this.finish();\n            return this;\n        },\n\n        finishExportNamedDeclaration: function (declaration, specifiers, src) {\n            this.type = Syntax.ExportNamedDeclaration;\n            this.declaration = declaration;\n            this.specifiers = specifiers;\n            this.source = src;\n            this.finish();\n            return this;\n        },\n\n        finishExportDefaultDeclaration: function (declaration) {\n            this.type = Syntax.ExportDefaultDeclaration;\n            this.declaration = declaration;\n            this.finish();\n            return this;\n        },\n\n        finishExportAllDeclaration: function (src) {\n            this.type = Syntax.ExportAllDeclaration;\n            this.source = src;\n            this.finish();\n            return this;\n        },\n\n        finishImportSpecifier: function (local, imported) {\n            this.type = Syntax.ImportSpecifier;\n            this.local = local || imported;\n            this.imported = imported;\n            this.finish();\n            return this;\n        },\n\n        finishImportDeclaration: function (specifiers, src) {\n            this.type = Syntax.ImportDeclaration;\n            this.specifiers = specifiers;\n            this.source = src;\n            this.finish();\n            return this;\n        },\n\n        finishYieldExpression: function (argument, delegate) {\n            this.type = Syntax.YieldExpression;\n            this.argument = argument;\n            this.delegate = delegate;\n            this.finish();\n            return this;\n        }\n    };\n\n\n    function recordError(error) {\n        var e, existing;\n\n        for (e = 0; e < extra.errors.length; e++) {\n            existing = extra.errors[e];\n            // Prevent duplicated error.\n            /* istanbul ignore next */\n            if (existing.index === error.index && existing.message === error.message) {\n                return;\n            }\n        }\n\n        extra.errors.push(error);\n    }\n\n    function constructError(msg, column) {\n        var error = new Error(msg);\n        try {\n            throw error;\n        } catch (base) {\n            /* istanbul ignore else */\n            if (Object.create && Object.defineProperty) {\n                error = Object.create(base);\n                Object.defineProperty(error, 'column', { value: column });\n            }\n        } finally {\n            return error;\n        }\n    }\n\n    function createError(line, pos, description) {\n        var msg, column, error;\n\n        msg = 'Line ' + line + ': ' + description;\n        column = pos - (scanning ? lineStart : lastLineStart) + 1;\n        error = constructError(msg, column);\n        error.lineNumber = line;\n        error.description = description;\n        error.index = pos;\n        return error;\n    }\n\n    // Throw an exception\n\n    function throwError(messageFormat) {\n        var args, msg;\n\n        args = Array.prototype.slice.call(arguments, 1);\n        msg = messageFormat.replace(/%(\\d)/g,\n            function (whole, idx) {\n                assert(idx < args.length, 'Message reference must be in range');\n                return args[idx];\n            }\n        );\n\n        throw createError(lastLineNumber, lastIndex, msg);\n    }\n\n    function tolerateError(messageFormat) {\n        var args, msg, error;\n\n        args = Array.prototype.slice.call(arguments, 1);\n        /* istanbul ignore next */\n        msg = messageFormat.replace(/%(\\d)/g,\n            function (whole, idx) {\n                assert(idx < args.length, 'Message reference must be in range');\n                return args[idx];\n            }\n        );\n\n        error = createError(lineNumber, lastIndex, msg);\n        if (extra.errors) {\n            recordError(error);\n        } else {\n            throw error;\n        }\n    }\n\n    // Throw an exception because of the token.\n\n    function unexpectedTokenError(token, message) {\n        var value, msg = message || Messages.UnexpectedToken;\n\n        if (token) {\n            if (!message) {\n                msg = (token.type === Token.EOF) ? Messages.UnexpectedEOS :\n                    (token.type === Token.Identifier) ? Messages.UnexpectedIdentifier :\n                    (token.type === Token.NumericLiteral) ? Messages.UnexpectedNumber :\n                    (token.type === Token.StringLiteral) ? Messages.UnexpectedString :\n                    (token.type === Token.Template) ? Messages.UnexpectedTemplate :\n                    Messages.UnexpectedToken;\n\n                if (token.type === Token.Keyword) {\n                    if (isFutureReservedWord(token.value)) {\n                        msg = Messages.UnexpectedReserved;\n                    } else if (strict && isStrictModeReservedWord(token.value)) {\n                        msg = Messages.StrictReservedWord;\n                    }\n                }\n            }\n\n            value = (token.type === Token.Template) ? token.value.raw : token.value;\n        } else {\n            value = 'ILLEGAL';\n        }\n\n        msg = msg.replace('%0', value);\n\n        return (token && typeof token.lineNumber === 'number') ?\n            createError(token.lineNumber, token.start, msg) :\n            createError(scanning ? lineNumber : lastLineNumber, scanning ? index : lastIndex, msg);\n    }\n\n    function throwUnexpectedToken(token, message) {\n        throw unexpectedTokenError(token, message);\n    }\n\n    function tolerateUnexpectedToken(token, message) {\n        var error = unexpectedTokenError(token, message);\n        if (extra.errors) {\n            recordError(error);\n        } else {\n            throw error;\n        }\n    }\n\n    // Expect the next token to match the specified punctuator.\n    // If not, an exception will be thrown.\n\n    function expect(value) {\n        var token = lex();\n        if (token.type !== Token.Punctuator || token.value !== value) {\n            throwUnexpectedToken(token);\n        }\n    }\n\n    /**\n     * @name expectCommaSeparator\n     * @description Quietly expect a comma when in tolerant mode, otherwise delegates\n     * to <code>expect(value)</code>\n     * @since 2.0\n     */\n    function expectCommaSeparator() {\n        var token;\n\n        if (extra.errors) {\n            token = lookahead;\n            if (token.type === Token.Punctuator && token.value === ',') {\n                lex();\n            } else if (token.type === Token.Punctuator && token.value === ';') {\n                lex();\n                tolerateUnexpectedToken(token);\n            } else {\n                tolerateUnexpectedToken(token, Messages.UnexpectedToken);\n            }\n        } else {\n            expect(',');\n        }\n    }\n\n    // Expect the next token to match the specified keyword.\n    // If not, an exception will be thrown.\n\n    function expectKeyword(keyword) {\n        var token = lex();\n        if (token.type !== Token.Keyword || token.value !== keyword) {\n            throwUnexpectedToken(token);\n        }\n    }\n\n    // Return true if the next token matches the specified punctuator.\n\n    function match(value) {\n        return lookahead.type === Token.Punctuator && lookahead.value === value;\n    }\n\n    // Return true if the next token matches the specified keyword\n\n    function matchKeyword(keyword) {\n        return lookahead.type === Token.Keyword && lookahead.value === keyword;\n    }\n\n    // Return true if the next token matches the specified contextual keyword\n    // (where an identifier is sometimes a keyword depending on the context)\n\n    function matchContextualKeyword(keyword) {\n        return lookahead.type === Token.Identifier && lookahead.value === keyword;\n    }\n\n    // Return true if the next token is an assignment operator\n\n    function matchAssign() {\n        var op;\n\n        if (lookahead.type !== Token.Punctuator) {\n            return false;\n        }\n        op = lookahead.value;\n        return op === '=' ||\n            op === '*=' ||\n            op === '/=' ||\n            op === '%=' ||\n            op === '+=' ||\n            op === '-=' ||\n            op === '<<=' ||\n            op === '>>=' ||\n            op === '>>>=' ||\n            op === '&=' ||\n            op === '^=' ||\n            op === '|=';\n    }\n\n    function consumeSemicolon() {\n        // Catch the very common case first: immediately a semicolon (U+003B).\n        if (source.charCodeAt(startIndex) === 0x3B || match(';')) {\n            lex();\n            return;\n        }\n\n        if (hasLineTerminator) {\n            return;\n        }\n\n        // FIXME(ikarienator): this is seemingly an issue in the previous location info convention.\n        lastIndex = startIndex;\n        lastLineNumber = startLineNumber;\n        lastLineStart = startLineStart;\n\n        if (lookahead.type !== Token.EOF && !match('}')) {\n            throwUnexpectedToken(lookahead);\n        }\n    }\n\n    // Cover grammar support.\n    //\n    // When an assignment expression position starts with an left parenthesis, the determination of the type\n    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)\n    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.\n    //\n    // There are three productions that can be parsed in a parentheses pair that needs to be determined\n    // after the outermost pair is closed. They are:\n    //\n    //   1. AssignmentExpression\n    //   2. BindingElements\n    //   3. AssignmentTargets\n    //\n    // In order to avoid exponential backtracking, we use two flags to denote if the production can be\n    // binding element or assignment target.\n    //\n    // The three productions have the relationship:\n    //\n    //   BindingElements  AssignmentTargets  AssignmentExpression\n    //\n    // with a single exception that CoverInitializedName when used directly in an Expression, generates\n    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the\n    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.\n    //\n    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not\n    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore\n    // the CoverInitializedName check is conducted.\n    //\n    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates\n    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential\n    // pattern. The CoverInitializedName check is deferred.\n    function isolateCoverGrammar(parser) {\n        var oldIsBindingElement = isBindingElement,\n            oldIsAssignmentTarget = isAssignmentTarget,\n            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,\n            result;\n        isBindingElement = true;\n        isAssignmentTarget = true;\n        firstCoverInitializedNameError = null;\n        result = parser();\n        if (firstCoverInitializedNameError !== null) {\n            throwUnexpectedToken(firstCoverInitializedNameError);\n        }\n        isBindingElement = oldIsBindingElement;\n        isAssignmentTarget = oldIsAssignmentTarget;\n        firstCoverInitializedNameError = oldFirstCoverInitializedNameError;\n        return result;\n    }\n\n    function inheritCoverGrammar(parser) {\n        var oldIsBindingElement = isBindingElement,\n            oldIsAssignmentTarget = isAssignmentTarget,\n            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,\n            result;\n        isBindingElement = true;\n        isAssignmentTarget = true;\n        firstCoverInitializedNameError = null;\n        result = parser();\n        isBindingElement = isBindingElement && oldIsBindingElement;\n        isAssignmentTarget = isAssignmentTarget && oldIsAssignmentTarget;\n        firstCoverInitializedNameError = oldFirstCoverInitializedNameError || firstCoverInitializedNameError;\n        return result;\n    }\n\n    // ECMA-262 13.3.3 Destructuring Binding Patterns\n\n    function parseArrayPattern(params, kind) {\n        var node = new Node(), elements = [], rest, restNode;\n        expect('[');\n\n        while (!match(']')) {\n            if (match(',')) {\n                lex();\n                elements.push(null);\n            } else {\n                if (match('...')) {\n                    restNode = new Node();\n                    lex();\n                    params.push(lookahead);\n                    rest = parseVariableIdentifier(kind);\n                    elements.push(restNode.finishRestElement(rest));\n                    break;\n                } else {\n                    elements.push(parsePatternWithDefault(params, kind));\n                }\n                if (!match(']')) {\n                    expect(',');\n                }\n            }\n\n        }\n\n        expect(']');\n\n        return node.finishArrayPattern(elements);\n    }\n\n    function parsePropertyPattern(params, kind) {\n        var node = new Node(), key, keyToken, computed = match('['), init;\n        if (lookahead.type === Token.Identifier) {\n            keyToken = lookahead;\n            key = parseVariableIdentifier();\n            if (match('=')) {\n                params.push(keyToken);\n                lex();\n                init = parseAssignmentExpression();\n\n                return node.finishProperty(\n                    'init', key, false,\n                    new WrappingNode(keyToken).finishAssignmentPattern(key, init), false, true);\n            } else if (!match(':')) {\n                params.push(keyToken);\n                return node.finishProperty('init', key, false, key, false, true);\n            }\n        } else {\n            key = parseObjectPropertyKey();\n        }\n        expect(':');\n        init = parsePatternWithDefault(params, kind);\n        return node.finishProperty('init', key, computed, init, false, false);\n    }\n\n    function parseObjectPattern(params, kind) {\n        var node = new Node(), properties = [];\n\n        expect('{');\n\n        while (!match('}')) {\n            properties.push(parsePropertyPattern(params, kind));\n            if (!match('}')) {\n                expect(',');\n            }\n        }\n\n        lex();\n\n        return node.finishObjectPattern(properties);\n    }\n\n    function parsePattern(params, kind) {\n        if (match('[')) {\n            return parseArrayPattern(params, kind);\n        } else if (match('{')) {\n            return parseObjectPattern(params, kind);\n        } else if (matchKeyword('let')) {\n            if (kind === 'const' || kind === 'let') {\n                tolerateUnexpectedToken(lookahead, Messages.UnexpectedToken);\n            }\n        }\n\n        params.push(lookahead);\n        return parseVariableIdentifier(kind);\n    }\n\n    function parsePatternWithDefault(params, kind) {\n        var startToken = lookahead, pattern, previousAllowYield, right;\n        pattern = parsePattern(params, kind);\n        if (match('=')) {\n            lex();\n            previousAllowYield = state.allowYield;\n            state.allowYield = true;\n            right = isolateCoverGrammar(parseAssignmentExpression);\n            state.allowYield = previousAllowYield;\n            pattern = new WrappingNode(startToken).finishAssignmentPattern(pattern, right);\n        }\n        return pattern;\n    }\n\n    // ECMA-262 12.2.5 Array Initializer\n\n    function parseArrayInitializer() {\n        var elements = [], node = new Node(), restSpread;\n\n        expect('[');\n\n        while (!match(']')) {\n            if (match(',')) {\n                lex();\n                elements.push(null);\n            } else if (match('...')) {\n                restSpread = new Node();\n                lex();\n                restSpread.finishSpreadElement(inheritCoverGrammar(parseAssignmentExpression));\n\n                if (!match(']')) {\n                    isAssignmentTarget = isBindingElement = false;\n                    expect(',');\n                }\n                elements.push(restSpread);\n            } else {\n                elements.push(inheritCoverGrammar(parseAssignmentExpression));\n\n                if (!match(']')) {\n                    expect(',');\n                }\n            }\n        }\n\n        lex();\n\n        return node.finishArrayExpression(elements);\n    }\n\n    // ECMA-262 12.2.6 Object Initializer\n\n    function parsePropertyFunction(node, paramInfo, isGenerator) {\n        var previousStrict, body;\n\n        isAssignmentTarget = isBindingElement = false;\n\n        previousStrict = strict;\n        body = isolateCoverGrammar(parseFunctionSourceElements);\n\n        if (strict && paramInfo.firstRestricted) {\n            tolerateUnexpectedToken(paramInfo.firstRestricted, paramInfo.message);\n        }\n        if (strict && paramInfo.stricted) {\n            tolerateUnexpectedToken(paramInfo.stricted, paramInfo.message);\n        }\n\n        strict = previousStrict;\n        return node.finishFunctionExpression(null, paramInfo.params, paramInfo.defaults, body, isGenerator);\n    }\n\n    function parsePropertyMethodFunction() {\n        var params, method, node = new Node(),\n            previousAllowYield = state.allowYield;\n\n        state.allowYield = false;\n        params = parseParams();\n        state.allowYield = previousAllowYield;\n\n        state.allowYield = false;\n        method = parsePropertyFunction(node, params, false);\n        state.allowYield = previousAllowYield;\n\n        return method;\n    }\n\n    function parseObjectPropertyKey() {\n        var token, node = new Node(), expr;\n\n        token = lex();\n\n        // Note: This function is called only from parseObjectProperty(), where\n        // EOF and Punctuator tokens are already filtered out.\n\n        switch (token.type) {\n        case Token.StringLiteral:\n        case Token.NumericLiteral:\n            if (strict && token.octal) {\n                tolerateUnexpectedToken(token, Messages.StrictOctalLiteral);\n            }\n            return node.finishLiteral(token);\n        case Token.Identifier:\n        case Token.BooleanLiteral:\n        case Token.NullLiteral:\n        case Token.Keyword:\n            return node.finishIdentifier(token.value);\n        case Token.Punctuator:\n            if (token.value === '[') {\n                expr = isolateCoverGrammar(parseAssignmentExpression);\n                expect(']');\n                return expr;\n            }\n            break;\n        }\n        throwUnexpectedToken(token);\n    }\n\n    function lookaheadPropertyName() {\n        switch (lookahead.type) {\n        case Token.Identifier:\n        case Token.StringLiteral:\n        case Token.BooleanLiteral:\n        case Token.NullLiteral:\n        case Token.NumericLiteral:\n        case Token.Keyword:\n            return true;\n        case Token.Punctuator:\n            return lookahead.value === '[';\n        }\n        return false;\n    }\n\n    // This function is to try to parse a MethodDefinition as defined in 14.3. But in the case of object literals,\n    // it might be called at a position where there is in fact a short hand identifier pattern or a data property.\n    // This can only be determined after we consumed up to the left parentheses.\n    //\n    // In order to avoid back tracking, it returns `null` if the position is not a MethodDefinition and the caller\n    // is responsible to visit other options.\n    function tryParseMethodDefinition(token, key, computed, node) {\n        var value, options, methodNode, params,\n            previousAllowYield = state.allowYield;\n\n        if (token.type === Token.Identifier) {\n            // check for `get` and `set`;\n\n            if (token.value === 'get' && lookaheadPropertyName()) {\n                computed = match('[');\n                key = parseObjectPropertyKey();\n                methodNode = new Node();\n                expect('(');\n                expect(')');\n\n                state.allowYield = false;\n                value = parsePropertyFunction(methodNode, {\n                    params: [],\n                    defaults: [],\n                    stricted: null,\n                    firstRestricted: null,\n                    message: null\n                }, false);\n                state.allowYield = previousAllowYield;\n\n                return node.finishProperty('get', key, computed, value, false, false);\n            } else if (token.value === 'set' && lookaheadPropertyName()) {\n                computed = match('[');\n                key = parseObjectPropertyKey();\n                methodNode = new Node();\n                expect('(');\n\n                options = {\n                    params: [],\n                    defaultCount: 0,\n                    defaults: [],\n                    firstRestricted: null,\n                    paramSet: {}\n                };\n                if (match(')')) {\n                    tolerateUnexpectedToken(lookahead);\n                } else {\n                    state.allowYield = false;\n                    parseParam(options);\n                    state.allowYield = previousAllowYield;\n                    if (options.defaultCount === 0) {\n                        options.defaults = [];\n                    }\n                }\n                expect(')');\n\n                state.allowYield = false;\n                value = parsePropertyFunction(methodNode, options, false);\n                state.allowYield = previousAllowYield;\n\n                return node.finishProperty('set', key, computed, value, false, false);\n            }\n        } else if (token.type === Token.Punctuator && token.value === '*' && lookaheadPropertyName()) {\n            computed = match('[');\n            key = parseObjectPropertyKey();\n            methodNode = new Node();\n\n            state.allowYield = true;\n            params = parseParams();\n            state.allowYield = previousAllowYield;\n\n            state.allowYield = false;\n            value = parsePropertyFunction(methodNode, params, true);\n            state.allowYield = previousAllowYield;\n\n            return node.finishProperty('init', key, computed, value, true, false);\n        }\n\n        if (key && match('(')) {\n            value = parsePropertyMethodFunction();\n            return node.finishProperty('init', key, computed, value, true, false);\n        }\n\n        // Not a MethodDefinition.\n        return null;\n    }\n\n    function parseObjectProperty(hasProto) {\n        var token = lookahead, node = new Node(), computed, key, maybeMethod, proto, value;\n\n        computed = match('[');\n        if (match('*')) {\n            lex();\n        } else {\n            key = parseObjectPropertyKey();\n        }\n        maybeMethod = tryParseMethodDefinition(token, key, computed, node);\n        if (maybeMethod) {\n            return maybeMethod;\n        }\n\n        if (!key) {\n            throwUnexpectedToken(lookahead);\n        }\n\n        // Check for duplicated __proto__\n        if (!computed) {\n            proto = (key.type === Syntax.Identifier && key.name === '__proto__') ||\n                (key.type === Syntax.Literal && key.value === '__proto__');\n            if (hasProto.value && proto) {\n                tolerateError(Messages.DuplicateProtoProperty);\n            }\n            hasProto.value |= proto;\n        }\n\n        if (match(':')) {\n            lex();\n            value = inheritCoverGrammar(parseAssignmentExpression);\n            return node.finishProperty('init', key, computed, value, false, false);\n        }\n\n        if (token.type === Token.Identifier) {\n            if (match('=')) {\n                firstCoverInitializedNameError = lookahead;\n                lex();\n                value = isolateCoverGrammar(parseAssignmentExpression);\n                return node.finishProperty('init', key, computed,\n                    new WrappingNode(token).finishAssignmentPattern(key, value), false, true);\n            }\n            return node.finishProperty('init', key, computed, key, false, true);\n        }\n\n        throwUnexpectedToken(lookahead);\n    }\n\n    function parseObjectInitializer() {\n        var properties = [], hasProto = {value: false}, node = new Node();\n\n        expect('{');\n\n        while (!match('}')) {\n            properties.push(parseObjectProperty(hasProto));\n\n            if (!match('}')) {\n                expectCommaSeparator();\n            }\n        }\n\n        expect('}');\n\n        return node.finishObjectExpression(properties);\n    }\n\n    function reinterpretExpressionAsPattern(expr) {\n        var i;\n        switch (expr.type) {\n        case Syntax.Identifier:\n        case Syntax.MemberExpression:\n        case Syntax.RestElement:\n        case Syntax.AssignmentPattern:\n            break;\n        case Syntax.SpreadElement:\n            expr.type = Syntax.RestElement;\n            reinterpretExpressionAsPattern(expr.argument);\n            break;\n        case Syntax.ArrayExpression:\n            expr.type = Syntax.ArrayPattern;\n            for (i = 0; i < expr.elements.length; i++) {\n                if (expr.elements[i] !== null) {\n                    reinterpretExpressionAsPattern(expr.elements[i]);\n                }\n            }\n            break;\n        case Syntax.ObjectExpression:\n            expr.type = Syntax.ObjectPattern;\n            for (i = 0; i < expr.properties.length; i++) {\n                reinterpretExpressionAsPattern(expr.properties[i].value);\n            }\n            break;\n        case Syntax.AssignmentExpression:\n            expr.type = Syntax.AssignmentPattern;\n            reinterpretExpressionAsPattern(expr.left);\n            break;\n        default:\n            // Allow other node type for tolerant parsing.\n            break;\n        }\n    }\n\n    // ECMA-262 12.2.9 Template Literals\n\n    function parseTemplateElement(option) {\n        var node, token;\n\n        if (lookahead.type !== Token.Template || (option.head && !lookahead.head)) {\n            throwUnexpectedToken();\n        }\n\n        node = new Node();\n        token = lex();\n\n        return node.finishTemplateElement({ raw: token.value.raw, cooked: token.value.cooked }, token.tail);\n    }\n\n    function parseTemplateLiteral() {\n        var quasi, quasis, expressions, node = new Node();\n\n        quasi = parseTemplateElement({ head: true });\n        quasis = [quasi];\n        expressions = [];\n\n        while (!quasi.tail) {\n            expressions.push(parseExpression());\n            quasi = parseTemplateElement({ head: false });\n            quasis.push(quasi);\n        }\n\n        return node.finishTemplateLiteral(quasis, expressions);\n    }\n\n    // ECMA-262 12.2.10 The Grouping Operator\n\n    function parseGroupExpression() {\n        var expr, expressions, startToken, i, params = [];\n\n        expect('(');\n\n        if (match(')')) {\n            lex();\n            if (!match('=>')) {\n                expect('=>');\n            }\n            return {\n                type: PlaceHolders.ArrowParameterPlaceHolder,\n                params: [],\n                rawParams: []\n            };\n        }\n\n        startToken = lookahead;\n        if (match('...')) {\n            expr = parseRestElement(params);\n            expect(')');\n            if (!match('=>')) {\n                expect('=>');\n            }\n            return {\n                type: PlaceHolders.ArrowParameterPlaceHolder,\n                params: [expr]\n            };\n        }\n\n        isBindingElement = true;\n        expr = inheritCoverGrammar(parseAssignmentExpression);\n\n        if (match(',')) {\n            isAssignmentTarget = false;\n            expressions = [expr];\n\n            while (startIndex < length) {\n                if (!match(',')) {\n                    break;\n                }\n                lex();\n\n                if (match('...')) {\n                    if (!isBindingElement) {\n                        throwUnexpectedToken(lookahead);\n                    }\n                    expressions.push(parseRestElement(params));\n                    expect(')');\n                    if (!match('=>')) {\n                        expect('=>');\n                    }\n                    isBindingElement = false;\n                    for (i = 0; i < expressions.length; i++) {\n                        reinterpretExpressionAsPattern(expressions[i]);\n                    }\n                    return {\n                        type: PlaceHolders.ArrowParameterPlaceHolder,\n                        params: expressions\n                    };\n                }\n\n                expressions.push(inheritCoverGrammar(parseAssignmentExpression));\n            }\n\n            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);\n        }\n\n\n        expect(')');\n\n        if (match('=>')) {\n            if (expr.type === Syntax.Identifier && expr.name === 'yield') {\n                return {\n                    type: PlaceHolders.ArrowParameterPlaceHolder,\n                    params: [expr]\n                };\n            }\n\n            if (!isBindingElement) {\n                throwUnexpectedToken(lookahead);\n            }\n\n            if (expr.type === Syntax.SequenceExpression) {\n                for (i = 0; i < expr.expressions.length; i++) {\n                    reinterpretExpressionAsPattern(expr.expressions[i]);\n                }\n            } else {\n                reinterpretExpressionAsPattern(expr);\n            }\n\n            expr = {\n                type: PlaceHolders.ArrowParameterPlaceHolder,\n                params: expr.type === Syntax.SequenceExpression ? expr.expressions : [expr]\n            };\n        }\n        isBindingElement = false;\n        return expr;\n    }\n\n\n    // ECMA-262 12.2 Primary Expressions\n\n    function parsePrimaryExpression() {\n        var type, token, expr, node;\n\n        if (match('(')) {\n            isBindingElement = false;\n            return inheritCoverGrammar(parseGroupExpression);\n        }\n\n        if (match('[')) {\n            return inheritCoverGrammar(parseArrayInitializer);\n        }\n\n        if (match('{')) {\n            return inheritCoverGrammar(parseObjectInitializer);\n        }\n\n        type = lookahead.type;\n        node = new Node();\n\n        if (type === Token.Identifier) {\n            if (state.sourceType === 'module' && lookahead.value === 'await') {\n                tolerateUnexpectedToken(lookahead);\n            }\n            expr = node.finishIdentifier(lex().value);\n        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n            isAssignmentTarget = isBindingElement = false;\n            if (strict && lookahead.octal) {\n                tolerateUnexpectedToken(lookahead, Messages.StrictOctalLiteral);\n            }\n            expr = node.finishLiteral(lex());\n        } else if (type === Token.Keyword) {\n            if (!strict && state.allowYield && matchKeyword('yield')) {\n                return parseNonComputedProperty();\n            }\n            if (!strict && matchKeyword('let')) {\n                return node.finishIdentifier(lex().value);\n            }\n            isAssignmentTarget = isBindingElement = false;\n            if (matchKeyword('function')) {\n                return parseFunctionExpression();\n            }\n            if (matchKeyword('this')) {\n                lex();\n                return node.finishThisExpression();\n            }\n            if (matchKeyword('class')) {\n                return parseClassExpression();\n            }\n            throwUnexpectedToken(lex());\n        } else if (type === Token.BooleanLiteral) {\n            isAssignmentTarget = isBindingElement = false;\n            token = lex();\n            token.value = (token.value === 'true');\n            expr = node.finishLiteral(token);\n        } else if (type === Token.NullLiteral) {\n            isAssignmentTarget = isBindingElement = false;\n            token = lex();\n            token.value = null;\n            expr = node.finishLiteral(token);\n        } else if (match('/') || match('/=')) {\n            isAssignmentTarget = isBindingElement = false;\n            index = startIndex;\n\n            if (typeof extra.tokens !== 'undefined') {\n                token = collectRegex();\n            } else {\n                token = scanRegExp();\n            }\n            lex();\n            expr = node.finishLiteral(token);\n        } else if (type === Token.Template) {\n            expr = parseTemplateLiteral();\n        } else {\n            throwUnexpectedToken(lex());\n        }\n\n        return expr;\n    }\n\n    // ECMA-262 12.3 Left-Hand-Side Expressions\n\n    function parseArguments() {\n        var args = [], expr;\n\n        expect('(');\n\n        if (!match(')')) {\n            while (startIndex < length) {\n                if (match('...')) {\n                    expr = new Node();\n                    lex();\n                    expr.finishSpreadElement(isolateCoverGrammar(parseAssignmentExpression));\n                } else {\n                    expr = isolateCoverGrammar(parseAssignmentExpression);\n                }\n                args.push(expr);\n                if (match(')')) {\n                    break;\n                }\n                expectCommaSeparator();\n            }\n        }\n\n        expect(')');\n\n        return args;\n    }\n\n    function parseNonComputedProperty() {\n        var token, node = new Node();\n\n        token = lex();\n\n        if (!isIdentifierName(token)) {\n            throwUnexpectedToken(token);\n        }\n\n        return node.finishIdentifier(token.value);\n    }\n\n    function parseNonComputedMember() {\n        expect('.');\n\n        return parseNonComputedProperty();\n    }\n\n    function parseComputedMember() {\n        var expr;\n\n        expect('[');\n\n        expr = isolateCoverGrammar(parseExpression);\n\n        expect(']');\n\n        return expr;\n    }\n\n    // ECMA-262 12.3.3 The new Operator\n\n    function parseNewExpression() {\n        var callee, args, node = new Node();\n\n        expectKeyword('new');\n\n        if (match('.')) {\n            lex();\n            if (lookahead.type === Token.Identifier && lookahead.value === 'target') {\n                if (state.inFunctionBody) {\n                    lex();\n                    return node.finishMetaProperty('new', 'target');\n                }\n            }\n            throwUnexpectedToken(lookahead);\n        }\n\n        callee = isolateCoverGrammar(parseLeftHandSideExpression);\n        args = match('(') ? parseArguments() : [];\n\n        isAssignmentTarget = isBindingElement = false;\n\n        return node.finishNewExpression(callee, args);\n    }\n\n    // ECMA-262 12.3.4 Function Calls\n\n    function parseLeftHandSideExpressionAllowCall() {\n        var quasi, expr, args, property, startToken, previousAllowIn = state.allowIn;\n\n        startToken = lookahead;\n        state.allowIn = true;\n\n        if (matchKeyword('super') && state.inFunctionBody) {\n            expr = new Node();\n            lex();\n            expr = expr.finishSuper();\n            if (!match('(') && !match('.') && !match('[')) {\n                throwUnexpectedToken(lookahead);\n            }\n        } else {\n            expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);\n        }\n\n        for (;;) {\n            if (match('.')) {\n                isBindingElement = false;\n                isAssignmentTarget = true;\n                property = parseNonComputedMember();\n                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n            } else if (match('(')) {\n                isBindingElement = false;\n                isAssignmentTarget = false;\n                args = parseArguments();\n                expr = new WrappingNode(startToken).finishCallExpression(expr, args);\n            } else if (match('[')) {\n                isBindingElement = false;\n                isAssignmentTarget = true;\n                property = parseComputedMember();\n                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n            } else if (lookahead.type === Token.Template && lookahead.head) {\n                quasi = parseTemplateLiteral();\n                expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);\n            } else {\n                break;\n            }\n        }\n        state.allowIn = previousAllowIn;\n\n        return expr;\n    }\n\n    // ECMA-262 12.3 Left-Hand-Side Expressions\n\n    function parseLeftHandSideExpression() {\n        var quasi, expr, property, startToken;\n        assert(state.allowIn, 'callee of new expression always allow in keyword.');\n\n        startToken = lookahead;\n\n        if (matchKeyword('super') && state.inFunctionBody) {\n            expr = new Node();\n            lex();\n            expr = expr.finishSuper();\n            if (!match('[') && !match('.')) {\n                throwUnexpectedToken(lookahead);\n            }\n        } else {\n            expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);\n        }\n\n        for (;;) {\n            if (match('[')) {\n                isBindingElement = false;\n                isAssignmentTarget = true;\n                property = parseComputedMember();\n                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n            } else if (match('.')) {\n                isBindingElement = false;\n                isAssignmentTarget = true;\n                property = parseNonComputedMember();\n                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n            } else if (lookahead.type === Token.Template && lookahead.head) {\n                quasi = parseTemplateLiteral();\n                expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);\n            } else {\n                break;\n            }\n        }\n        return expr;\n    }\n\n    // ECMA-262 12.4 Postfix Expressions\n\n    function parsePostfixExpression() {\n        var expr, token, startToken = lookahead;\n\n        expr = inheritCoverGrammar(parseLeftHandSideExpressionAllowCall);\n\n        if (!hasLineTerminator && lookahead.type === Token.Punctuator) {\n            if (match('++') || match('--')) {\n                // ECMA-262 11.3.1, 11.3.2\n                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                    tolerateError(Messages.StrictLHSPostfix);\n                }\n\n                if (!isAssignmentTarget) {\n                    tolerateError(Messages.InvalidLHSInAssignment);\n                }\n\n                isAssignmentTarget = isBindingElement = false;\n\n                token = lex();\n                expr = new WrappingNode(startToken).finishPostfixExpression(token.value, expr);\n            }\n        }\n\n        return expr;\n    }\n\n    // ECMA-262 12.5 Unary Operators\n\n    function parseUnaryExpression() {\n        var token, expr, startToken;\n\n        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n            expr = parsePostfixExpression();\n        } else if (match('++') || match('--')) {\n            startToken = lookahead;\n            token = lex();\n            expr = inheritCoverGrammar(parseUnaryExpression);\n            // ECMA-262 11.4.4, 11.4.5\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                tolerateError(Messages.StrictLHSPrefix);\n            }\n\n            if (!isAssignmentTarget) {\n                tolerateError(Messages.InvalidLHSInAssignment);\n            }\n            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n            isAssignmentTarget = isBindingElement = false;\n        } else if (match('+') || match('-') || match('~') || match('!')) {\n            startToken = lookahead;\n            token = lex();\n            expr = inheritCoverGrammar(parseUnaryExpression);\n            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n            isAssignmentTarget = isBindingElement = false;\n        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n            startToken = lookahead;\n            token = lex();\n            expr = inheritCoverGrammar(parseUnaryExpression);\n            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {\n                tolerateError(Messages.StrictDelete);\n            }\n            isAssignmentTarget = isBindingElement = false;\n        } else {\n            expr = parsePostfixExpression();\n        }\n\n        return expr;\n    }\n\n    function binaryPrecedence(token, allowIn) {\n        var prec = 0;\n\n        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n            return 0;\n        }\n\n        switch (token.value) {\n        case '||':\n            prec = 1;\n            break;\n\n        case '&&':\n            prec = 2;\n            break;\n\n        case '|':\n            prec = 3;\n            break;\n\n        case '^':\n            prec = 4;\n            break;\n\n        case '&':\n            prec = 5;\n            break;\n\n        case '==':\n        case '!=':\n        case '===':\n        case '!==':\n            prec = 6;\n            break;\n\n        case '<':\n        case '>':\n        case '<=':\n        case '>=':\n        case 'instanceof':\n            prec = 7;\n            break;\n\n        case 'in':\n            prec = allowIn ? 7 : 0;\n            break;\n\n        case '<<':\n        case '>>':\n        case '>>>':\n            prec = 8;\n            break;\n\n        case '+':\n        case '-':\n            prec = 9;\n            break;\n\n        case '*':\n        case '/':\n        case '%':\n            prec = 11;\n            break;\n\n        default:\n            break;\n        }\n\n        return prec;\n    }\n\n    // ECMA-262 12.6 Multiplicative Operators\n    // ECMA-262 12.7 Additive Operators\n    // ECMA-262 12.8 Bitwise Shift Operators\n    // ECMA-262 12.9 Relational Operators\n    // ECMA-262 12.10 Equality Operators\n    // ECMA-262 12.11 Binary Bitwise Operators\n    // ECMA-262 12.12 Binary Logical Operators\n\n    function parseBinaryExpression() {\n        var marker, markers, expr, token, prec, stack, right, operator, left, i;\n\n        marker = lookahead;\n        left = inheritCoverGrammar(parseUnaryExpression);\n\n        token = lookahead;\n        prec = binaryPrecedence(token, state.allowIn);\n        if (prec === 0) {\n            return left;\n        }\n        isAssignmentTarget = isBindingElement = false;\n        token.prec = prec;\n        lex();\n\n        markers = [marker, lookahead];\n        right = isolateCoverGrammar(parseUnaryExpression);\n\n        stack = [left, token, right];\n\n        while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {\n\n            // Reduce: make a binary expression from the three topmost entries.\n            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n                right = stack.pop();\n                operator = stack.pop().value;\n                left = stack.pop();\n                markers.pop();\n                expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);\n                stack.push(expr);\n            }\n\n            // Shift.\n            token = lex();\n            token.prec = prec;\n            stack.push(token);\n            markers.push(lookahead);\n            expr = isolateCoverGrammar(parseUnaryExpression);\n            stack.push(expr);\n        }\n\n        // Final reduce to clean-up the stack.\n        i = stack.length - 1;\n        expr = stack[i];\n        markers.pop();\n        while (i > 1) {\n            expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n            i -= 2;\n        }\n\n        return expr;\n    }\n\n\n    // ECMA-262 12.13 Conditional Operator\n\n    function parseConditionalExpression() {\n        var expr, previousAllowIn, consequent, alternate, startToken;\n\n        startToken = lookahead;\n\n        expr = inheritCoverGrammar(parseBinaryExpression);\n        if (match('?')) {\n            lex();\n            previousAllowIn = state.allowIn;\n            state.allowIn = true;\n            consequent = isolateCoverGrammar(parseAssignmentExpression);\n            state.allowIn = previousAllowIn;\n            expect(':');\n            alternate = isolateCoverGrammar(parseAssignmentExpression);\n\n            expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);\n            isAssignmentTarget = isBindingElement = false;\n        }\n\n        return expr;\n    }\n\n    // ECMA-262 14.2 Arrow Function Definitions\n\n    function parseConciseBody() {\n        if (match('{')) {\n            return parseFunctionSourceElements();\n        }\n        return isolateCoverGrammar(parseAssignmentExpression);\n    }\n\n    function checkPatternParam(options, param) {\n        var i;\n        switch (param.type) {\n        case Syntax.Identifier:\n            validateParam(options, param, param.name);\n            break;\n        case Syntax.RestElement:\n            checkPatternParam(options, param.argument);\n            break;\n        case Syntax.AssignmentPattern:\n            checkPatternParam(options, param.left);\n            break;\n        case Syntax.ArrayPattern:\n            for (i = 0; i < param.elements.length; i++) {\n                if (param.elements[i] !== null) {\n                    checkPatternParam(options, param.elements[i]);\n                }\n            }\n            break;\n        case Syntax.YieldExpression:\n            break;\n        default:\n            assert(param.type === Syntax.ObjectPattern, 'Invalid type');\n            for (i = 0; i < param.properties.length; i++) {\n                checkPatternParam(options, param.properties[i].value);\n            }\n            break;\n        }\n    }\n    function reinterpretAsCoverFormalsList(expr) {\n        var i, len, param, params, defaults, defaultCount, options, token;\n\n        defaults = [];\n        defaultCount = 0;\n        params = [expr];\n\n        switch (expr.type) {\n        case Syntax.Identifier:\n            break;\n        case PlaceHolders.ArrowParameterPlaceHolder:\n            params = expr.params;\n            break;\n        default:\n            return null;\n        }\n\n        options = {\n            paramSet: {}\n        };\n\n        for (i = 0, len = params.length; i < len; i += 1) {\n            param = params[i];\n            switch (param.type) {\n            case Syntax.AssignmentPattern:\n                params[i] = param.left;\n                if (param.right.type === Syntax.YieldExpression) {\n                    if (param.right.argument) {\n                        throwUnexpectedToken(lookahead);\n                    }\n                    param.right.type = Syntax.Identifier;\n                    param.right.name = 'yield';\n                    delete param.right.argument;\n                    delete param.right.delegate;\n                }\n                defaults.push(param.right);\n                ++defaultCount;\n                checkPatternParam(options, param.left);\n                break;\n            default:\n                checkPatternParam(options, param);\n                params[i] = param;\n                defaults.push(null);\n                break;\n            }\n        }\n\n        if (strict || !state.allowYield) {\n            for (i = 0, len = params.length; i < len; i += 1) {\n                param = params[i];\n                if (param.type === Syntax.YieldExpression) {\n                    throwUnexpectedToken(lookahead);\n                }\n            }\n        }\n\n        if (options.message === Messages.StrictParamDupe) {\n            token = strict ? options.stricted : options.firstRestricted;\n            throwUnexpectedToken(token, options.message);\n        }\n\n        if (defaultCount === 0) {\n            defaults = [];\n        }\n\n        return {\n            params: params,\n            defaults: defaults,\n            stricted: options.stricted,\n            firstRestricted: options.firstRestricted,\n            message: options.message\n        };\n    }\n\n    function parseArrowFunctionExpression(options, node) {\n        var previousStrict, previousAllowYield, body;\n\n        if (hasLineTerminator) {\n            tolerateUnexpectedToken(lookahead);\n        }\n        expect('=>');\n\n        previousStrict = strict;\n        previousAllowYield = state.allowYield;\n        state.allowYield = true;\n\n        body = parseConciseBody();\n\n        if (strict && options.firstRestricted) {\n            throwUnexpectedToken(options.firstRestricted, options.message);\n        }\n        if (strict && options.stricted) {\n            tolerateUnexpectedToken(options.stricted, options.message);\n        }\n\n        strict = previousStrict;\n        state.allowYield = previousAllowYield;\n\n        return node.finishArrowFunctionExpression(options.params, options.defaults, body, body.type !== Syntax.BlockStatement);\n    }\n\n    // ECMA-262 14.4 Yield expression\n\n    function parseYieldExpression() {\n        var argument, expr, delegate, previousAllowYield;\n\n        argument = null;\n        expr = new Node();\n        delegate = false;\n\n        expectKeyword('yield');\n\n        if (!hasLineTerminator) {\n            previousAllowYield = state.allowYield;\n            state.allowYield = false;\n            delegate = match('*');\n            if (delegate) {\n                lex();\n                argument = parseAssignmentExpression();\n            } else {\n                if (!match(';') && !match('}') && !match(')') && lookahead.type !== Token.EOF) {\n                    argument = parseAssignmentExpression();\n                }\n            }\n            state.allowYield = previousAllowYield;\n        }\n\n        return expr.finishYieldExpression(argument, delegate);\n    }\n\n    // ECMA-262 12.14 Assignment Operators\n\n    function parseAssignmentExpression() {\n        var token, expr, right, list, startToken;\n\n        startToken = lookahead;\n        token = lookahead;\n\n        if (!state.allowYield && matchKeyword('yield')) {\n            return parseYieldExpression();\n        }\n\n        expr = parseConditionalExpression();\n\n        if (expr.type === PlaceHolders.ArrowParameterPlaceHolder || match('=>')) {\n            isAssignmentTarget = isBindingElement = false;\n            list = reinterpretAsCoverFormalsList(expr);\n\n            if (list) {\n                firstCoverInitializedNameError = null;\n                return parseArrowFunctionExpression(list, new WrappingNode(startToken));\n            }\n\n            return expr;\n        }\n\n        if (matchAssign()) {\n            if (!isAssignmentTarget) {\n                tolerateError(Messages.InvalidLHSInAssignment);\n            }\n\n            // ECMA-262 12.1.1\n            if (strict && expr.type === Syntax.Identifier) {\n                if (isRestrictedWord(expr.name)) {\n                    tolerateUnexpectedToken(token, Messages.StrictLHSAssignment);\n                }\n                if (isStrictModeReservedWord(expr.name)) {\n                    tolerateUnexpectedToken(token, Messages.StrictReservedWord);\n                }\n            }\n\n            if (!match('=')) {\n                isAssignmentTarget = isBindingElement = false;\n            } else {\n                reinterpretExpressionAsPattern(expr);\n            }\n\n            token = lex();\n            right = isolateCoverGrammar(parseAssignmentExpression);\n            expr = new WrappingNode(startToken).finishAssignmentExpression(token.value, expr, right);\n            firstCoverInitializedNameError = null;\n        }\n\n        return expr;\n    }\n\n    // ECMA-262 12.15 Comma Operator\n\n    function parseExpression() {\n        var expr, startToken = lookahead, expressions;\n\n        expr = isolateCoverGrammar(parseAssignmentExpression);\n\n        if (match(',')) {\n            expressions = [expr];\n\n            while (startIndex < length) {\n                if (!match(',')) {\n                    break;\n                }\n                lex();\n                expressions.push(isolateCoverGrammar(parseAssignmentExpression));\n            }\n\n            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);\n        }\n\n        return expr;\n    }\n\n    // ECMA-262 13.2 Block\n\n    function parseStatementListItem() {\n        if (lookahead.type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'export':\n                if (state.sourceType !== 'module') {\n                    tolerateUnexpectedToken(lookahead, Messages.IllegalExportDeclaration);\n                }\n                return parseExportDeclaration();\n            case 'import':\n                if (state.sourceType !== 'module') {\n                    tolerateUnexpectedToken(lookahead, Messages.IllegalImportDeclaration);\n                }\n                return parseImportDeclaration();\n            case 'const':\n                return parseLexicalDeclaration({inFor: false});\n            case 'function':\n                return parseFunctionDeclaration(new Node());\n            case 'class':\n                return parseClassDeclaration();\n            }\n        }\n\n        if (matchKeyword('let') && isLexicalDeclaration()) {\n            return parseLexicalDeclaration({inFor: false});\n        }\n\n        return parseStatement();\n    }\n\n    function parseStatementList() {\n        var list = [];\n        while (startIndex < length) {\n            if (match('}')) {\n                break;\n            }\n            list.push(parseStatementListItem());\n        }\n\n        return list;\n    }\n\n    function parseBlock() {\n        var block, node = new Node();\n\n        expect('{');\n\n        block = parseStatementList();\n\n        expect('}');\n\n        return node.finishBlockStatement(block);\n    }\n\n    // ECMA-262 13.3.2 Variable Statement\n\n    function parseVariableIdentifier(kind) {\n        var token, node = new Node();\n\n        token = lex();\n\n        if (token.type === Token.Keyword && token.value === 'yield') {\n            if (strict) {\n                tolerateUnexpectedToken(token, Messages.StrictReservedWord);\n            } if (!state.allowYield) {\n                throwUnexpectedToken(token);\n            }\n        } else if (token.type !== Token.Identifier) {\n            if (strict && token.type === Token.Keyword && isStrictModeReservedWord(token.value)) {\n                tolerateUnexpectedToken(token, Messages.StrictReservedWord);\n            } else {\n                if (strict || token.value !== 'let' || kind !== 'var') {\n                    throwUnexpectedToken(token);\n                }\n            }\n        } else if (state.sourceType === 'module' && token.type === Token.Identifier && token.value === 'await') {\n            tolerateUnexpectedToken(token);\n        }\n\n        return node.finishIdentifier(token.value);\n    }\n\n    function parseVariableDeclaration(options) {\n        var init = null, id, node = new Node(), params = [];\n\n        id = parsePattern(params, 'var');\n\n        // ECMA-262 12.2.1\n        if (strict && isRestrictedWord(id.name)) {\n            tolerateError(Messages.StrictVarName);\n        }\n\n        if (match('=')) {\n            lex();\n            init = isolateCoverGrammar(parseAssignmentExpression);\n        } else if (id.type !== Syntax.Identifier && !options.inFor) {\n            expect('=');\n        }\n\n        return node.finishVariableDeclarator(id, init);\n    }\n\n    function parseVariableDeclarationList(options) {\n        var opt, list;\n\n        opt = { inFor: options.inFor };\n        list = [parseVariableDeclaration(opt)];\n\n        while (match(',')) {\n            lex();\n            list.push(parseVariableDeclaration(opt));\n        }\n\n        return list;\n    }\n\n    function parseVariableStatement(node) {\n        var declarations;\n\n        expectKeyword('var');\n\n        declarations = parseVariableDeclarationList({ inFor: false });\n\n        consumeSemicolon();\n\n        return node.finishVariableDeclaration(declarations);\n    }\n\n    // ECMA-262 13.3.1 Let and Const Declarations\n\n    function parseLexicalBinding(kind, options) {\n        var init = null, id, node = new Node(), params = [];\n\n        id = parsePattern(params, kind);\n\n        // ECMA-262 12.2.1\n        if (strict && id.type === Syntax.Identifier && isRestrictedWord(id.name)) {\n            tolerateError(Messages.StrictVarName);\n        }\n\n        if (kind === 'const') {\n            if (!matchKeyword('in') && !matchContextualKeyword('of')) {\n                expect('=');\n                init = isolateCoverGrammar(parseAssignmentExpression);\n            }\n        } else if ((!options.inFor && id.type !== Syntax.Identifier) || match('=')) {\n            expect('=');\n            init = isolateCoverGrammar(parseAssignmentExpression);\n        }\n\n        return node.finishVariableDeclarator(id, init);\n    }\n\n    function parseBindingList(kind, options) {\n        var list = [parseLexicalBinding(kind, options)];\n\n        while (match(',')) {\n            lex();\n            list.push(parseLexicalBinding(kind, options));\n        }\n\n        return list;\n    }\n\n\n    function tokenizerState() {\n        return {\n            index: index,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            hasLineTerminator: hasLineTerminator,\n            lastIndex: lastIndex,\n            lastLineNumber: lastLineNumber,\n            lastLineStart: lastLineStart,\n            startIndex: startIndex,\n            startLineNumber: startLineNumber,\n            startLineStart: startLineStart,\n            lookahead: lookahead,\n            tokenCount: extra.tokens ? extra.tokens.length : 0\n        };\n    }\n\n    function resetTokenizerState(ts) {\n        index = ts.index;\n        lineNumber = ts.lineNumber;\n        lineStart = ts.lineStart;\n        hasLineTerminator = ts.hasLineTerminator;\n        lastIndex = ts.lastIndex;\n        lastLineNumber = ts.lastLineNumber;\n        lastLineStart = ts.lastLineStart;\n        startIndex = ts.startIndex;\n        startLineNumber = ts.startLineNumber;\n        startLineStart = ts.startLineStart;\n        lookahead = ts.lookahead;\n        if (extra.tokens) {\n            extra.tokens.splice(ts.tokenCount, extra.tokens.length);\n        }\n    }\n\n    function isLexicalDeclaration() {\n        var lexical, ts;\n\n        ts = tokenizerState();\n\n        lex();\n        lexical = (lookahead.type === Token.Identifier) || match('[') || match('{') ||\n            matchKeyword('let') || matchKeyword('yield');\n\n        resetTokenizerState(ts);\n\n        return lexical;\n    }\n\n    function parseLexicalDeclaration(options) {\n        var kind, declarations, node = new Node();\n\n        kind = lex().value;\n        assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');\n\n        declarations = parseBindingList(kind, options);\n\n        consumeSemicolon();\n\n        return node.finishLexicalDeclaration(declarations, kind);\n    }\n\n    function parseRestElement(params) {\n        var param, node = new Node();\n\n        lex();\n\n        if (match('{')) {\n            throwError(Messages.ObjectPatternAsRestParameter);\n        }\n\n        params.push(lookahead);\n\n        param = parseVariableIdentifier();\n\n        if (match('=')) {\n            throwError(Messages.DefaultRestParameter);\n        }\n\n        if (!match(')')) {\n            throwError(Messages.ParameterAfterRestParameter);\n        }\n\n        return node.finishRestElement(param);\n    }\n\n    // ECMA-262 13.4 Empty Statement\n\n    function parseEmptyStatement(node) {\n        expect(';');\n        return node.finishEmptyStatement();\n    }\n\n    // ECMA-262 12.4 Expression Statement\n\n    function parseExpressionStatement(node) {\n        var expr = parseExpression();\n        consumeSemicolon();\n        return node.finishExpressionStatement(expr);\n    }\n\n    // ECMA-262 13.6 If statement\n\n    function parseIfStatement(node) {\n        var test, consequent, alternate;\n\n        expectKeyword('if');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        consequent = parseStatement();\n\n        if (matchKeyword('else')) {\n            lex();\n            alternate = parseStatement();\n        } else {\n            alternate = null;\n        }\n\n        return node.finishIfStatement(test, consequent, alternate);\n    }\n\n    // ECMA-262 13.7 Iteration Statements\n\n    function parseDoWhileStatement(node) {\n        var body, test, oldInIteration;\n\n        expectKeyword('do');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        if (match(';')) {\n            lex();\n        }\n\n        return node.finishDoWhileStatement(body, test);\n    }\n\n    function parseWhileStatement(node) {\n        var test, body, oldInIteration;\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        return node.finishWhileStatement(test, body);\n    }\n\n    function parseForStatement(node) {\n        var init, forIn, initSeq, initStartToken, test, update, left, right, kind, declarations,\n            body, oldInIteration, previousAllowIn = state.allowIn;\n\n        init = test = update = null;\n        forIn = true;\n\n        expectKeyword('for');\n\n        expect('(');\n\n        if (match(';')) {\n            lex();\n        } else {\n            if (matchKeyword('var')) {\n                init = new Node();\n                lex();\n\n                state.allowIn = false;\n                declarations = parseVariableDeclarationList({ inFor: true });\n                state.allowIn = previousAllowIn;\n\n                if (declarations.length === 1 && matchKeyword('in')) {\n                    init = init.finishVariableDeclaration(declarations);\n                    lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                } else if (declarations.length === 1 && declarations[0].init === null && matchContextualKeyword('of')) {\n                    init = init.finishVariableDeclaration(declarations);\n                    lex();\n                    left = init;\n                    right = parseAssignmentExpression();\n                    init = null;\n                    forIn = false;\n                } else {\n                    init = init.finishVariableDeclaration(declarations);\n                    expect(';');\n                }\n            } else if (matchKeyword('const') || matchKeyword('let')) {\n                init = new Node();\n                kind = lex().value;\n\n                if (!strict && lookahead.value === 'in') {\n                    init = init.finishIdentifier(kind);\n                    lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                } else {\n                    state.allowIn = false;\n                    declarations = parseBindingList(kind, {inFor: true});\n                    state.allowIn = previousAllowIn;\n\n                    if (declarations.length === 1 && declarations[0].init === null && matchKeyword('in')) {\n                        init = init.finishLexicalDeclaration(declarations, kind);\n                        lex();\n                        left = init;\n                        right = parseExpression();\n                        init = null;\n                    } else if (declarations.length === 1 && declarations[0].init === null && matchContextualKeyword('of')) {\n                        init = init.finishLexicalDeclaration(declarations, kind);\n                        lex();\n                        left = init;\n                        right = parseAssignmentExpression();\n                        init = null;\n                        forIn = false;\n                    } else {\n                        consumeSemicolon();\n                        init = init.finishLexicalDeclaration(declarations, kind);\n                    }\n                }\n            } else {\n                initStartToken = lookahead;\n                state.allowIn = false;\n                init = inheritCoverGrammar(parseAssignmentExpression);\n                state.allowIn = previousAllowIn;\n\n                if (matchKeyword('in')) {\n                    if (!isAssignmentTarget) {\n                        tolerateError(Messages.InvalidLHSInForIn);\n                    }\n\n                    lex();\n                    reinterpretExpressionAsPattern(init);\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                } else if (matchContextualKeyword('of')) {\n                    if (!isAssignmentTarget) {\n                        tolerateError(Messages.InvalidLHSInForLoop);\n                    }\n\n                    lex();\n                    reinterpretExpressionAsPattern(init);\n                    left = init;\n                    right = parseAssignmentExpression();\n                    init = null;\n                    forIn = false;\n                } else {\n                    if (match(',')) {\n                        initSeq = [init];\n                        while (match(',')) {\n                            lex();\n                            initSeq.push(isolateCoverGrammar(parseAssignmentExpression));\n                        }\n                        init = new WrappingNode(initStartToken).finishSequenceExpression(initSeq);\n                    }\n                    expect(';');\n                }\n            }\n        }\n\n        if (typeof left === 'undefined') {\n\n            if (!match(';')) {\n                test = parseExpression();\n            }\n            expect(';');\n\n            if (!match(')')) {\n                update = parseExpression();\n            }\n        }\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = isolateCoverGrammar(parseStatement);\n\n        state.inIteration = oldInIteration;\n\n        return (typeof left === 'undefined') ?\n                node.finishForStatement(init, test, update, body) :\n                forIn ? node.finishForInStatement(left, right, body) :\n                    node.finishForOfStatement(left, right, body);\n    }\n\n    // ECMA-262 13.8 The continue statement\n\n    function parseContinueStatement(node) {\n        var label = null, key;\n\n        expectKeyword('continue');\n\n        // Optimize the most common form: 'continue;'.\n        if (source.charCodeAt(startIndex) === 0x3B) {\n            lex();\n\n            if (!state.inIteration) {\n                throwError(Messages.IllegalContinue);\n            }\n\n            return node.finishContinueStatement(null);\n        }\n\n        if (hasLineTerminator) {\n            if (!state.inIteration) {\n                throwError(Messages.IllegalContinue);\n            }\n\n            return node.finishContinueStatement(null);\n        }\n\n        if (lookahead.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            key = '$' + label.name;\n            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError(Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !state.inIteration) {\n            throwError(Messages.IllegalContinue);\n        }\n\n        return node.finishContinueStatement(label);\n    }\n\n    // ECMA-262 13.9 The break statement\n\n    function parseBreakStatement(node) {\n        var label = null, key;\n\n        expectKeyword('break');\n\n        // Catch the very common case first: immediately a semicolon (U+003B).\n        if (source.charCodeAt(lastIndex) === 0x3B) {\n            lex();\n\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError(Messages.IllegalBreak);\n            }\n\n            return node.finishBreakStatement(null);\n        }\n\n        if (hasLineTerminator) {\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError(Messages.IllegalBreak);\n            }\n        } else if (lookahead.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            key = '$' + label.name;\n            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError(Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !(state.inIteration || state.inSwitch)) {\n            throwError(Messages.IllegalBreak);\n        }\n\n        return node.finishBreakStatement(label);\n    }\n\n    // ECMA-262 13.10 The return statement\n\n    function parseReturnStatement(node) {\n        var argument = null;\n\n        expectKeyword('return');\n\n        if (!state.inFunctionBody) {\n            tolerateError(Messages.IllegalReturn);\n        }\n\n        // 'return' followed by a space and an identifier is very common.\n        if (source.charCodeAt(lastIndex) === 0x20) {\n            if (isIdentifierStart(source.charCodeAt(lastIndex + 1))) {\n                argument = parseExpression();\n                consumeSemicolon();\n                return node.finishReturnStatement(argument);\n            }\n        }\n\n        if (hasLineTerminator) {\n            // HACK\n            return node.finishReturnStatement(null);\n        }\n\n        if (!match(';')) {\n            if (!match('}') && lookahead.type !== Token.EOF) {\n                argument = parseExpression();\n            }\n        }\n\n        consumeSemicolon();\n\n        return node.finishReturnStatement(argument);\n    }\n\n    // ECMA-262 13.11 The with statement\n\n    function parseWithStatement(node) {\n        var object, body;\n\n        if (strict) {\n            tolerateError(Messages.StrictModeWith);\n        }\n\n        expectKeyword('with');\n\n        expect('(');\n\n        object = parseExpression();\n\n        expect(')');\n\n        body = parseStatement();\n\n        return node.finishWithStatement(object, body);\n    }\n\n    // ECMA-262 13.12 The switch statement\n\n    function parseSwitchCase() {\n        var test, consequent = [], statement, node = new Node();\n\n        if (matchKeyword('default')) {\n            lex();\n            test = null;\n        } else {\n            expectKeyword('case');\n            test = parseExpression();\n        }\n        expect(':');\n\n        while (startIndex < length) {\n            if (match('}') || matchKeyword('default') || matchKeyword('case')) {\n                break;\n            }\n            statement = parseStatementListItem();\n            consequent.push(statement);\n        }\n\n        return node.finishSwitchCase(test, consequent);\n    }\n\n    function parseSwitchStatement(node) {\n        var discriminant, cases, clause, oldInSwitch, defaultFound;\n\n        expectKeyword('switch');\n\n        expect('(');\n\n        discriminant = parseExpression();\n\n        expect(')');\n\n        expect('{');\n\n        cases = [];\n\n        if (match('}')) {\n            lex();\n            return node.finishSwitchStatement(discriminant, cases);\n        }\n\n        oldInSwitch = state.inSwitch;\n        state.inSwitch = true;\n        defaultFound = false;\n\n        while (startIndex < length) {\n            if (match('}')) {\n                break;\n            }\n            clause = parseSwitchCase();\n            if (clause.test === null) {\n                if (defaultFound) {\n                    throwError(Messages.MultipleDefaultsInSwitch);\n                }\n                defaultFound = true;\n            }\n            cases.push(clause);\n        }\n\n        state.inSwitch = oldInSwitch;\n\n        expect('}');\n\n        return node.finishSwitchStatement(discriminant, cases);\n    }\n\n    // ECMA-262 13.14 The throw statement\n\n    function parseThrowStatement(node) {\n        var argument;\n\n        expectKeyword('throw');\n\n        if (hasLineTerminator) {\n            throwError(Messages.NewlineAfterThrow);\n        }\n\n        argument = parseExpression();\n\n        consumeSemicolon();\n\n        return node.finishThrowStatement(argument);\n    }\n\n    // ECMA-262 13.15 The try statement\n\n    function parseCatchClause() {\n        var param, params = [], paramMap = {}, key, i, body, node = new Node();\n\n        expectKeyword('catch');\n\n        expect('(');\n        if (match(')')) {\n            throwUnexpectedToken(lookahead);\n        }\n\n        param = parsePattern(params);\n        for (i = 0; i < params.length; i++) {\n            key = '$' + params[i].value;\n            if (Object.prototype.hasOwnProperty.call(paramMap, key)) {\n                tolerateError(Messages.DuplicateBinding, params[i].value);\n            }\n            paramMap[key] = true;\n        }\n\n        // ECMA-262 12.14.1\n        if (strict && isRestrictedWord(param.name)) {\n            tolerateError(Messages.StrictCatchVariable);\n        }\n\n        expect(')');\n        body = parseBlock();\n        return node.finishCatchClause(param, body);\n    }\n\n    function parseTryStatement(node) {\n        var block, handler = null, finalizer = null;\n\n        expectKeyword('try');\n\n        block = parseBlock();\n\n        if (matchKeyword('catch')) {\n            handler = parseCatchClause();\n        }\n\n        if (matchKeyword('finally')) {\n            lex();\n            finalizer = parseBlock();\n        }\n\n        if (!handler && !finalizer) {\n            throwError(Messages.NoCatchOrFinally);\n        }\n\n        return node.finishTryStatement(block, handler, finalizer);\n    }\n\n    // ECMA-262 13.16 The debugger statement\n\n    function parseDebuggerStatement(node) {\n        expectKeyword('debugger');\n\n        consumeSemicolon();\n\n        return node.finishDebuggerStatement();\n    }\n\n    // 13 Statements\n\n    function parseStatement() {\n        var type = lookahead.type,\n            expr,\n            labeledBody,\n            key,\n            node;\n\n        if (type === Token.EOF) {\n            throwUnexpectedToken(lookahead);\n        }\n\n        if (type === Token.Punctuator && lookahead.value === '{') {\n            return parseBlock();\n        }\n        isAssignmentTarget = isBindingElement = true;\n        node = new Node();\n\n        if (type === Token.Punctuator) {\n            switch (lookahead.value) {\n            case ';':\n                return parseEmptyStatement(node);\n            case '(':\n                return parseExpressionStatement(node);\n            default:\n                break;\n            }\n        } else if (type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'break':\n                return parseBreakStatement(node);\n            case 'continue':\n                return parseContinueStatement(node);\n            case 'debugger':\n                return parseDebuggerStatement(node);\n            case 'do':\n                return parseDoWhileStatement(node);\n            case 'for':\n                return parseForStatement(node);\n            case 'function':\n                return parseFunctionDeclaration(node);\n            case 'if':\n                return parseIfStatement(node);\n            case 'return':\n                return parseReturnStatement(node);\n            case 'switch':\n                return parseSwitchStatement(node);\n            case 'throw':\n                return parseThrowStatement(node);\n            case 'try':\n                return parseTryStatement(node);\n            case 'var':\n                return parseVariableStatement(node);\n            case 'while':\n                return parseWhileStatement(node);\n            case 'with':\n                return parseWithStatement(node);\n            default:\n                break;\n            }\n        }\n\n        expr = parseExpression();\n\n        // ECMA-262 12.12 Labelled Statements\n        if ((expr.type === Syntax.Identifier) && match(':')) {\n            lex();\n\n            key = '$' + expr.name;\n            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError(Messages.Redeclaration, 'Label', expr.name);\n            }\n\n            state.labelSet[key] = true;\n            labeledBody = parseStatement();\n            delete state.labelSet[key];\n            return node.finishLabeledStatement(expr, labeledBody);\n        }\n\n        consumeSemicolon();\n\n        return node.finishExpressionStatement(expr);\n    }\n\n    // ECMA-262 14.1 Function Definition\n\n    function parseFunctionSourceElements() {\n        var statement, body = [], token, directive, firstRestricted,\n            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody,\n            node = new Node();\n\n        expect('{');\n\n        while (startIndex < length) {\n            if (lookahead.type !== Token.StringLiteral) {\n                break;\n            }\n            token = lookahead;\n\n            statement = parseStatementListItem();\n            body.push(statement);\n            if (statement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = source.slice(token.start + 1, token.end - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        oldLabelSet = state.labelSet;\n        oldInIteration = state.inIteration;\n        oldInSwitch = state.inSwitch;\n        oldInFunctionBody = state.inFunctionBody;\n\n        state.labelSet = {};\n        state.inIteration = false;\n        state.inSwitch = false;\n        state.inFunctionBody = true;\n\n        while (startIndex < length) {\n            if (match('}')) {\n                break;\n            }\n            body.push(parseStatementListItem());\n        }\n\n        expect('}');\n\n        state.labelSet = oldLabelSet;\n        state.inIteration = oldInIteration;\n        state.inSwitch = oldInSwitch;\n        state.inFunctionBody = oldInFunctionBody;\n\n        return node.finishBlockStatement(body);\n    }\n\n    function validateParam(options, param, name) {\n        var key = '$' + name;\n        if (strict) {\n            if (isRestrictedWord(name)) {\n                options.stricted = param;\n                options.message = Messages.StrictParamName;\n            }\n            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {\n                options.stricted = param;\n                options.message = Messages.StrictParamDupe;\n            }\n        } else if (!options.firstRestricted) {\n            if (isRestrictedWord(name)) {\n                options.firstRestricted = param;\n                options.message = Messages.StrictParamName;\n            } else if (isStrictModeReservedWord(name)) {\n                options.firstRestricted = param;\n                options.message = Messages.StrictReservedWord;\n            } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {\n                options.stricted = param;\n                options.message = Messages.StrictParamDupe;\n            }\n        }\n        options.paramSet[key] = true;\n    }\n\n    function parseParam(options) {\n        var token, param, params = [], i, def;\n\n        token = lookahead;\n        if (token.value === '...') {\n            param = parseRestElement(params);\n            validateParam(options, param.argument, param.argument.name);\n            options.params.push(param);\n            options.defaults.push(null);\n            return false;\n        }\n\n        param = parsePatternWithDefault(params);\n        for (i = 0; i < params.length; i++) {\n            validateParam(options, params[i], params[i].value);\n        }\n\n        if (param.type === Syntax.AssignmentPattern) {\n            def = param.right;\n            param = param.left;\n            ++options.defaultCount;\n        }\n\n        options.params.push(param);\n        options.defaults.push(def);\n\n        return !match(')');\n    }\n\n    function parseParams(firstRestricted) {\n        var options;\n\n        options = {\n            params: [],\n            defaultCount: 0,\n            defaults: [],\n            firstRestricted: firstRestricted\n        };\n\n        expect('(');\n\n        if (!match(')')) {\n            options.paramSet = {};\n            while (startIndex < length) {\n                if (!parseParam(options)) {\n                    break;\n                }\n                expect(',');\n            }\n        }\n\n        expect(')');\n\n        if (options.defaultCount === 0) {\n            options.defaults = [];\n        }\n\n        return {\n            params: options.params,\n            defaults: options.defaults,\n            stricted: options.stricted,\n            firstRestricted: options.firstRestricted,\n            message: options.message\n        };\n    }\n\n    function parseFunctionDeclaration(node, identifierIsOptional) {\n        var id = null, params = [], defaults = [], body, token, stricted, tmp, firstRestricted, message, previousStrict,\n            isGenerator, previousAllowYield;\n\n        previousAllowYield = state.allowYield;\n\n        expectKeyword('function');\n\n        isGenerator = match('*');\n        if (isGenerator) {\n            lex();\n        }\n\n        if (!identifierIsOptional || !match('(')) {\n            token = lookahead;\n            id = parseVariableIdentifier();\n            if (strict) {\n                if (isRestrictedWord(token.value)) {\n                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);\n                }\n            } else {\n                if (isRestrictedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictFunctionName;\n                } else if (isStrictModeReservedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictReservedWord;\n                }\n            }\n        }\n\n        state.allowYield = !isGenerator;\n        tmp = parseParams(firstRestricted);\n        params = tmp.params;\n        defaults = tmp.defaults;\n        stricted = tmp.stricted;\n        firstRestricted = tmp.firstRestricted;\n        if (tmp.message) {\n            message = tmp.message;\n        }\n\n\n        previousStrict = strict;\n        body = parseFunctionSourceElements();\n        if (strict && firstRestricted) {\n            throwUnexpectedToken(firstRestricted, message);\n        }\n        if (strict && stricted) {\n            tolerateUnexpectedToken(stricted, message);\n        }\n\n        strict = previousStrict;\n        state.allowYield = previousAllowYield;\n\n        return node.finishFunctionDeclaration(id, params, defaults, body, isGenerator);\n    }\n\n    function parseFunctionExpression() {\n        var token, id = null, stricted, firstRestricted, message, tmp,\n            params = [], defaults = [], body, previousStrict, node = new Node(),\n            isGenerator, previousAllowYield;\n\n        previousAllowYield = state.allowYield;\n\n        expectKeyword('function');\n\n        isGenerator = match('*');\n        if (isGenerator) {\n            lex();\n        }\n\n        state.allowYield = !isGenerator;\n        if (!match('(')) {\n            token = lookahead;\n            id = (!strict && !isGenerator && matchKeyword('yield')) ? parseNonComputedProperty() : parseVariableIdentifier();\n            if (strict) {\n                if (isRestrictedWord(token.value)) {\n                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);\n                }\n            } else {\n                if (isRestrictedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictFunctionName;\n                } else if (isStrictModeReservedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictReservedWord;\n                }\n            }\n        }\n\n        tmp = parseParams(firstRestricted);\n        params = tmp.params;\n        defaults = tmp.defaults;\n        stricted = tmp.stricted;\n        firstRestricted = tmp.firstRestricted;\n        if (tmp.message) {\n            message = tmp.message;\n        }\n\n        previousStrict = strict;\n        body = parseFunctionSourceElements();\n        if (strict && firstRestricted) {\n            throwUnexpectedToken(firstRestricted, message);\n        }\n        if (strict && stricted) {\n            tolerateUnexpectedToken(stricted, message);\n        }\n        strict = previousStrict;\n        state.allowYield = previousAllowYield;\n\n        return node.finishFunctionExpression(id, params, defaults, body, isGenerator);\n    }\n\n    // ECMA-262 14.5 Class Definitions\n\n    function parseClassBody() {\n        var classBody, token, isStatic, hasConstructor = false, body, method, computed, key;\n\n        classBody = new Node();\n\n        expect('{');\n        body = [];\n        while (!match('}')) {\n            if (match(';')) {\n                lex();\n            } else {\n                method = new Node();\n                token = lookahead;\n                isStatic = false;\n                computed = match('[');\n                if (match('*')) {\n                    lex();\n                } else {\n                    key = parseObjectPropertyKey();\n                    if (key.name === 'static' && (lookaheadPropertyName() || match('*'))) {\n                        token = lookahead;\n                        isStatic = true;\n                        computed = match('[');\n                        if (match('*')) {\n                            lex();\n                        } else {\n                            key = parseObjectPropertyKey();\n                        }\n                    }\n                }\n                method = tryParseMethodDefinition(token, key, computed, method);\n                if (method) {\n                    method['static'] = isStatic; // jscs:ignore requireDotNotation\n                    if (method.kind === 'init') {\n                        method.kind = 'method';\n                    }\n                    if (!isStatic) {\n                        if (!method.computed && (method.key.name || method.key.value.toString()) === 'constructor') {\n                            if (method.kind !== 'method' || !method.method || method.value.generator) {\n                                throwUnexpectedToken(token, Messages.ConstructorSpecialMethod);\n                            }\n                            if (hasConstructor) {\n                                throwUnexpectedToken(token, Messages.DuplicateConstructor);\n                            } else {\n                                hasConstructor = true;\n                            }\n                            method.kind = 'constructor';\n                        }\n                    } else {\n                        if (!method.computed && (method.key.name || method.key.value.toString()) === 'prototype') {\n                            throwUnexpectedToken(token, Messages.StaticPrototype);\n                        }\n                    }\n                    method.type = Syntax.MethodDefinition;\n                    delete method.method;\n                    delete method.shorthand;\n                    body.push(method);\n                } else {\n                    throwUnexpectedToken(lookahead);\n                }\n            }\n        }\n        lex();\n        return classBody.finishClassBody(body);\n    }\n\n    function parseClassDeclaration(identifierIsOptional) {\n        var id = null, superClass = null, classNode = new Node(), classBody, previousStrict = strict;\n        strict = true;\n\n        expectKeyword('class');\n\n        if (!identifierIsOptional || lookahead.type === Token.Identifier) {\n            id = parseVariableIdentifier();\n        }\n\n        if (matchKeyword('extends')) {\n            lex();\n            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);\n        }\n        classBody = parseClassBody();\n        strict = previousStrict;\n\n        return classNode.finishClassDeclaration(id, superClass, classBody);\n    }\n\n    function parseClassExpression() {\n        var id = null, superClass = null, classNode = new Node(), classBody, previousStrict = strict;\n        strict = true;\n\n        expectKeyword('class');\n\n        if (lookahead.type === Token.Identifier) {\n            id = parseVariableIdentifier();\n        }\n\n        if (matchKeyword('extends')) {\n            lex();\n            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);\n        }\n        classBody = parseClassBody();\n        strict = previousStrict;\n\n        return classNode.finishClassExpression(id, superClass, classBody);\n    }\n\n    // ECMA-262 15.2 Modules\n\n    function parseModuleSpecifier() {\n        var node = new Node();\n\n        if (lookahead.type !== Token.StringLiteral) {\n            throwError(Messages.InvalidModuleSpecifier);\n        }\n        return node.finishLiteral(lex());\n    }\n\n    // ECMA-262 15.2.3 Exports\n\n    function parseExportSpecifier() {\n        var exported, local, node = new Node(), def;\n        if (matchKeyword('default')) {\n            // export {default} from 'something';\n            def = new Node();\n            lex();\n            local = def.finishIdentifier('default');\n        } else {\n            local = parseVariableIdentifier();\n        }\n        if (matchContextualKeyword('as')) {\n            lex();\n            exported = parseNonComputedProperty();\n        }\n        return node.finishExportSpecifier(local, exported);\n    }\n\n    function parseExportNamedDeclaration(node) {\n        var declaration = null,\n            isExportFromIdentifier,\n            src = null, specifiers = [];\n\n        // non-default export\n        if (lookahead.type === Token.Keyword) {\n            // covers:\n            // export var f = 1;\n            switch (lookahead.value) {\n                case 'let':\n                case 'const':\n                    declaration = parseLexicalDeclaration({inFor: false});\n                    return node.finishExportNamedDeclaration(declaration, specifiers, null);\n                case 'var':\n                case 'class':\n                case 'function':\n                    declaration = parseStatementListItem();\n                    return node.finishExportNamedDeclaration(declaration, specifiers, null);\n            }\n        }\n\n        expect('{');\n        while (!match('}')) {\n            isExportFromIdentifier = isExportFromIdentifier || matchKeyword('default');\n            specifiers.push(parseExportSpecifier());\n            if (!match('}')) {\n                expect(',');\n                if (match('}')) {\n                    break;\n                }\n            }\n        }\n        expect('}');\n\n        if (matchContextualKeyword('from')) {\n            // covering:\n            // export {default} from 'foo';\n            // export {foo} from 'foo';\n            lex();\n            src = parseModuleSpecifier();\n            consumeSemicolon();\n        } else if (isExportFromIdentifier) {\n            // covering:\n            // export {default}; // missing fromClause\n            throwError(lookahead.value ?\n                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n        } else {\n            // cover\n            // export {foo};\n            consumeSemicolon();\n        }\n        return node.finishExportNamedDeclaration(declaration, specifiers, src);\n    }\n\n    function parseExportDefaultDeclaration(node) {\n        var declaration = null,\n            expression = null;\n\n        // covers:\n        // export default ...\n        expectKeyword('default');\n\n        if (matchKeyword('function')) {\n            // covers:\n            // export default function foo () {}\n            // export default function () {}\n            declaration = parseFunctionDeclaration(new Node(), true);\n            return node.finishExportDefaultDeclaration(declaration);\n        }\n        if (matchKeyword('class')) {\n            declaration = parseClassDeclaration(true);\n            return node.finishExportDefaultDeclaration(declaration);\n        }\n\n        if (matchContextualKeyword('from')) {\n            throwError(Messages.UnexpectedToken, lookahead.value);\n        }\n\n        // covers:\n        // export default {};\n        // export default [];\n        // export default (1 + 2);\n        if (match('{')) {\n            expression = parseObjectInitializer();\n        } else if (match('[')) {\n            expression = parseArrayInitializer();\n        } else {\n            expression = parseAssignmentExpression();\n        }\n        consumeSemicolon();\n        return node.finishExportDefaultDeclaration(expression);\n    }\n\n    function parseExportAllDeclaration(node) {\n        var src;\n\n        // covers:\n        // export * from 'foo';\n        expect('*');\n        if (!matchContextualKeyword('from')) {\n            throwError(lookahead.value ?\n                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n        }\n        lex();\n        src = parseModuleSpecifier();\n        consumeSemicolon();\n\n        return node.finishExportAllDeclaration(src);\n    }\n\n    function parseExportDeclaration() {\n        var node = new Node();\n        if (state.inFunctionBody) {\n            throwError(Messages.IllegalExportDeclaration);\n        }\n\n        expectKeyword('export');\n\n        if (matchKeyword('default')) {\n            return parseExportDefaultDeclaration(node);\n        }\n        if (match('*')) {\n            return parseExportAllDeclaration(node);\n        }\n        return parseExportNamedDeclaration(node);\n    }\n\n    // ECMA-262 15.2.2 Imports\n\n    function parseImportSpecifier() {\n        // import {<foo as bar>} ...;\n        var local, imported, node = new Node();\n\n        imported = parseNonComputedProperty();\n        if (matchContextualKeyword('as')) {\n            lex();\n            local = parseVariableIdentifier();\n        }\n\n        return node.finishImportSpecifier(local, imported);\n    }\n\n    function parseNamedImports() {\n        var specifiers = [];\n        // {foo, bar as bas}\n        expect('{');\n        while (!match('}')) {\n            specifiers.push(parseImportSpecifier());\n            if (!match('}')) {\n                expect(',');\n                if (match('}')) {\n                    break;\n                }\n            }\n        }\n        expect('}');\n        return specifiers;\n    }\n\n    function parseImportDefaultSpecifier() {\n        // import <foo> ...;\n        var local, node = new Node();\n\n        local = parseNonComputedProperty();\n\n        return node.finishImportDefaultSpecifier(local);\n    }\n\n    function parseImportNamespaceSpecifier() {\n        // import <* as foo> ...;\n        var local, node = new Node();\n\n        expect('*');\n        if (!matchContextualKeyword('as')) {\n            throwError(Messages.NoAsAfterImportNamespace);\n        }\n        lex();\n        local = parseNonComputedProperty();\n\n        return node.finishImportNamespaceSpecifier(local);\n    }\n\n    function parseImportDeclaration() {\n        var specifiers = [], src, node = new Node();\n\n        if (state.inFunctionBody) {\n            throwError(Messages.IllegalImportDeclaration);\n        }\n\n        expectKeyword('import');\n\n        if (lookahead.type === Token.StringLiteral) {\n            // import 'foo';\n            src = parseModuleSpecifier();\n        } else {\n\n            if (match('{')) {\n                // import {bar}\n                specifiers = specifiers.concat(parseNamedImports());\n            } else if (match('*')) {\n                // import * as foo\n                specifiers.push(parseImportNamespaceSpecifier());\n            } else if (isIdentifierName(lookahead) && !matchKeyword('default')) {\n                // import foo\n                specifiers.push(parseImportDefaultSpecifier());\n                if (match(',')) {\n                    lex();\n                    if (match('*')) {\n                        // import foo, * as foo\n                        specifiers.push(parseImportNamespaceSpecifier());\n                    } else if (match('{')) {\n                        // import foo, {bar}\n                        specifiers = specifiers.concat(parseNamedImports());\n                    } else {\n                        throwUnexpectedToken(lookahead);\n                    }\n                }\n            } else {\n                throwUnexpectedToken(lex());\n            }\n\n            if (!matchContextualKeyword('from')) {\n                throwError(lookahead.value ?\n                        Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n            }\n            lex();\n            src = parseModuleSpecifier();\n        }\n\n        consumeSemicolon();\n        return node.finishImportDeclaration(specifiers, src);\n    }\n\n    // ECMA-262 15.1 Scripts\n\n    function parseScriptBody() {\n        var statement, body = [], token, directive, firstRestricted;\n\n        while (startIndex < length) {\n            token = lookahead;\n            if (token.type !== Token.StringLiteral) {\n                break;\n            }\n\n            statement = parseStatementListItem();\n            body.push(statement);\n            if (statement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = source.slice(token.start + 1, token.end - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        while (startIndex < length) {\n            statement = parseStatementListItem();\n            /* istanbul ignore if */\n            if (typeof statement === 'undefined') {\n                break;\n            }\n            body.push(statement);\n        }\n        return body;\n    }\n\n    function parseProgram() {\n        var body, node;\n\n        peek();\n        node = new Node();\n\n        body = parseScriptBody();\n        return node.finishProgram(body, state.sourceType);\n    }\n\n    function filterTokenLocation() {\n        var i, entry, token, tokens = [];\n\n        for (i = 0; i < extra.tokens.length; ++i) {\n            entry = extra.tokens[i];\n            token = {\n                type: entry.type,\n                value: entry.value\n            };\n            if (entry.regex) {\n                token.regex = {\n                    pattern: entry.regex.pattern,\n                    flags: entry.regex.flags\n                };\n            }\n            if (extra.range) {\n                token.range = entry.range;\n            }\n            if (extra.loc) {\n                token.loc = entry.loc;\n            }\n            tokens.push(token);\n        }\n\n        extra.tokens = tokens;\n    }\n\n    function tokenize(code, options, delegate) {\n        var toString,\n            tokens;\n\n        toString = String;\n        if (typeof code !== 'string' && !(code instanceof String)) {\n            code = toString(code);\n        }\n\n        source = code;\n        index = 0;\n        lineNumber = (source.length > 0) ? 1 : 0;\n        lineStart = 0;\n        startIndex = index;\n        startLineNumber = lineNumber;\n        startLineStart = lineStart;\n        length = source.length;\n        lookahead = null;\n        state = {\n            allowIn: true,\n            allowYield: true,\n            labelSet: {},\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false,\n            lastCommentStart: -1,\n            curlyStack: []\n        };\n\n        extra = {};\n\n        // Options matching.\n        options = options || {};\n\n        // Of course we collect tokens here.\n        options.tokens = true;\n        extra.tokens = [];\n        extra.tokenValues = [];\n        extra.tokenize = true;\n        extra.delegate = delegate;\n\n        // The following two fields are necessary to compute the Regex tokens.\n        extra.openParenToken = -1;\n        extra.openCurlyToken = -1;\n\n        extra.range = (typeof options.range === 'boolean') && options.range;\n        extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n        if (typeof options.comment === 'boolean' && options.comment) {\n            extra.comments = [];\n        }\n        if (typeof options.tolerant === 'boolean' && options.tolerant) {\n            extra.errors = [];\n        }\n\n        try {\n            peek();\n            if (lookahead.type === Token.EOF) {\n                return extra.tokens;\n            }\n\n            lex();\n            while (lookahead.type !== Token.EOF) {\n                try {\n                    lex();\n                } catch (lexError) {\n                    if (extra.errors) {\n                        recordError(lexError);\n                        // We have to break on the first error\n                        // to avoid infinite loops.\n                        break;\n                    } else {\n                        throw lexError;\n                    }\n                }\n            }\n\n            tokens = extra.tokens;\n            if (typeof extra.errors !== 'undefined') {\n                tokens.errors = extra.errors;\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            extra = {};\n        }\n        return tokens;\n    }\n\n    function parse(code, options) {\n        var program, toString;\n\n        toString = String;\n        if (typeof code !== 'string' && !(code instanceof String)) {\n            code = toString(code);\n        }\n\n        source = code;\n        index = 0;\n        lineNumber = (source.length > 0) ? 1 : 0;\n        lineStart = 0;\n        startIndex = index;\n        startLineNumber = lineNumber;\n        startLineStart = lineStart;\n        length = source.length;\n        lookahead = null;\n        state = {\n            allowIn: true,\n            allowYield: true,\n            labelSet: {},\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false,\n            lastCommentStart: -1,\n            curlyStack: [],\n            sourceType: 'script'\n        };\n        strict = false;\n\n        extra = {};\n        if (typeof options !== 'undefined') {\n            extra.range = (typeof options.range === 'boolean') && options.range;\n            extra.loc = (typeof options.loc === 'boolean') && options.loc;\n            extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;\n\n            if (extra.loc && options.source !== null && options.source !== undefined) {\n                extra.source = toString(options.source);\n            }\n\n            if (typeof options.tokens === 'boolean' && options.tokens) {\n                extra.tokens = [];\n            }\n            if (typeof options.comment === 'boolean' && options.comment) {\n                extra.comments = [];\n            }\n            if (typeof options.tolerant === 'boolean' && options.tolerant) {\n                extra.errors = [];\n            }\n            if (extra.attachComment) {\n                extra.range = true;\n                extra.comments = [];\n                extra.bottomRightStack = [];\n                extra.trailingComments = [];\n                extra.leadingComments = [];\n            }\n            if (options.sourceType === 'module') {\n                // very restrictive condition for now\n                state.sourceType = options.sourceType;\n                strict = true;\n            }\n        }\n\n        try {\n            program = parseProgram();\n            if (typeof extra.comments !== 'undefined') {\n                program.comments = extra.comments;\n            }\n            if (typeof extra.tokens !== 'undefined') {\n                filterTokenLocation();\n                program.tokens = extra.tokens;\n            }\n            if (typeof extra.errors !== 'undefined') {\n                program.errors = extra.errors;\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            extra = {};\n        }\n\n        return program;\n    }\n\n    // Sync with *.json manifests.\n    exports.version = '2.7.3';\n\n    exports.tokenize = tokenize;\n\n    exports.parse = parse;\n\n    // Deep copy.\n    /* istanbul ignore next */\n    exports.Syntax = (function () {\n        var name, types = {};\n\n        if (typeof Object.create === 'function') {\n            types = Object.create(null);\n        }\n\n        for (name in Syntax) {\n            if (Syntax.hasOwnProperty(name)) {\n                types[name] = Syntax[name];\n            }\n        }\n\n        if (typeof Object.freeze === 'function') {\n            Object.freeze(types);\n        }\n\n        return types;\n    }());\n\n}));\n/* vim: set sw=4 ts=4 et tw=80 : */\n"]},"metadata":{},"sourceType":"script"}