{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\"use strict\";\n\nclass HookCodeFactory {\n  constructor(config) {\n    this.config = config;\n    this.options = undefined;\n  }\n\n  create(options) {\n    this.init(options);\n\n    switch (this.options.type) {\n      case \"sync\":\n        return new Function(this.args(), \"\\\"use strict\\\";\\n\" + this.header() + this.content({\n          onError: err => `throw ${err};\\n`,\n          onResult: result => `return ${result};\\n`,\n          onDone: () => \"\",\n          rethrowIfPossible: true\n        }));\n\n      case \"async\":\n        return new Function(this.args({\n          after: \"_callback\"\n        }), \"\\\"use strict\\\";\\n\" + this.header() + this.content({\n          onError: err => `_callback(${err});\\n`,\n          onResult: result => `_callback(null, ${result});\\n`,\n          onDone: () => \"_callback();\\n\"\n        }));\n\n      case \"promise\":\n        let code = \"\";\n        code += \"\\\"use strict\\\";\\n\";\n        code += \"return new Promise((_resolve, _reject) => {\\n\";\n        code += \"var _sync = true;\\n\";\n        code += this.header();\n        code += this.content({\n          onError: err => {\n            let code = \"\";\n            code += \"if(_sync)\\n\";\n            code += `_resolve(Promise.resolve().then(() => { throw ${err}; }));\\n`;\n            code += \"else\\n\";\n            code += `_reject(${err});\\n`;\n            return code;\n          },\n          onResult: result => `_resolve(${result});\\n`,\n          onDone: () => \"_resolve();\\n\"\n        });\n        code += \"_sync = false;\\n\";\n        code += \"});\\n\";\n        return new Function(this.args(), code);\n    }\n  }\n\n  setup(instance, options) {\n    instance._x = options.taps.map(t => t.fn);\n  }\n  /**\r\n   * @param {{ type: \"sync\" | \"promise\" | \"async\", taps: Array<Tap>, interceptors: Array<Interceptor> }} options\r\n   */\n\n\n  init(options) {\n    this.options = options;\n    this._args = options.args.slice();\n  }\n\n  header() {\n    let code = \"\";\n\n    if (this.needContext()) {\n      code += \"var _context = {};\\n\";\n    } else {\n      code += \"var _context;\\n\";\n    }\n\n    code += \"var _x = this._x;\\n\";\n\n    if (this.options.interceptors.length > 0) {\n      code += \"var _taps = this.taps;\\n\";\n      code += \"var _interceptors = this.interceptors;\\n\";\n    }\n\n    for (let i = 0; i < this.options.interceptors.length; i++) {\n      const interceptor = this.options.interceptors[i];\n\n      if (interceptor.call) {\n        code += `${this.getInterceptor(i)}.call(${this.args({\n          before: interceptor.context ? \"_context\" : undefined\n        })});\\n`;\n      }\n    }\n\n    return code;\n  }\n\n  needContext() {\n    for (const tap of this.options.taps) if (tap.context) return true;\n\n    return false;\n  }\n\n  callTap(tapIndex, {\n    onError,\n    onResult,\n    onDone,\n    rethrowIfPossible\n  }) {\n    let code = \"\";\n    let hasTapCached = false;\n\n    for (let i = 0; i < this.options.interceptors.length; i++) {\n      const interceptor = this.options.interceptors[i];\n\n      if (interceptor.tap) {\n        if (!hasTapCached) {\n          code += `var _tap${tapIndex} = ${this.getTap(tapIndex)};\\n`;\n          hasTapCached = true;\n        }\n\n        code += `${this.getInterceptor(i)}.tap(${interceptor.context ? \"_context, \" : \"\"}_tap${tapIndex});\\n`;\n      }\n    }\n\n    code += `var _fn${tapIndex} = ${this.getTapFn(tapIndex)};\\n`;\n    const tap = this.options.taps[tapIndex];\n\n    switch (tap.type) {\n      case \"sync\":\n        if (!rethrowIfPossible) {\n          code += `var _hasError${tapIndex} = false;\\n`;\n          code += \"try {\\n\";\n        }\n\n        if (onResult) {\n          code += `var _result${tapIndex} = _fn${tapIndex}(${this.args({\n            before: tap.context ? \"_context\" : undefined\n          })});\\n`;\n        } else {\n          code += `_fn${tapIndex}(${this.args({\n            before: tap.context ? \"_context\" : undefined\n          })});\\n`;\n        }\n\n        if (!rethrowIfPossible) {\n          code += \"} catch(_err) {\\n\";\n          code += `_hasError${tapIndex} = true;\\n`;\n          code += onError(\"_err\");\n          code += \"}\\n\";\n          code += `if(!_hasError${tapIndex}) {\\n`;\n        }\n\n        if (onResult) {\n          code += onResult(`_result${tapIndex}`);\n        }\n\n        if (onDone) {\n          code += onDone();\n        }\n\n        if (!rethrowIfPossible) {\n          code += \"}\\n\";\n        }\n\n        break;\n\n      case \"async\":\n        let cbCode = \"\";\n        if (onResult) cbCode += `(_err${tapIndex}, _result${tapIndex}) => {\\n`;else cbCode += `_err${tapIndex} => {\\n`;\n        cbCode += `if(_err${tapIndex}) {\\n`;\n        cbCode += onError(`_err${tapIndex}`);\n        cbCode += \"} else {\\n\";\n\n        if (onResult) {\n          cbCode += onResult(`_result${tapIndex}`);\n        }\n\n        if (onDone) {\n          cbCode += onDone();\n        }\n\n        cbCode += \"}\\n\";\n        cbCode += \"}\";\n        code += `_fn${tapIndex}(${this.args({\n          before: tap.context ? \"_context\" : undefined,\n          after: cbCode\n        })});\\n`;\n        break;\n\n      case \"promise\":\n        code += `var _hasResult${tapIndex} = false;\\n`;\n        code += `_fn${tapIndex}(${this.args({\n          before: tap.context ? \"_context\" : undefined\n        })}).then(_result${tapIndex} => {\\n`;\n        code += `_hasResult${tapIndex} = true;\\n`;\n\n        if (onResult) {\n          code += onResult(`_result${tapIndex}`);\n        }\n\n        if (onDone) {\n          code += onDone();\n        }\n\n        code += `}, _err${tapIndex} => {\\n`;\n        code += `if(_hasResult${tapIndex}) throw _err${tapIndex};\\n`;\n        code += onError(`_err${tapIndex}`);\n        code += \"});\\n\";\n        break;\n    }\n\n    return code;\n  }\n\n  callTapsSeries({\n    onError,\n    onResult,\n    onDone,\n    rethrowIfPossible\n  }) {\n    if (this.options.taps.length === 0) return onDone();\n    const firstAsync = this.options.taps.findIndex(t => t.type !== \"sync\");\n\n    const next = i => {\n      if (i >= this.options.taps.length) {\n        return onDone();\n      }\n\n      const done = () => next(i + 1);\n\n      const doneBreak = skipDone => {\n        if (skipDone) return \"\";\n        return onDone();\n      };\n\n      return this.callTap(i, {\n        onError: error => onError(i, error, done, doneBreak),\n        onResult: onResult && (result => {\n          return onResult(i, result, done, doneBreak);\n        }),\n        onDone: !onResult && (() => {\n          return done();\n        }),\n        rethrowIfPossible: rethrowIfPossible && (firstAsync < 0 || i < firstAsync)\n      });\n    };\n\n    return next(0);\n  }\n\n  callTapsLooping({\n    onError,\n    onDone,\n    rethrowIfPossible\n  }) {\n    if (this.options.taps.length === 0) return onDone();\n    const syncOnly = this.options.taps.every(t => t.type === \"sync\");\n    let code = \"\";\n\n    if (!syncOnly) {\n      code += \"var _looper = () => {\\n\";\n      code += \"var _loopAsync = false;\\n\";\n    }\n\n    code += \"var _loop;\\n\";\n    code += \"do {\\n\";\n    code += \"_loop = false;\\n\";\n\n    for (let i = 0; i < this.options.interceptors.length; i++) {\n      const interceptor = this.options.interceptors[i];\n\n      if (interceptor.loop) {\n        code += `${this.getInterceptor(i)}.loop(${this.args({\n          before: interceptor.context ? \"_context\" : undefined\n        })});\\n`;\n      }\n    }\n\n    code += this.callTapsSeries({\n      onError,\n      onResult: (i, result, next, doneBreak) => {\n        let code = \"\";\n        code += `if(${result} !== undefined) {\\n`;\n        code += \"_loop = true;\\n\";\n        if (!syncOnly) code += \"if(_loopAsync) _looper();\\n\";\n        code += doneBreak(true);\n        code += `} else {\\n`;\n        code += next();\n        code += `}\\n`;\n        return code;\n      },\n      onDone: onDone && (() => {\n        let code = \"\";\n        code += \"if(!_loop) {\\n\";\n        code += onDone();\n        code += \"}\\n\";\n        return code;\n      }),\n      rethrowIfPossible: rethrowIfPossible && syncOnly\n    });\n    code += \"} while(_loop);\\n\";\n\n    if (!syncOnly) {\n      code += \"_loopAsync = true;\\n\";\n      code += \"};\\n\";\n      code += \"_looper();\\n\";\n    }\n\n    return code;\n  }\n\n  callTapsParallel({\n    onError,\n    onResult,\n    onDone,\n    rethrowIfPossible,\n    onTap = (i, run) => run()\n  }) {\n    if (this.options.taps.length <= 1) {\n      return this.callTapsSeries({\n        onError,\n        onResult,\n        onDone,\n        rethrowIfPossible\n      });\n    }\n\n    let code = \"\";\n    code += \"do {\\n\";\n    code += `var _counter = ${this.options.taps.length};\\n`;\n\n    if (onDone) {\n      code += \"var _done = () => {\\n\";\n      code += onDone();\n      code += \"};\\n\";\n    }\n\n    for (let i = 0; i < this.options.taps.length; i++) {\n      const done = () => {\n        if (onDone) return \"if(--_counter === 0) _done();\\n\";else return \"--_counter;\";\n      };\n\n      const doneBreak = skipDone => {\n        if (skipDone || !onDone) return \"_counter = 0;\\n\";else return \"_counter = 0;\\n_done();\\n\";\n      };\n\n      code += \"if(_counter <= 0) break;\\n\";\n      code += onTap(i, () => this.callTap(i, {\n        onError: error => {\n          let code = \"\";\n          code += \"if(_counter > 0) {\\n\";\n          code += onError(i, error, done, doneBreak);\n          code += \"}\\n\";\n          return code;\n        },\n        onResult: onResult && (result => {\n          let code = \"\";\n          code += \"if(_counter > 0) {\\n\";\n          code += onResult(i, result, done, doneBreak);\n          code += \"}\\n\";\n          return code;\n        }),\n        onDone: !onResult && (() => {\n          return done();\n        }),\n        rethrowIfPossible\n      }), done, doneBreak);\n    }\n\n    code += \"} while(false);\\n\";\n    return code;\n  }\n\n  args({\n    before,\n    after\n  } = {}) {\n    let allArgs = this._args;\n    if (before) allArgs = [before].concat(allArgs);\n    if (after) allArgs = allArgs.concat(after);\n\n    if (allArgs.length === 0) {\n      return \"\";\n    } else {\n      return allArgs.join(\", \");\n    }\n  }\n\n  getTapFn(idx) {\n    return `_x[${idx}]`;\n  }\n\n  getTap(idx) {\n    return `_taps[${idx}]`;\n  }\n\n  getInterceptor(idx) {\n    return `_interceptors[${idx}]`;\n  }\n\n}\n\nmodule.exports = HookCodeFactory;","map":{"version":3,"sources":["C:/Users/guido/Documents/GitHub/myreactapp/node_modules/globalize-webpack-plugin/node_modules/tapable/lib/HookCodeFactory.js"],"names":["HookCodeFactory","constructor","config","options","undefined","create","init","type","Function","args","header","content","onError","err","onResult","result","onDone","rethrowIfPossible","after","code","setup","instance","_x","taps","map","t","fn","_args","slice","needContext","interceptors","length","i","interceptor","call","getInterceptor","before","context","tap","callTap","tapIndex","hasTapCached","getTap","getTapFn","cbCode","callTapsSeries","firstAsync","findIndex","next","done","doneBreak","skipDone","error","callTapsLooping","syncOnly","every","loop","callTapsParallel","onTap","run","allArgs","concat","join","idx","module","exports"],"mappings":"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","sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\"use strict\";\r\n\r\nclass HookCodeFactory {\r\n\tconstructor(config) {\r\n\t\tthis.config = config;\r\n\t\tthis.options = undefined;\r\n\t}\r\n\r\n\tcreate(options) {\r\n\t\tthis.init(options);\r\n\t\tswitch(this.options.type) {\r\n\t\t\tcase \"sync\":\r\n\t\t\t\treturn new Function(this.args(), \"\\\"use strict\\\";\\n\" + this.header() + this.content({\r\n\t\t\t\t\tonError: err => `throw ${err};\\n`,\r\n\t\t\t\t\tonResult: result => `return ${result};\\n`,\r\n\t\t\t\t\tonDone: () => \"\",\r\n\t\t\t\t\trethrowIfPossible: true\r\n\t\t\t\t}));\r\n\t\t\tcase \"async\":\r\n\t\t\t\treturn new Function(this.args({\r\n\t\t\t\t\tafter: \"_callback\"\r\n\t\t\t\t}), \"\\\"use strict\\\";\\n\" + this.header() + this.content({\r\n\t\t\t\t\tonError: err => `_callback(${err});\\n`,\r\n\t\t\t\t\tonResult: result => `_callback(null, ${result});\\n`,\r\n\t\t\t\t\tonDone: () => \"_callback();\\n\"\r\n\t\t\t\t}));\r\n\t\t\tcase \"promise\":\r\n\t\t\t\tlet code = \"\";\r\n\t\t\t\tcode += \"\\\"use strict\\\";\\n\";\r\n\t\t\t\tcode += \"return new Promise((_resolve, _reject) => {\\n\";\r\n\t\t\t\tcode += \"var _sync = true;\\n\";\r\n\t\t\t\tcode += this.header();\r\n\t\t\t\tcode += this.content({\r\n\t\t\t\t\tonError: err => {\r\n\t\t\t\t\t\tlet code = \"\";\r\n\t\t\t\t\t\tcode += \"if(_sync)\\n\";\r\n\t\t\t\t\t\tcode += `_resolve(Promise.resolve().then(() => { throw ${err}; }));\\n`;\r\n\t\t\t\t\t\tcode += \"else\\n\";\r\n\t\t\t\t\t\tcode += `_reject(${err});\\n`;\r\n\t\t\t\t\t\treturn code;\r\n\t\t\t\t\t},\r\n\t\t\t\t\tonResult: result => `_resolve(${result});\\n`,\r\n\t\t\t\t\tonDone: () => \"_resolve();\\n\"\r\n\t\t\t\t});\r\n\t\t\t\tcode += \"_sync = false;\\n\";\r\n\t\t\t\tcode += \"});\\n\";\r\n\t\t\t\treturn new Function(this.args(), code);\r\n\t\t}\r\n\t}\r\n\r\n\tsetup(instance, options) {\r\n\t\tinstance._x = options.taps.map(t => t.fn);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {{ type: \"sync\" | \"promise\" | \"async\", taps: Array<Tap>, interceptors: Array<Interceptor> }} options\r\n\t */\r\n\tinit(options) {\r\n\t\tthis.options = options;\r\n\t\tthis._args = options.args.slice();\r\n\t}\r\n\r\n\theader() {\r\n\t\tlet code = \"\";\r\n\t\tif(this.needContext()) {\r\n\t\t\tcode += \"var _context = {};\\n\";\r\n\t\t} else {\r\n\t\t\tcode += \"var _context;\\n\";\r\n\t\t}\r\n\t\tcode += \"var _x = this._x;\\n\";\r\n\t\tif(this.options.interceptors.length > 0) {\r\n\t\t\tcode += \"var _taps = this.taps;\\n\";\r\n\t\t\tcode += \"var _interceptors = this.interceptors;\\n\";\r\n\t\t}\r\n\t\tfor(let i = 0; i < this.options.interceptors.length; i++) {\r\n\t\t\tconst interceptor = this.options.interceptors[i];\r\n\t\t\tif(interceptor.call) {\r\n\t\t\t\tcode += `${this.getInterceptor(i)}.call(${this.args({\r\n\t\t\t\t\tbefore: interceptor.context ? \"_context\" : undefined\r\n\t\t\t\t})});\\n`;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn code;\r\n\t}\r\n\r\n\tneedContext() {\r\n\t\tfor(const tap of this.options.taps)\r\n\t\t\tif(tap.context) return true;\r\n\t\treturn false;\r\n\t}\r\n\r\n\tcallTap(tapIndex, { onError, onResult, onDone, rethrowIfPossible }) {\r\n\t\tlet code = \"\";\r\n\t\tlet hasTapCached = false;\r\n\t\tfor(let i = 0; i < this.options.interceptors.length; i++) {\r\n\t\t\tconst interceptor = this.options.interceptors[i];\r\n\t\t\tif(interceptor.tap) {\r\n\t\t\t\tif(!hasTapCached) {\r\n\t\t\t\t\tcode += `var _tap${tapIndex} = ${this.getTap(tapIndex)};\\n`;\r\n\t\t\t\t\thasTapCached = true;\r\n\t\t\t\t}\r\n\t\t\t\tcode += `${this.getInterceptor(i)}.tap(${interceptor.context ? \"_context, \" : \"\"}_tap${tapIndex});\\n`;\r\n\t\t\t}\r\n\t\t}\r\n\t\tcode += `var _fn${tapIndex} = ${this.getTapFn(tapIndex)};\\n`;\r\n\t\tconst tap = this.options.taps[tapIndex];\r\n\t\tswitch(tap.type) {\r\n\t\t\tcase \"sync\":\r\n\t\t\t\tif(!rethrowIfPossible) {\r\n\t\t\t\t\tcode += `var _hasError${tapIndex} = false;\\n`;\r\n\t\t\t\t\tcode += \"try {\\n\";\r\n\t\t\t\t}\r\n\t\t\t\tif(onResult) {\r\n\t\t\t\t\tcode += `var _result${tapIndex} = _fn${tapIndex}(${this.args({\r\n\t\t\t\t\t\tbefore: tap.context ? \"_context\" : undefined\r\n\t\t\t\t\t})});\\n`;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcode += `_fn${tapIndex}(${this.args({\r\n\t\t\t\t\t\tbefore: tap.context ? \"_context\" : undefined\r\n\t\t\t\t\t})});\\n`;\r\n\t\t\t\t}\r\n\t\t\t\tif(!rethrowIfPossible) {\r\n\t\t\t\t\tcode += \"} catch(_err) {\\n\";\r\n\t\t\t\t\tcode += `_hasError${tapIndex} = true;\\n`;\r\n\t\t\t\t\tcode += onError(\"_err\");\r\n\t\t\t\t\tcode += \"}\\n\";\r\n\t\t\t\t\tcode += `if(!_hasError${tapIndex}) {\\n`;\r\n\t\t\t\t}\r\n\t\t\t\tif(onResult) {\r\n\t\t\t\t\tcode += onResult(`_result${tapIndex}`);\r\n\t\t\t\t}\r\n\t\t\t\tif(onDone) {\r\n\t\t\t\t\tcode += onDone();\r\n\t\t\t\t}\r\n\t\t\t\tif(!rethrowIfPossible) {\r\n\t\t\t\t\tcode += \"}\\n\";\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"async\":\r\n\t\t\t\tlet cbCode = \"\";\r\n\t\t\t\tif(onResult)\r\n\t\t\t\t\tcbCode += `(_err${tapIndex}, _result${tapIndex}) => {\\n`;\r\n\t\t\t\telse\r\n\t\t\t\t\tcbCode += `_err${tapIndex} => {\\n`;\r\n\t\t\t\tcbCode += `if(_err${tapIndex}) {\\n`;\r\n\t\t\t\tcbCode += onError(`_err${tapIndex}`);\r\n\t\t\t\tcbCode += \"} else {\\n\";\r\n\t\t\t\tif(onResult) {\r\n\t\t\t\t\tcbCode += onResult(`_result${tapIndex}`);\r\n\t\t\t\t}\r\n\t\t\t\tif(onDone) {\r\n\t\t\t\t\tcbCode += onDone();\r\n\t\t\t\t}\r\n\t\t\t\tcbCode += \"}\\n\";\r\n\t\t\t\tcbCode += \"}\";\r\n\t\t\t\tcode += `_fn${tapIndex}(${this.args({\r\n\t\t\t\t\tbefore: tap.context ? \"_context\" : undefined,\r\n\t\t\t\t\tafter: cbCode\r\n\t\t\t\t})});\\n`;\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"promise\":\r\n\t\t\t\tcode += `var _hasResult${tapIndex} = false;\\n`;\r\n\t\t\t\tcode += `_fn${tapIndex}(${this.args({\r\n\t\t\t\t\tbefore: tap.context ? \"_context\" : undefined\r\n\t\t\t\t})}).then(_result${tapIndex} => {\\n`;\r\n\t\t\t\tcode += `_hasResult${tapIndex} = true;\\n`;\r\n\t\t\t\tif(onResult) {\r\n\t\t\t\t\tcode += onResult(`_result${tapIndex}`);\r\n\t\t\t\t}\r\n\t\t\t\tif(onDone) {\r\n\t\t\t\t\tcode += onDone();\r\n\t\t\t\t}\r\n\t\t\t\tcode += `}, _err${tapIndex} => {\\n`;\r\n\t\t\t\tcode += `if(_hasResult${tapIndex}) throw _err${tapIndex};\\n`;\r\n\t\t\t\tcode += onError(`_err${tapIndex}`);\r\n\t\t\t\tcode += \"});\\n\";\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\treturn code;\r\n\t}\r\n\r\n\tcallTapsSeries({ onError, onResult, onDone, rethrowIfPossible }) {\r\n\t\tif(this.options.taps.length === 0)\r\n\t\t\treturn onDone();\r\n\t\tconst firstAsync = this.options.taps.findIndex(t => t.type !== \"sync\");\r\n\t\tconst next = i => {\r\n\t\t\tif(i >= this.options.taps.length) {\r\n\t\t\t\treturn onDone();\r\n\t\t\t}\r\n\t\t\tconst done = () => next(i + 1);\r\n\t\t\tconst doneBreak = (skipDone) => {\r\n\t\t\t\tif(skipDone) return \"\";\r\n\t\t\t\treturn onDone();\r\n\t\t\t}\r\n\t\t\treturn this.callTap(i, {\r\n\t\t\t\tonError: error => onError(i, error, done, doneBreak),\r\n\t\t\t\tonResult: onResult && ((result) => {\r\n\t\t\t\t\treturn onResult(i, result, done, doneBreak);\r\n\t\t\t\t}),\r\n\t\t\t\tonDone: !onResult && (() => {\r\n\t\t\t\t\treturn done();\r\n\t\t\t\t}),\r\n\t\t\t\trethrowIfPossible: rethrowIfPossible && (firstAsync < 0 || i < firstAsync)\r\n\t\t\t});\r\n\t\t};\r\n\t\treturn next(0);\r\n\t}\r\n\r\n\tcallTapsLooping({ onError, onDone, rethrowIfPossible }) {\r\n\t\tif(this.options.taps.length === 0)\r\n\t\t\treturn onDone();\r\n\t\tconst syncOnly = this.options.taps.every(t => t.type === \"sync\");\r\n\t\tlet code = \"\";\r\n\t\tif(!syncOnly) {\r\n\t\t\tcode += \"var _looper = () => {\\n\";\r\n\t\t\tcode += \"var _loopAsync = false;\\n\";\r\n\t\t}\r\n\t\tcode += \"var _loop;\\n\";\r\n\t\tcode += \"do {\\n\";\r\n\t\tcode += \"_loop = false;\\n\";\r\n\t\tfor(let i = 0; i < this.options.interceptors.length; i++) {\r\n\t\t\tconst interceptor = this.options.interceptors[i];\r\n\t\t\tif(interceptor.loop) {\r\n\t\t\t\tcode += `${this.getInterceptor(i)}.loop(${this.args({\r\n\t\t\t\t\tbefore: interceptor.context ? \"_context\" : undefined\r\n\t\t\t\t})});\\n`;\r\n\t\t\t}\r\n\t\t}\r\n\t\tcode += this.callTapsSeries({\r\n\t\t\tonError,\r\n\t\t\tonResult: (i, result, next, doneBreak) => {\r\n\t\t\t\tlet code = \"\";\r\n\t\t\t\tcode += `if(${result} !== undefined) {\\n`;\r\n\t\t\t\tcode += \"_loop = true;\\n\";\r\n\t\t\t\tif(!syncOnly)\r\n\t\t\t\t\tcode += \"if(_loopAsync) _looper();\\n\";\r\n\t\t\t\tcode += doneBreak(true);\r\n\t\t\t\tcode += `} else {\\n`;\r\n\t\t\t\tcode += next();\r\n\t\t\t\tcode += `}\\n`;\r\n\t\t\t\treturn code;\r\n\t\t\t},\r\n\t\t\tonDone: onDone && (() => {\r\n\t\t\t\tlet code = \"\";\r\n\t\t\t\tcode += \"if(!_loop) {\\n\";\r\n\t\t\t\tcode += onDone();\r\n\t\t\t\tcode += \"}\\n\";\r\n\t\t\t\treturn code;\r\n\t\t\t}),\r\n\t\t\trethrowIfPossible: rethrowIfPossible && syncOnly\r\n\t\t})\r\n\t\tcode += \"} while(_loop);\\n\";\r\n\t\tif(!syncOnly) {\r\n\t\t\tcode += \"_loopAsync = true;\\n\";\r\n\t\t\tcode += \"};\\n\";\r\n\t\t\tcode += \"_looper();\\n\";\r\n\t\t}\r\n\t\treturn code;\r\n\t}\r\n\r\n\tcallTapsParallel({ onError, onResult, onDone, rethrowIfPossible, onTap = (i, run) => run() }) {\r\n\t\tif(this.options.taps.length <= 1) {\r\n\t\t\treturn this.callTapsSeries({ onError, onResult, onDone, rethrowIfPossible })\r\n\t\t}\r\n\t\tlet code = \"\";\r\n\t\tcode += \"do {\\n\";\r\n\t\tcode += `var _counter = ${this.options.taps.length};\\n`;\r\n\t\tif(onDone) {\r\n\t\t\tcode += \"var _done = () => {\\n\";\r\n\t\t\tcode += onDone();\r\n\t\t\tcode += \"};\\n\";\r\n\t\t}\r\n\t\tfor(let i = 0; i < this.options.taps.length; i++) {\r\n\t\t\tconst done = () => {\r\n\t\t\t\tif(onDone)\r\n\t\t\t\t\treturn \"if(--_counter === 0) _done();\\n\";\r\n\t\t\t\telse\r\n\t\t\t\t\treturn \"--_counter;\";\r\n\t\t\t};\r\n\t\t\tconst doneBreak = (skipDone) => {\r\n\t\t\t\tif(skipDone || !onDone)\r\n\t\t\t\t\treturn \"_counter = 0;\\n\";\r\n\t\t\t\telse\r\n\t\t\t\t\treturn \"_counter = 0;\\n_done();\\n\";\r\n\t\t\t}\r\n\t\t\tcode += \"if(_counter <= 0) break;\\n\";\r\n\t\t\tcode += onTap(i, () => this.callTap(i, {\r\n\t\t\t\tonError: error => {\r\n\t\t\t\t\tlet code = \"\";\r\n\t\t\t\t\tcode += \"if(_counter > 0) {\\n\";\r\n\t\t\t\t\tcode += onError(i, error, done, doneBreak);\r\n\t\t\t\t\tcode += \"}\\n\";\r\n\t\t\t\t\treturn code;\r\n\t\t\t\t},\r\n\t\t\t\tonResult: onResult && ((result) => {\r\n\t\t\t\t\tlet code = \"\";\r\n\t\t\t\t\tcode += \"if(_counter > 0) {\\n\";\r\n\t\t\t\t\tcode += onResult(i, result, done, doneBreak);\r\n\t\t\t\t\tcode += \"}\\n\";\r\n\t\t\t\t\treturn code;\r\n\t\t\t\t}),\r\n\t\t\t\tonDone: !onResult && (() => {\r\n\t\t\t\t\treturn done();\r\n\t\t\t\t}),\r\n\t\t\t\trethrowIfPossible\r\n\t\t\t}), done, doneBreak);\r\n\t\t}\r\n\t\tcode += \"} while(false);\\n\";\r\n\t\treturn code;\r\n\t}\r\n\r\n\targs({ before, after } = {}) {\r\n\t\tlet allArgs = this._args;\r\n\t\tif(before) allArgs = [before].concat(allArgs);\r\n\t\tif(after) allArgs = allArgs.concat(after);\r\n\t\tif(allArgs.length === 0) {\r\n\t\t\treturn \"\";\r\n\t\t} else {\r\n\t\t\treturn allArgs.join(\", \");\r\n\t\t}\r\n\t}\r\n\r\n\tgetTapFn(idx) {\r\n\t\treturn `_x[${idx}]`;\r\n\t}\r\n\r\n\tgetTap(idx) {\r\n\t\treturn `_taps[${idx}]`;\r\n\t}\r\n\r\n\tgetInterceptor(idx) {\r\n\t\treturn `_interceptors[${idx}]`;\r\n\t}\r\n}\r\n\r\nmodule.exports = HookCodeFactory;\r\n"]},"metadata":{},"sourceType":"script"}